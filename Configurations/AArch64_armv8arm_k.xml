<?xml version="1.0" encoding="utf-8" standalone="no"?>
<documentation>
	<document id="armv8arm" name="ARM Architecture Reference Manual" version="A.k">
		<path>/path/to/DDI0487A_k_armv8_arm.pdf</path>
	</document>
	<elements>
		<group type="reg" name="A64 General Purpose Registers">
			<hint page="59" header="64-bit General Purpose Register" doc_id="armv8arm" token="X0">Possible purpose:
- return value register
- argument register</hint>
			<hint page="59" header="64-bit General Purpose Register" doc_id="armv8arm" token="X1">Possible purpose:
- argument register
- scratch register
- caller-saved register</hint>
			<hint page="59" header="64-bit General Purpose Register" doc_id="armv8arm" token="X2">Possible purpose:
- argument register
- scratch register
- caller-saved register</hint>
			<hint page="59" header="64-bit General Purpose Register" doc_id="armv8arm" token="X3">Possible purpose:
- argument register
- scratch register
- caller-saved register</hint>
			<hint page="59" header="64-bit General Purpose Register" doc_id="armv8arm" token="X4">Possible purpose:
- argument register
- scratch register
- caller-saved register</hint>
			<hint page="59" header="64-bit General Purpose Register" doc_id="armv8arm" token="X5">Possible purpose:
- argument register
- scratch register
- caller-saved register</hint>
			<hint page="59" header="64-bit General Purpose Register" doc_id="armv8arm" token="X6">Possible purpose:
- argument register
- scratch register
- caller-saved register</hint>
			<hint page="59" header="64-bit General Purpose Register" doc_id="armv8arm" token="X7">Possible purpose:
- argument register
- scratch register
- caller-saved register</hint>
			<hint page="59" header="64-bit General Purpose Register" doc_id="armv8arm" token="X8">Possible purpose:
- indirect result register (XR)</hint>
			<hint page="59" header="64-bit General Purpose Register" doc_id="armv8arm" token="X9">Possible purpose:
- caller-saved temporary register</hint>
			<hint page="59" header="64-bit General Purpose Register" doc_id="armv8arm" token="X10">Possible purpose:
- caller-saved temporary register</hint>
			<hint page="59" header="64-bit General Purpose Register" doc_id="armv8arm" token="X11">Possible purpose:
- caller-saved temporary register</hint>
			<hint page="59" header="64-bit General Purpose Register" doc_id="armv8arm" token="X12">Possible purpose:
- caller-saved temporary register</hint>
			<hint page="59" header="64-bit General Purpose Register" doc_id="armv8arm" token="X12">Possible purpose:
- caller-saved temporary register</hint>
			<hint page="59" header="64-bit General Purpose Register" doc_id="armv8arm" token="X14">Possible purpose:
- caller-saved temporary register</hint>
			<hint page="59" header="64-bit General Purpose Register" doc_id="armv8arm" token="X15">Possible purpose:
- caller-saved temporary register</hint>
			<hint page="59" header="64-bit General Purpose Regisfter" doc_id="armv8arm" token="X16">Possible purpose:
- intra-procedure-call temporary register (IP0)</hint>
			<hint page="59" header="64-bit General Purpose Register" doc_id="armv8arm" token="X17">Possible purpose:
- intra-procedure-call temporary register (IP1)</hint>
			<hint page="59" header="64-bit General Purpose Register" doc_id="armv8arm" token="X18">Possible purpose:
- platform register (PR), reserved for the use of platform ABIs</hint>
			<hint page="59" header="64-bit General Purpose Register" doc_id="armv8arm" token="X19">Possible purpose:
- callee-saved registers</hint>
			<hint page="59" header="64-bit General Purpose Register" doc_id="armv8arm" token="X20">Possible purpose:
- callee-saved registers</hint>
			<hint page="59" header="64-bit General Purpose Register" doc_id="armv8arm" token="X21">Possible purpose:
- callee-saved registers</hint>
			<hint page="59" header="64-bit General Purpose Register" doc_id="armv8arm" token="X22">Possible purpose:
- callee-saved registers</hint>
			<hint page="59" header="64-bit General Purpose Register" doc_id="armv8arm" token="X23">Possible purpose:
- callee-saved registers</hint>
			<hint page="59" header="64-bit General Purpose Register" doc_id="armv8arm" token="X24">Possible purpose:
- callee-saved registers</hint>
			<hint page="59" header="64-bit General Purpose Register" doc_id="armv8arm" token="X25">Possible purpose:
- callee-saved registers</hint>
			<hint page="59" header="64-bit General Purpose Register" doc_id="armv8arm" token="X26">Possible purpose:
- callee-saved registers</hint>
			<hint page="59" header="64-bit General Purpose Register" doc_id="armv8arm" token="X27">Possible purpose:
- callee-saved registers</hint>
			<hint page="59" header="64-bit General Purpose Register" doc_id="armv8arm" token="X28">Possible purpose:
- callee-saved registers</hint>
			<hint page="59" header="64-bit General Purpose Register" doc_id="armv8arm" token="X29">Possible purpose:
- frame pointer register (FP)</hint>
			<hint page="59" header="64-bit General Purpose Register" doc_id="armv8arm" token="X30">Possible purpose:
- link register (LR)</hint>
			<hint page="125" header="64-bit Zero Register" doc_id="armv8arm" token="XZR">The name XZR represents the zero register in a 64-bit context.</hint>
			<hint page="59" header="Program Counter Register" doc_id="armv8arm" token="PC">Possible purpose:
- holding the address of the current instruction</hint>
			<hint page="59" header="64-bit Stack Pointer Register" doc_id="armv8arm" token="SP">Represents the current stack pointer in a 64-bit context.</hint>
			<hint page="59" header="Frame Pointer Register" doc_id="armv8arm" token="FP">Possible purpose:
- holds the address of the current frame</hint>
			<hint page="59" header="Link Register Register" doc_id="armv8arm" token="LR">Possible purpose:
- holds return address</hint>
			<hint page="59" header="32-bit General Purpose Register" doc_id="armv8arm" token="W0">Possible purpose:
- return value register
- argument register</hint>
			<hint page="59" header="32-bit General Purpose Register" doc_id="armv8arm" token="W1">Possible purpose:
- argument register
- scratch register
- caller-saved register</hint>
			<hint page="59" header="32-bit General Purpose Register" doc_id="armv8arm" token="W2">Possible purpose:
- argument register
- scratch register
- caller-saved register</hint>
			<hint page="59" header="32-bit General Purpose Register" doc_id="armv8arm" token="W3">Possible purpose:
- argument register
- scratch register
- caller-saved register</hint>
			<hint page="59" header="32-bit General Purpose Register" doc_id="armv8arm" token="W4">Possible purpose:
- argument register
- scratch register
- caller-saved register</hint>
			<hint page="59" header="32-bit General Purpose Register" doc_id="armv8arm" token="W5">Possible purpose:
- argument register
- scratch register
- caller-saved register</hint>
			<hint page="59" header="32-bit General Purpose Register" doc_id="armv8arm" token="W6">Possible purpose:
- argument register
- scratch register
- caller-saved register</hint>
			<hint page="59" header="32-bit General Purpose Register" doc_id="armv8arm" token="W7">Possible purpose:
- argument register
- scratch register
- caller-saved register</hint>
			<hint page="59" header="32-bit General Purpose Register" doc_id="armv8arm" token="W8">Possible purpose:
- indirect result register (XR)</hint>
			<hint page="59" header="32-bit General Purpose Register" doc_id="armv8arm" token="W9">Possible purpose:
- caller-saved temporary register</hint>
			<hint page="59" header="32-bit General Purpose Register" doc_id="armv8arm" token="W10">Possible purpose:
- caller-saved temporary register</hint>
			<hint page="59" header="32-bit General Purpose Register" doc_id="armv8arm" token="W11">Possible purpose:
- caller-saved temporary register</hint>
			<hint page="59" header="32-bit General Purpose Register" doc_id="armv8arm" token="W12">Possible purpose:
- caller-saved temporary register</hint>
			<hint page="59" header="32-bit General Purpose Register" doc_id="armv8arm" token="W12">Possible purpose:
- caller-saved temporary register</hint>
			<hint page="59" header="32-bit General Purpose Register" doc_id="armv8arm" token="W14">Possible purpose:
- caller-saved temporary register</hint>
			<hint page="59" header="32-bit General Purpose Register" doc_id="armv8arm" token="W15">Possible purpose:
- caller-saved temporary register</hint>
			<hint page="59" header="32-bit General Purpose Register" doc_id="armv8arm" token="W16">Possible purpose:
- intra-procedure-call temporary register (IP0)</hint>
			<hint page="59" header="32-bit General Purpose Register" doc_id="armv8arm" token="W17">Possible purpose:
- intra-procedure-call temporary register (IP1)</hint>
			<hint page="59" header="32-bit General Purpose Register" doc_id="armv8arm" token="W18">Possible purpose:
- platform register (PR), reserved for the use of platform ABIs</hint>
			<hint page="59" header="32-bit General Purpose Register" doc_id="armv8arm" token="W19">Possible purpose:
- callee-saved registers</hint>
			<hint page="59" header="32-bit General Purpose Register" doc_id="armv8arm" token="W20">Possible purpose:
- callee-saved registers</hint>
			<hint page="59" header="32-bit General Purpose Register" doc_id="armv8arm" token="W21">Possible purpose:
- callee-saved registers</hint>
			<hint page="59" header="32-bit General Purpose Register" doc_id="armv8arm" token="W22">Possible purpose:
- callee-saved registers</hint>
			<hint page="59" header="32-bit General Purpose Register" doc_id="armv8arm" token="W23">Possible purpose:
- callee-saved registers</hint>
			<hint page="59" header="32-bit General Purpose Register" doc_id="armv8arm" token="W24">Possible purpose:
- callee-saved registers</hint>
			<hint page="59" header="32-bit General Purpose Register" doc_id="armv8arm" token="W25">Possible purpose:
- callee-saved registers</hint>
			<hint page="59" header="32-bit General Purpose Register" doc_id="armv8arm" token="W26">Possible purpose:
- callee-saved registers</hint>
			<hint page="59" header="32-bit General Purpose Register" doc_id="armv8arm" token="W27">Possible purpose:
- callee-saved registers</hint>
			<hint page="59" header="32-bit General Purpose Register" doc_id="armv8arm" token="W28">Possible purpose:
- callee-saved registers</hint>
			<hint page="59" header="32-bit General Purpose Register" doc_id="armv8arm" token="W29">Possible purpose:
- frame pointer register (FP)</hint>
			<hint page="59" header="32-bit General Purpose Register" doc_id="armv8arm" token="W30">Possible purpose:
- link register (LR)</hint>
			<hint page="125" header="32-bit Zero Register" doc_id="armv8arm" token="WZR">The name XZR represents the zero register in a 64-bit context.</hint>
			<hint page="123" header="32-bit Stack Pointer Register" doc_id="armv8arm" token="WSP">Represents the current stack pointer in a 32-bit context.</hint>
		</group>
		<group type="reg" name="A64 SIMD and FP Registers">
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="V0">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="V1">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="V2">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="V3">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="V4">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="V5">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="V6">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="V7">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="V8">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="V9">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="V10">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="V11">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="V12">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="V12">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="V14">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="V15">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="V16">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="V17">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="V18">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="V19">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="V20">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="V21">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="V22">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="V23">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="V24">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="V25">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="V26">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="V27">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="V28">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="V29">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="V30">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="Q0">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="Q1">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="Q2">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="Q3">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="Q4">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="Q5">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="Q6">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="Q7">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="Q8">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="Q9">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="Q10">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="Q11">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="Q12">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="Q12">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="Q14">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="Q15">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="Q16">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="Q17">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="Q18">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="Q19">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="Q20">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="Q21">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="Q22">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="Q23">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="Q24">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="Q25">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="Q26">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="Q27">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="Q28">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="Q29">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="Q30">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="64-bit SIMD and FP Register" doc_id="armv8arm" token="D0">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="64-bit SIMD and FP Register" doc_id="armv8arm" token="D1">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="64-bit SIMD and FP Register" doc_id="armv8arm" token="D2">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="64-bit SIMD and FP Register" doc_id="armv8arm" token="D3">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="64-bit SIMD and FP Register" doc_id="armv8arm" token="D4">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="64-bit SIMD and FP Register" doc_id="armv8arm" token="D5">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="64-bit SIMD and FP Register" doc_id="armv8arm" token="D6">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="64-bit SIMD and FP Register" doc_id="armv8arm" token="D7">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="64-bit SIMD and FP Register" doc_id="armv8arm" token="D8">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="64-bit SIMD and FP Register" doc_id="armv8arm" token="D9">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="64-bit SIMD and FP Register" doc_id="armv8arm" token="D10">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="64-bit SIMD and FP Register" doc_id="armv8arm" token="D11">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="64-bit SIMD and FP Register" doc_id="armv8arm" token="D12">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="64-bit SIMD and FP Register" doc_id="armv8arm" token="D12">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="64-bit SIMD and FP Register" doc_id="armv8arm" token="D14">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="64-bit SIMD and FP Register" doc_id="armv8arm" token="D15">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="64-bit SIMD and FP Register" doc_id="armv8arm" token="D16">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="64-bit SIMD and FP Register" doc_id="armv8arm" token="D17">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="64-bit SIMD and FP Register" doc_id="armv8arm" token="D18">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="64-bit SIMD and FP Register" doc_id="armv8arm" token="D19">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="64-bit SIMD and FP Register" doc_id="armv8arm" token="D20">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="64-bit SIMD and FP Register" doc_id="armv8arm" token="D21">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="64-bit SIMD and FP Register" doc_id="armv8arm" token="D22">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="64-bit SIMD and FP Register" doc_id="armv8arm" token="D23">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="64-bit SIMD and FP Register" doc_id="armv8arm" token="D24">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="64-bit SIMD and FP Register" doc_id="armv8arm" token="D25">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="64-bit SIMD and FP Register" doc_id="armv8arm" token="D26">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="64-bit SIMD and FP Register" doc_id="armv8arm" token="D27">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="64-bit SIMD and FP Register" doc_id="armv8arm" token="D28">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="64-bit SIMD and FP Register" doc_id="armv8arm" token="D29">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="64-bit SIMD and FP Register" doc_id="armv8arm" token="D30">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="32-bit SIMD and FP Register" doc_id="armv8arm" token="S0">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="32-bit SIMD and FP Register" doc_id="armv8arm" token="S1">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="32-bit SIMD and FP Register" doc_id="armv8arm" token="S2">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="32-bit SIMD and FP Register" doc_id="armv8arm" token="S3">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="32-bit SIMD and FP Register" doc_id="armv8arm" token="S4">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="32-bit SIMD and FP Register" doc_id="armv8arm" token="S5">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="32-bit SIMD and FP Register" doc_id="armv8arm" token="S6">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="32-bit SIMD and FP Register" doc_id="armv8arm" token="S7">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="32-bit SIMD and FP Register" doc_id="armv8arm" token="S8">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="32-bit SIMD and FP Register" doc_id="armv8arm" token="S9">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="32-bit SIMD and FP Register" doc_id="armv8arm" token="S10">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="32-bit SIMD and FP Register" doc_id="armv8arm" token="S11">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="32-bit SIMD and FP Register" doc_id="armv8arm" token="S12">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="32-bit SIMD and FP Register" doc_id="armv8arm" token="S12">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="32-bit SIMD and FP Register" doc_id="armv8arm" token="S14">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="32-bit SIMD and FP Register" doc_id="armv8arm" token="S15">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="32-bit SIMD and FP Register" doc_id="armv8arm" token="S16">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="32-bit SIMD and FP Register" doc_id="armv8arm" token="S17">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="32-bit SIMD and FP Register" doc_id="armv8arm" token="S18">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="32-bit SIMD and FP Register" doc_id="armv8arm" token="S19">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="32-bit SIMD and FP Register" doc_id="armv8arm" token="S20">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="32-bit SIMD and FP Register" doc_id="armv8arm" token="S21">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="32-bit SIMD and FP Register" doc_id="armv8arm" token="S22">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="32-bit SIMD and FP Register" doc_id="armv8arm" token="S23">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="32-bit SIMD and FP Register" doc_id="armv8arm" token="S24">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="32-bit SIMD and FP Register" doc_id="armv8arm" token="S25">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="32-bit SIMD and FP Register" doc_id="armv8arm" token="S26">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="32-bit SIMD and FP Register" doc_id="armv8arm" token="S27">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="32-bit SIMD and FP Register" doc_id="armv8arm" token="S28">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="32-bit SIMD and FP Register" doc_id="armv8arm" token="S29">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="32-bit SIMD and FP Register" doc_id="armv8arm" token="S30">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="16-bit SIMD and FP Register" doc_id="armv8arm" token="H0">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="16-bit SIMD and FP Register" doc_id="armv8arm" token="H1">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="16-bit SIMD and FP Register" doc_id="armv8arm" token="H2">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="16-bit SIMD and FP Register" doc_id="armv8arm" token="H3">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="16-bit SIMD and FP Register" doc_id="armv8arm" token="H4">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="16-bit SIMD and FP Register" doc_id="armv8arm" token="H5">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="16-bit SIMD and FP Register" doc_id="armv8arm" token="H6">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="16-bit SIMD and FP Register" doc_id="armv8arm" token="H7">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="16-bit SIMD and FP Register" doc_id="armv8arm" token="H8">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="16-bit SIMD and FP Register" doc_id="armv8arm" token="H9">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="16-bit SIMD and FP Register" doc_id="armv8arm" token="H10">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="16-bit SIMD and FP Register" doc_id="armv8arm" token="H11">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="16-bit SIMD and FP Register" doc_id="armv8arm" token="H12">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="16-bit SIMD and FP Register" doc_id="armv8arm" token="H12">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="16-bit SIMD and FP Register" doc_id="armv8arm" token="H14">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="16-bit SIMD and FP Register" doc_id="armv8arm" token="H15">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="16-bit SIMD and FP Register" doc_id="armv8arm" token="H16">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="16-bit SIMD and FP Register" doc_id="armv8arm" token="H17">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="16-bit SIMD and FP Register" doc_id="armv8arm" token="H18">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="16-bit SIMD and FP Register" doc_id="armv8arm" token="H19">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="16-bit SIMD and FP Register" doc_id="armv8arm" token="H20">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="16-bit SIMD and FP Register" doc_id="armv8arm" token="H21">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="16-bit SIMD and FP Register" doc_id="armv8arm" token="H22">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="16-bit SIMD and FP Register" doc_id="armv8arm" token="H23">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="16-bit SIMD and FP Register" doc_id="armv8arm" token="H24">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="16-bit SIMD and FP Register" doc_id="armv8arm" token="H25">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="16-bit SIMD and FP Register" doc_id="armv8arm" token="H26">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="16-bit SIMD and FP Register" doc_id="armv8arm" token="H27">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="16-bit SIMD and FP Register" doc_id="armv8arm" token="H28">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="16-bit SIMD and FP Register" doc_id="armv8arm" token="H29">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="16-bit SIMD and FP Register" doc_id="armv8arm" token="H30">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="8-bit SIMD and FP Register" doc_id="armv8arm" token="B0">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="8-bit SIMD and FP Register" doc_id="armv8arm" token="B1">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="8-bit SIMD and FP Register" doc_id="armv8arm" token="B2">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="8-bit SIMD and FP Register" doc_id="armv8arm" token="B3">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="8-bit SIMD and FP Register" doc_id="armv8arm" token="B4">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="8-bit SIMD and FP Register" doc_id="armv8arm" token="B5">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="8-bit SIMD and FP Register" doc_id="armv8arm" token="B6">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="8-bit SIMD and FP Register" doc_id="armv8arm" token="B7">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="8-bit SIMD and FP Register" doc_id="armv8arm" token="B8">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="8-bit SIMD and FP Register" doc_id="armv8arm" token="B9">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="8-bit SIMD and FP Register" doc_id="armv8arm" token="B10">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="8-bit SIMD and FP Register" doc_id="armv8arm" token="B11">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="8-bit SIMD and FP Register" doc_id="armv8arm" token="B12">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="8-bit SIMD and FP Register" doc_id="armv8arm" token="B12">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="8-bit SIMD and FP Register" doc_id="armv8arm" token="B14">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="8-bit SIMD and FP Register" doc_id="armv8arm" token="B15">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="8-bit SIMD and FP Register" doc_id="armv8arm" token="B16">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="8-bit SIMD and FP Register" doc_id="armv8arm" token="B17">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="8-bit SIMD and FP Register" doc_id="armv8arm" token="B18">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="8-bit SIMD and FP Register" doc_id="armv8arm" token="B19">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="8-bit SIMD and FP Register" doc_id="armv8arm" token="B20">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="8-bit SIMD and FP Register" doc_id="armv8arm" token="B21">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="8-bit SIMD and FP Register" doc_id="armv8arm" token="B22">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="8-bit SIMD and FP Register" doc_id="armv8arm" token="B23">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="8-bit SIMD and FP Register" doc_id="armv8arm" token="B24">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="8-bit SIMD and FP Register" doc_id="armv8arm" token="B25">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="8-bit SIMD and FP Register" doc_id="armv8arm" token="B26">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="8-bit SIMD and FP Register" doc_id="armv8arm" token="B27">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="8-bit SIMD and FP Register" doc_id="armv8arm" token="B28">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="8-bit SIMD and FP Register" doc_id="armv8arm" token="B29">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="8-bit SIMD and FP Register" doc_id="armv8arm" token="B30">Possible purpose:
- callee optionally preserved register</hint>
		</group>
		<group type="reg" name="A64 Special-purpose Registers">
			<hint page="294" header="Current Exception Level" doc_id="armv8arm" token="CurrentEL">Holds the current Exception level.
   [31:4] - Reserved, RES0.
EL [ 3:2] - Current Exception level:
            00 EL0
            01 EL1
            10 EL2
            11 EL3
   [ 1:0] - Reserved, RES0.</hint>
			<hint page="296" header="Interrupt Mask Bits" doc_id="armv8arm" token="DAIF">Allows access to the interrupt mask bits.
[31:10] - Reserved, RES0.
D [ 9 ] - Process state D mask:
          0 Watchpoint, Breakpoint, and Software Step at the current EL are not masked.
          1 Watchpoint, Breakpoint, and Software Step at the current EL are masked.
A [ 8 ] - SError interrupt mask bit:
          0 Exception not masked.
          1 Exception masked.
I [ 7 ] - IRQ mask bit:
          0 Exception not masked.
          1 Exception masked.
F [ 6 ] - FIQ mask bit:
          0 Exception not masked.
          1 Exception masked.
[ 5: 0] - Reserved, RES0.</hint>
			<hint page="2177" header="Debug Link Register" doc_id="armv8arm" token="DLR_EL0">In Debug state, holds the address to restart from.</hint>
			<hint page="2180" header="Debug Saved Program Status Register" doc_id="armv8arm" token="DSPSR_EL0">Holds the saved process state when entering from AArch64 and exiting Debug state to AArch64.
N, bit [31]  - Set to the value of the N condition flag.
Z, bit [30]  - Set to the value of the Z condition flag.
C, bit [29]  - Set to the value of the C condition flag.
V, bit [28]  - Set to the value of the V condition flag.
Bits [27:22] - Reserved, RES0.
SS, bit [21] - Software step. Shows the value of PSTATE.SS immediately 
               before Debug state was entered.
IL, bit [20] - Illegal Execution state bit. Shows the value of PSTATE.IL 
               immediately before Debug state was entered.
Bits [19:10] - Reserved, RES0.
D, bit [9]   - Process state D mask.
               0 Watchpoint, Breakpoint, and Software Step exceptions are not masked.
               1 Watchpoint, Breakpoint, and Software Step exceptions are masked.
A, bit [8]   - SError interrupt mask bit.
               0 Exception not masked.
               1 Exception masked.
I, bit [7]   - IRQ mask bit.
               0 Exception not masked.
               1 Exception masked.
F, bit [6]   - FIQ mask bit.
               0 Exception not masked.
               1 Exception masked.
Bit [5]      - Reserved, RES0.
M[4], bit [4] - Execution state that Debug state was entered from.
               0 Exception taken from AArch64.
M[3:0], bits [3:0] - AArch64 mode that Debug state was entered from.
               0b0000 EL0t      
               0b0100 EL1t      M[3:2] holds the Exception Level.
               0b0101 EL1h      M[1] is unused and is RES0 for all non-reserved values. 
               0b1000 EL2t      M[0] is used to select the SP: 
               0b1001 EL2h           0 means the SP is always SP0.
               0b1100 EL3t           1 means the exception SP is determined by the EL.
               0b1101 EL3h</hint>
			<hint page="300" header="Exception Link Register (EL1)" doc_id="armv8arm" token="ELR_EL1">When taking an exception to EL1, holds the address to return to.</hint>
			<hint page="301" header="Exception Link Register (EL2)" doc_id="armv8arm" token="ELR_EL2">When taking an exception to EL2, holds the address to return to.</hint>
			<hint page="303" header="Exception Link Register (EL3)" doc_id="armv8arm" token="ELR_EL3">When taking an exception to EL3, holds the address to return to.</hint>
			<hint page="304" header="Floating-point Control Register" doc_id="armv8arm" token="FPCR">Controls floating-point behavior.
Bits [31:27]  - Reserved, RES0.
AHP, bit [26] - Alternative half-precision control bit:
                0 IEEE half-precision format selected.
                1 Alternative half-precision format selected.
DN, bit [25]  - Default NaN mode control bit:
                0 NaN operands propagate through to the output of a floating-point operation.
                1 Any operation involving one or more NaNs returns the Default NaN.
FZ, bit [24]  - Flush-to-zero mode control bit:
                0 Flush-to-zero mode disabled. Behavior of the floating-point system is 
                  fully compliant with the IEEE 754 standard.
                1 Flush-to-zero mode enabled.
RMode, bits [23:22] - Rounding Mode control field. The encoding of this field is:
                00 Round to Nearest (RN) mode
                01 Round towards Plus Infinity (RP) mode
                10 Round towards Minus Infinity (RM) mode
                11 Round towards Zero (RZ) mode.
Stride, bits [21:20] - This field has no function in AArch64, and non-zero values are 
                ignored during AArch64 execution
Bit [19]      - Reserved, RES0.
Len, bits [18:16] - This field has no function in AArch64, and non-zero values are 
                ignored during AArch64 execution.
IDE, bit [15] - Input Denormal exception trap enable.
                0 Untrapped exception handling selected.
                1 Trapped exception handling selected.
Bits [14:13]  - Reserved, RES0.
IXE, bit [12] - Inexact exception trap enable.
                0 Untrapped exception handling selected.
                1 Trapped exception handling selected. 
UFE, bit [11] - Underflow exception trap enable.
                0 Untrapped exception handling selected.
                1 Trapped exception handling selected.
OFE, bit [10] - Overflow exception trap enable.
                0 Untrapped exception handling selected.
                1 Trapped exception handling selected.
DZE, bit [9]  - Division by Zero exception trap enable.
                0 Untrapped exception handling selected.
                1 Trapped exception handling selected.
IOE, bit [8]  - Invalid Operation exception trap enable.
                0 Untrapped exception handling selected.
                1 Trapped exception handling selected.
Bits [7:0]    - Reserved, RES0.</hint>
			<hint page="308" header="Floating-point Status Register" doc_id="armv8arm" token="FPSR">Provides floating-point system status information.
N, bit [31]  - Negative condition, floating-point comparisons set the PSTATE.N flag
Z, bit [30]  - Zero condition, floating-point comparisons set the PSTATE.Z flag
C, bit [29]  - Carry condition, floating-point comparisons set the PSTATE.C flag
V, bit [28]  - Overflow condition flag, floating-point comparisons set the PSTATE.C flag
QC, bit [27] - Cumulative saturation bit
Bits [26:8]  - Reserved, RES0.
IDC, bit [7] - Input Denormal cumulative exception bit. 
Bits [6:5]   - Reserved, RES0.
IXC, bit [4] - Inexact cumulative exception bit.
UFC, bit [3] - Underflow cumulative exception bit. 
OFC, bit [2] - Overflow cumulative exception bit. 
DZC, bit [1] - Division by Zero cumulative exception bit.
IOC, bit [0] - Invalid Operation cumulative exception bit.</hint>
			<hint page="311" header="Condition Flags" doc_id="armv8arm" token="NZCV">Allows access to the condition flags.
N, bit [31] - Negative condition flag. 
              Set to 1 if the result of the last flag-setting instruction was negative.
Z, bit [30] - Zero condition flag.
              Set to 1 if the result of the last flag-setting instruction was zero, and to 0 otherwise. 
              A result of zero often indicates an equal result from a comparison.
C, bit [29] - Carry condition flag. 
              Set to 1 if the last flag-setting instruction resulted in a carry condition.
V, bit [28] - Overflow condition flag. 
              Set to 1 if the last flag-setting instruction resulted in an overflow condition.
Bits [27:0] - Reserved, RES0.</hint>
			<hint page="313" header="Stack Pointer (EL0)" doc_id="armv8arm" token="SP_EL0">Holds the stack pointer associated with EL0.
At higher Exception levels, this is used as the current stack pointer 
when the value of SPSel.SP is 0.</hint>
			<hint page="314" header="Stack Pointer (EL1)" doc_id="armv8arm" token="SP_EL1">Holds the stack pointer associated with EL1.
When executing at EL1, the value of SPSel.SP determines 
the current stack pointer:
0 SP_EL0
1 SP_EL1</hint>
			<hint page="316" header="Stack Pointer (EL2)" doc_id="armv8arm" token="SP_EL2">Holds the stack pointer associated with EL2. 
When executing at EL2, the value of SPSel.SP determines 
the current stack pointer:
0 SP_EL0
1 SP_EL2</hint>
			<hint page="318" header="SP_EL3, Stack Pointer (EL3)" doc_id="armv8arm" token="SP_EL3">Holds the stack pointer associated with EL3. 
When executing at EL3, the value of SPSel.SP determines 
the current stack pointer:
0 SP_EL0
1 SP_EL3</hint>
			<hint page="319" header="Stack Pointer Select" doc_id="armv8arm" token="SPSEL">Allows the Stack Pointer to be selected between SP_EL0 and SP_ELx.</hint>
			<hint page="323" header="Saved Program Status Register (EL1)" doc_id="armv8arm" token="SPSR_EL1">Holds the saved process state when an exception is taken to EL1.
N, bit [31]  - Set to the value of the N condition flag on exception to EL1.
Z, bit [30]  - Set to the value of the Z condition flag on exception to EL1.
C, bit [29]  - Set to the value of the C condition flag on exception to EL1.
V, bit [28]  - Set to the value of the V condition flag on exception to EL1.
Bits [27:22] - Reserved, RES0.
SS, bit [21] - Software step. Shows the value of PSTATE.SS immediately 
               before exception was taken.
IL, bit [20] - Illegal Execution state bit. Shows the value of PSTATE.IL 
               immediately before exception was taken.
Bits [19:10] - Reserved, RES0.
D, bit [9]   - Process state D mask.
               0 Watchpoint, Breakpoint, and Software Step exceptions are not masked.
               1 Watchpoint, Breakpoint, and Software Step exceptions are masked.
A, bit [8]   - SError interrupt mask bit.
               0 Exception not masked.
               1 Exception masked.
I, bit [7]   - IRQ mask bit.
               0 Exception not masked.
               1 Exception masked.
F, bit [6]   - FIQ mask bit.
               0 Exception not masked.
               1 Exception masked.
Bit [5]      - Reserved, RES0.
M[4], bit [4] - Execution state that the exception was taken from.
               0 Exception taken from AArch64.
M[3:0], bits [3:0] - AArch64 mode that an exception was taken from.
               0b0000 EL0t      M[3:2] holds the Exception Level.
               0b0100 EL1t      M[1] is unused and is RES0 for all non-reserved values. 
               0b0101 EL1h      M[0] is used to select the SP: 
                                     0 means the SP is always SP0.
                                     1 means the exception SP is determined by the EL.</hint>
			<hint page="328" header="Saved Program Status Register (EL2)" doc_id="armv8arm" token="SPSR_EL2">Holds the saved process state when an exception is taken to EL2.
N, bit [31]  - Set to the value of the N condition flag on exception to EL2.
Z, bit [30]  - Set to the value of the Z condition flag on exception to EL2.
C, bit [29]  - Set to the value of the C condition flag on exception to EL2.
V, bit [28]  - Set to the value of the V condition flag on exception to EL2.
Bits [27:22] - Reserved, RES0.
SS, bit [21] - Software step. Shows the value of PSTATE.SS immediately 
               before exception was taken.
IL, bit [20] - Illegal Execution state bit. Shows the value of PSTATE.IL 
               immediately before exception was taken.
Bits [19:10] - Reserved, RES0.
D, bit [9]   - Process state D mask.
               0 Watchpoint, Breakpoint, and Software Step exceptions are not masked.
               1 Watchpoint, Breakpoint, and Software Step exceptions are masked.
A, bit [8]   - SError interrupt mask bit.
               0 Exception not masked.
               1 Exception masked.
I, bit [7]   - IRQ mask bit.
               0 Exception not masked.
               1 Exception masked.
F, bit [6]   - FIQ mask bit.
               0 Exception not masked.
               1 Exception masked.
Bit [5]      - Reserved, RES0.
M[4], bit [4] - Execution state that the exception was taken from.
               0 Exception taken from AArch64.
M[3:0], bits [3:0] - AArch64 mode that an exception was taken from.
               0b0000 EL0t      M[3:2] holds the Exception Level.
               0b0100 EL1t      M[1] is unused and is RES0 for all non-reserved values. 
               0b0101 EL1h      M[0] is used to select the SP: 
               0b1000 EL2t           0 means the SP is always SP0.
               0b1001 EL2h           1 means the exception SP is determined by the EL.</hint>
			<hint page="333" header="Saved Program Status Register (EL3)" doc_id="armv8arm" token="SPSR_EL3">Holds the saved process state when an exception is taken to EL3.
N, bit [31]  - Set to the value of the N condition flag on exception to EL2.
Z, bit [30]  - Set to the value of the Z condition flag on exception to EL2.
C, bit [29]  - Set to the value of the C condition flag on exception to EL2.
V, bit [28]  - Set to the value of the V condition flag on exception to EL2.
Bits [27:22] - Reserved, RES0.
SS, bit [21] - Software step. Shows the value of PSTATE.SS immediately 
               before exception was taken.
IL, bit [20] - Illegal Execution state bit. Shows the value of PSTATE.IL 
               immediately before exception was taken.
Bits [19:10] - Reserved, RES0.
D, bit [9]   - Process state D mask.
               0 Watchpoint, Breakpoint, and Software Step exceptions are not masked.
               1 Watchpoint, Breakpoint, and Software Step exceptions are masked.
A, bit [8]   - SError interrupt mask bit.
               0 Exception not masked.
               1 Exception masked.
I, bit [7]   - IRQ mask bit.
               0 Exception not masked.
               1 Exception masked.
F, bit [6]   - FIQ mask bit.
               0 Exception not masked.
               1 Exception masked.
Bit [5]      - Reserved, RES0.
M[4], bit [4] - Execution state that the exception was taken from.
               0 Exception taken from AArch64.
M[3:0], bits [3:0] - AArch64 mode that an exception was taken from.
               0b0000 EL0t      
               0b0100 EL1t      M[3:2] holds the Exception Level.
               0b0101 EL1h      M[1] is unused and is RES0 for all non-reserved values. 
               0b1000 EL2t      M[0] is used to select the SP: 
               0b1001 EL2h           0 means the SP is always SP0.
               0b1100 EL3t           1 means the exception SP is determined by the EL.
               0b1101 EL3h</hint>
			<hint page="1530" header="Accessing PSTATE.{D, A, I, F} using MSR" doc_id="armv8arm" token="DAIFSET">Directly sets any of the PSTATE.{D,A, I, F} bits to 1</hint>
			<hint page="1530" header="Accessing PSTATE.{D, A, I, F} using MSR" doc_id="armv8arm" token="DAIFCLR">Directly clears any of the PSTATE.{D, A, I, F} bits to 0</hint>
		</group>
		<group type="reg" name="A64 System Registers (cache maintenance)">
			<hint page="348" header="Data or unified Cache line Clean and Invalidate by Set/Way" doc_id="armv8arm" token="CISW">Clean and Invalidate data cache by set/way.

Bits [63:32] - Reserved, RES0.
SetWay, bits [31:4] - Contains fields:
             Way, bits[31:32-A], the number of the way to operate on.
             Set, bits[B-1:L], the number of the set to operate on.
             Bits[L-1:4] are RES0.
Level, bits [3:1] - Cache level to operate on, minus 1
Bit [0]      - Reserved, RES0.

Example: DC CISW, &lt;Xt&gt;</hint>
			<hint page="350" header="Data or unified Cache line Clean and Invalidate by VA to PoC" doc_id="armv8arm" token="CIVAC">Clean and Invalidate data cache by address to Point of Coherency.

Bits [63:0] - Virtual address to use.

Example: DC CIVAC, &lt;Xt&gt;</hint>
			<hint page="352" header="Data or unified Cache line Clean by Set/Way" doc_id="armv8arm" token="CSW">Clean data cache by set/way.

Bits [63:32] - Reserved, RES0.
SetWay, bits [31:4] - Contains fields:
             Way, bits[31:32-A], the number of the way to operate on.
             Set, bits[B-1:L], the number of the set to operate on.
             Bits[L-1:4] are RES0.
Level, bits [3:1] - Cache level to operate on, minus 1
Bit [0]      - Reserved, RES0.

Example: DC CSW, &lt;Xt&gt;</hint>
			<hint page="353" header="Data or unified Cache line Clean by VA to PoC" doc_id="armv8arm" token="CVAC">Clean data cache by address to Point of Coherency.

Bits [63:0] - Virtual address to use.

Example: DC CVAC, &lt;Xt&gt;</hint>
			<hint page="354" header="Data or unified Cache line Clean by VA to PoU" doc_id="armv8arm" token="CVAU">Clean data cache by address to Point of Unification.

Bits [63:0] - Virtual address to use.

Example: DC CVAU, &lt;Xt&gt;</hint>
			<hint page="355" header="Data or unified Cache line Invalidate by Set/Way" doc_id="armv8arm" token="ISW">Invalidate data cache by set/way.

Bits [63:32] - Reserved, RES0.
SetWay, bits [31:4] - Contains fields:
             Way, bits[31:32-A], the number of the way to operate on.
             Set, bits[B-1:L], the number of the set to operate on.
             Bits[L-1:4] are RES0.
Level, bits [3:1] - Cache level to operate on, minus 1
Bit [0]      - Reserved, RES0.

Example: DC ISW, &lt;Xt&gt;</hint>
			<hint page="357" header="Data or unified Cache line Invalidate by VA to PoC" doc_id="armv8arm" token="IVAC">Invalidate data cache by address to Point of Coherency.
Bits [63:0] - Virtual address to use.

Example: DC IVAC, &lt;Xt&gt;</hint>
			<hint page="359" header="Data Cache Zero by VA" doc_id="armv8arm" token="ZVA">Zero data cache by address. 
Zeroes a naturally aligned block of N bytes, where the size of N is identified in DCZID_EL0.

Bits [63:0] - Virtual address to use. There is no alignment restriction on the address 
              within the block of N bytes that is used.

Example: DC ZVA, &lt;Xt&gt;</hint>
			<hint page="361" header="Instruction Cache Invalidate All to PoU" doc_id="armv8arm" token="IALLU">Invalidate all instruction caches to Point of Unification.

Example: IC IALLU</hint>
			<hint page="362" header="Instruction Cache Invalidate All to PoU, Inner Shareable" doc_id="armv8arm" token="IALLUIS">Invalidate all instruction caches in Inner Shareable domain to Point of Unification.

Example: IC IALLUIS</hint>
			<hint page="363" header="Instruction Cache line Invalidate by VA to PoU" doc_id="armv8arm" token="IVAU">Invalidate instruction cache by address to Point of Unification.

Bits [63:0] - Virtual address to use.

Example: IC IVAU, &lt;Xt&gt;</hint>
		</group>
		<group type="reg" name="A64 System Registers (address translation)">
			<hint page="366" header="Address Translate Stages 1 and 2 EL0 Read " doc_id="armv8arm" token="S12E0R">Performs stage 1 and 2 address translations as defined for EL0, 
with permissions as if reading from the given virtual address.

Bits [63:0] - Input address for translation. The resulting 
              address can be read from the PAR_EL1.

Example: AT S12E0R, &lt;Xt&gt;</hint>
			<hint page="367" header="Address Translate Stages 1 and 2 EL0 Write" doc_id="armv8arm" token="S12E0W">Performs stage 1 and 2 address translations as defined for EL0, 
with permissions as if writing to the given virtual address.

Bits [63:0] - Input address for translation. The resulting 
              address can be read from the PAR_EL1.

Example: AT S12E0W, &lt;Xt&gt;</hint>
			<hint page="368" header="Address Translate Stages 1 and 2 EL1 Read" doc_id="armv8arm" token="S12E1R">Performs stage 1 and 2 address translations as defined for EL1, 
with permissions as if reading from the given virtual address.

Bits [63:0] - Input address for translation. The resulting 
              address can be read from the PAR_EL1.

Example: AT S12E1R, &lt;Xt&gt;</hint>
			<hint page="369" header="Address Translate Stages 1 and 2 EL1 Write" doc_id="armv8arm" token="S12E1W">Performs stage 1 and 2 address translations as defined for EL1, 
with permissions as if writing to the given virtual address.

Bits [63:0] - Input address for translation. The resulting 
              address can be read from the PAR_EL1.

Example: AT S12E1W, &lt;Xt&gt;</hint>
			<hint page="370" header="Address Translate Stage 1 EL0 Read" doc_id="armv8arm" token="S1E0R">Performs stage 1 address translation as defined for EL0, 
with permissions as if reading from the given virtual address.

Bits [63:0] - Input address for translation. The resulting 
              address can be read from the PAR_EL1.

Example: AT S1E0R, &lt;Xt&gt;</hint>
			<hint page="371" header="Address Translate Stage 1 EL0 Write" doc_id="armv8arm" token="S1E0W">Performs stage 1 address translation as defined for EL0, 
with permissions as if writing to the given virtual address.

Bits [63:0] - Input address for translation. The resulting 
              address can be read from the PAR_EL1.

Example: AT S1E0W, &lt;Xt&gt;</hint>
			<hint page="372" header="Address Translate Stage 1 EL1 Read " doc_id="armv8arm" token="S1E1R">Performs stage 1 address translation as defined for EL1, 
with permissions as if reading from the given virtual address.

Bits [63:0] - Input address for translation. The resulting 
              address can be read from the PAR_EL1.

Example: AT S1E1R, &lt;Xt&gt;</hint>
			<hint page="373" header="Address Translate Stage 1 EL1 Write" doc_id="armv8arm" token="S1E1W">Performs stage 1 address translation as defined for EL1, 
with permissions as if writing to the given virtual address.

Bits [63:0] - Input address for translation. The resulting 
              address can be read from the PAR_EL1.

Example: AT S1E1W, &lt;Xt&gt;</hint>
			<hint page="374" header="Address Translate Stage 1 EL2 Read" doc_id="armv8arm" token="S1E2R">Performs stage 1 address translation as defined for EL2, 
with permissions as if reading from the given virtual address.

Bits [63:0] - Input address for translation. The resulting 
              address can be read from the PAR_EL1.

Example: AT S1E2R, &lt;Xt&gt;</hint>
			<hint page="375" header="Address Translate Stage 1 EL2 Write" doc_id="armv8arm" token="S1E2W">Performs stage 1 address translation as defined for EL2, 
with permissions as if writing to the given virtual address.

Bits [63:0] - Input address for translation. The resulting 
              address can be read from the PAR_EL1.

Example: AT S1E2W, &lt;Xt&gt;</hint>
			<hint page="376" header="Address Translate Stage 1 EL3 Read" doc_id="armv8arm" token="S1E3R">Performs stage 1 address translation as defined for EL3, 
with permissions as if reading from the given virtual address.

Bits [63:0] - Input address for translation. The resulting 
              address can be read from the PAR_EL1.

Example: AT S1E3R, &lt;Xt&gt;</hint>
			<hint page="377" header="Address Translate Stage 1 EL3 Write" doc_id="armv8arm" token="S1E3W">Performs stage 1 address translation as defined for EL3, 
with permissions as if writing to the given virtual address.

Bits [63:0] - Input address for translation. The resulting 
              address can be read from the PAR_EL1.

AT S1E3W, &lt;Xt&gt;</hint>
		</group>
		<group type="reg" name="A64 System Registers (TLB maintenance)">
			<hint page="379" header="TLB Invalidate All, EL1" doc_id="armv8arm" token="ALLE1">Invalidate all EL1&amp;0 regime stage 1 and 2 TLB entries.

Example: TLBI ALLE1</hint>
			<hint page="380" header="TLB Invalidate All, EL1, Inner Shareable" doc_id="armv8arm" token="ALLE1IS">Invalidate all EL1&amp;0 regime stage 1 and 2 TLB entries on 
all PEs in the same Inner Shareable domain.

Example: TLBI ALLE1IS</hint>
			<hint page="381" header="TLB Invalidate All, EL2" doc_id="armv8arm" token="ALLE2">Invalidate all EL2 regime stage 1 TLB entries.

Example: TLBI ALLE2</hint>
			<hint page="382" header="TLB Invalidate All, EL2, Inner Shareable" doc_id="armv8arm" token="ALLE2IS">Invalidate all EL2 regime stage 1 TLB entries on all PEs 
in the same Inner Shareable domain.

Example: TLBI ALLE2IS</hint>
			<hint page="383" header="TLB Invalidate All, EL3" doc_id="armv8arm" token="ALLE3">Invalidate all EL3 regime stage 1 TLB entries.

Example: TLBI ALLE3</hint>
			<hint page="384" header="TLB Invalidate All, EL3, Inner Shareable" doc_id="armv8arm" token="ALLE3IS">Invalidate all EL3 regime stage 1 TLB entries on all 
PEs in the same Inner Shareable domain.

Example: TLBI ALLE3IS</hint>
			<hint page="385" header="TLB Invalidate by ASID, EL1" doc_id="armv8arm" token="ASIDE1">Invalidate EL1&amp;0 regime stage 1 TLB entries for 
the given ASID and the current VMID.

ASID, bits [63:48] - ASID value to match. Any appropriate TLB 
                     entries that match the ASID values will 
                     be affected by this operation.
Bits [47:0]        - Reserved, RES0.


Example: TLBI ASIDE1, &lt;Xt&gt;</hint>
			<hint page="387" header="TLB Invalidate by ASID, EL1, Inner Shareable" doc_id="armv8arm" token="ASIDE1IS">Invalidate EL1&amp;0 regime stage 1 TLB entries for the given ASID and 
the current VMID on all PEs in the same Inner Shareable domain.

ASID, bits [63:48] - ASID value to match. Any appropriate TLB entries 
                     that match the ASID values will be affected by 
                     this operation.
Bits [47:0]        - Reserved, RES0.

Example: TLBI ASIDE1IS, &lt;Xt&gt;</hint>
			<hint page="389" header="TLB Invalidate by Intermediate Physical Address, Stage 2, EL1" doc_id="armv8arm" token="IPAS2E1">Invalidate EL1&amp;0 regime stage 2 TLB entries for the given IPA 
and the current VMID.

Bits [63:36]           - Reserved, RES0.
IPA[47:12], bits[35:0] - Bits[47:12] of the intermediate physical 
                         address to match.

Example: TLBI IPAS2E1, &lt;Xt&gt;</hint>
			<hint page="390" header="TLB Invalidate by Intermediate Physical Address, Stage 2, EL1, Inner Shareable" doc_id="armv8arm" token="IPAS2E1IS">Invalidate EL1&amp;0 regime stage 2 TLB entries for the given IPA and the current 
VMID on all PEs in the same Inner Shareable domain.

Bits [63:36]           - Reserved, RES0.
IPA[47:12], bits[35:0] - Bits[47:12] of the intermediate physical 
                         address to match.

Example: TLBI IPAS2E1IS, &lt;Xt&gt;</hint>
			<hint page="392" header="TLB Invalidate by Intermediate Physical Address, Stage 2, Last level, EL1" doc_id="armv8arm" token="IPAS2LE1">Invalidate EL1&amp;0 regime stage 2 TLB entries for the last level of translation, 
the given IPA, and the current VMID.

Bits [63:36]           - Reserved, RES0.
IPA[47:12], bits[35:0] - Bits[47:12] of the intermediate physical 
                         address to match.

Example: TLBI IPAS2LE1, &lt;Xt&gt;</hint>
			<hint page="393" header="TLB Invalidate by Intermediate Physical Address, Stage 2, Last level, EL1, Inner Shareable" doc_id="armv8arm" token="IPAS2LE1IS">Invalidate EL1&amp;0 regime stage 2 TLB entries for the last level of translation, 
the given IPA, and the current VMID, on all PEs in the same 
Inner Shareable domain.

Bits [63:36]           - Reserved, RES0.
IPA[47:12], bits[35:0] - Bits[47:12] of the intermediate physical 
                         address to match.

Example: TLBI IPAS2LE1IS, &lt;Xt&gt;</hint>
			<hint page="395" header="TLB Invalidate by VA, All ASID, EL1" doc_id="armv8arm" token="VAAE1">Invalidate EL1&amp;0 regime stage 1 TLB entries for the 
given VA and the current VMID.

Bits [63:44]           - Reserved, RES0.
VA[55:12], bits [43:0] - Bits[55:12] of the virtual address to match. 
                         Any appropriate TLB entries that match the VA 
                         will be affected by this operation, regardless 
                         of the ASID. 

Example: TLBI VAAE1, &lt;Xt&gt;</hint>
			<hint page="397" header="TLB Invalidate by VA, All ASID, EL1, Inner Shareable" doc_id="armv8arm" token="VAAE1IS">Invalidate EL1&amp;0 regime stage 1 TLB entries for the given VA and the 
current VMID on all PEs in the same Inner Shareable domain.

Bits [63:44]           - Reserved, RES0.
VA[55:12], bits [43:0] - Bits[55:12] of the virtual address to match. 
                         Any appropriate TLB entries that match the VA 
                         will be affected by this operation, regardless 
                         of the ASID. 

Example: TLBI VAAE1IS, &lt;Xt&gt;</hint>
			<hint page="399" header="TLB Invalidate by VA, All ASID, Last level, EL1" doc_id="armv8arm" token="VAALE1">Invalidate EL1&amp;0 regime stage 1 TLB entries for the last level of 
translation table walk, the given VA, and the current VMID.

Bits [63:44]           - Reserved, RES0.
VA[55:12], bits [43:0] - Bits[55:12] of the virtual address to match. 
                         Any appropriate TLB entries that match the VA 
                         will be affected by this operation, regardless 
                         of the ASID. 

Example: TLBI VAALE1, &lt;Xt&gt;</hint>
			<hint page="401" header="TLB Invalidate by VA, All ASID, EL1, Inner Shareable" doc_id="armv8arm" token="VAALE1IS">Invalidate EL1&amp;0 regime stage 1 TLB entries for the last level of 
translation table walk, the given VA, and the current VMID, on all 
PEs in the same Inner Shareable domain.

Bits [63:44]           - Reserved, RES0.
VA[55:12], bits [43:0] - Bits[55:12] of the virtual address to match. 
                         Any appropriate TLB entries that match the VA 
                         will be affected by this operation, regardless 
                         of the ASID. 

Example: TLBI VAALE1IS, &lt;Xt&gt;</hint>
			<hint page="403" header="TLB Invalidate by VA, EL1" doc_id="armv8arm" token="VAE1">Invalidate EL1&amp;0 regime stage 1 TLB entries for the given VA and 
ASID and the current VMID.

ASID, bits [63:48]     - ASID value to match. Any TLB entries that match 
                         the ASID value and VA value will be affected by 
                         this operation.
                         Global TLB entries that match the VA value will 
                         be affected by this operation, regardless of the 
                         value of the ASID field.
Bits [47:44]           - Reserved, RES0
VA[55:12], bits [43:0] - Bits[55:12] of the virtual address to match. Any 
                         appropriate TLB entries that match the ASID value 
                         (if appropriate) and VA will be affected by this 
                         operation.

Example: TLBI VAE1, &lt;Xt&gt;</hint>
			<hint page="405" header="TLB Invalidate by VA, EL1, Inner Shareable" doc_id="armv8arm" token="VAE1IS">Invalidate EL1&amp;0 regime stage 1 TLB entries for the given VA and ASID, and 
the current VMID, on all PEs in the same Inner Shareable domain.

ASID, bits [63:48]     - ASID value to match. Any TLB entries that match 
                         the ASID value and VA value will be affected by 
                         this operation.
                         Global TLB entries that match the VA value will 
                         be affected by this operation, regardless of the 
                         value of the ASID field.
Bits [47:44]           - Reserved, RES0
VA[55:12], bits [43:0] - Bits[55:12] of the virtual address to match. Any 
                         appropriate TLB entries that match the ASID value 
                         (if appropriate) and VA will be affected by this 
                         operation.

Example: TLBI VAE1IS, &lt;Xt&gt;</hint>
			<hint page="407" header="TLB Invalidate by VA, EL2" doc_id="armv8arm" token="VAE2">Invalidate EL2 regime stage 1 TLB entries for the given VA.

Bits [63:44]           - Reserved, RES0.
VA[55:12], bits [43:0] - Bits[55:12] of the virtual address to match. 
                         Any appropriate TLB entries that match the 
                         ASID value (if appropriate) and VA will be 
                         affected by this operation.

Example: TLBI VAE2, &lt;Xt&gt;</hint>
			<hint page="409" header="" doc_id="armv8arm" token="VAE2IS">Invalidate EL2 regime stage 1 TLB entries for the given VA on all PEs 
in the same Inner Shareable domain.

Bits [63:44]           - Reserved, RES0.
VA[55:12], bits [43:0] - Bits[55:12] of the virtual address to match. 
                         Any appropriate TLB entries that match the 
                         ASID value (if appropriate) and VA will be 
                         affected by this operation. 

Example: TLBI VAE2IS, &lt;Xt&gt;</hint>
			<hint page="411" header="TLB Invalidate by VA, EL3" doc_id="armv8arm" token="VAE3">Invalidate EL3 regime stage 1 TLB entries for the given VA.

Bits [63:44]           - Reserved, RES0.
VA[55:12], bits [43:0] - Bits[55:12] of the virtual address to match. 
                         Any appropriate TLB entries that match the 
                         ASID value (if appropriate) and VA will be 
                         affected by this operation. 

Example: TLBI VAE3, &lt;Xt</hint>
			<hint page="413" header="TLB Invalidate by VA, EL3, Inner Shareable" doc_id="armv8arm" token="VAE3IS">Invalidate EL3 regime stage 1 TLB entries for the given VA on 
all PEs in the same Inner Shareable domain.

Bits [63:44]           - Reserved, RES0.
VA[55:12], bits [43:0] - Bits[55:12] of the virtual address to match. 
                         Any appropriate TLB entries that match the 
                         ASID value (if appropriate) and VA will be 
                         affected by this operation. 

Example: TLBI VAE3IS, &lt;Xt&gt;</hint>
			<hint page="415" header="TLB Invalidate by VA, Last level, EL1" doc_id="armv8arm" token="VALE1">Invalidate EL1&amp;0 regime stage 1 TLB entries for the last level of 
translation table walk, the given VA and ASID, and the current VMID.

ASID, bits [63:48]     - ASID value to match. Any TLB entries that match 
                         the ASID value and VA value will be affected by 
                         this operation.
                         Global TLB entries that match the VA value will 
                         be affected by this operation, regardless of the 
                         value of the ASID field.
Bits [47:44]           - Reserved, RES0
VA[55:12], bits [43:0] - Bits[55:12] of the virtual address to match. Any 
                         appropriate TLB entries that match the ASID value 
                         (if appropriate) and VA will be affected by this 
                         operation.

Example: TLBI VALE1, &lt;Xt&gt;</hint>
			<hint page="417" header="TLB Invalidate by VA, Last level, EL1, Inner Shareable" doc_id="armv8arm" token="VALE1IS">Invalidate EL1&amp;0 regime stage 1 TLB entries for the last level of 
translation table walk, the given VA and ASID, and the current VMID, 
on all PEs in the same Inner Shareable domain.

ASID, bits [63:48]     - ASID value to match. Any TLB entries that match 
                         the ASID value and VA value will be affected by 
                         this operation.
                         Global TLB entries that match the VA value will 
                         be affected by this operation, regardless of the 
                         value of the ASID field.
Bits [47:44]           - Reserved, RES0
VA[55:12], bits [43:0] - Bits[55:12] of the virtual address to match. Any 
                         appropriate TLB entries that match the ASID value 
                         (if appropriate) and VA will be affected by this 
                         operation.

Example: TLBI VALE1IS, &lt;Xt&gt;</hint>
			<hint page="419" header="TLB Invalidate by VA, Last level, EL2" doc_id="armv8arm" token="VALE2">Invalidate EL2 regime stage 1 TLB entries for the last level 
of translation table walk and the given VA.

Bits [63:44]           - Reserved, RES0.
VA[55:12], bits [43:0] - Bits[55:12] of the virtual address to match. 
                         Any appropriate TLB entries that match the 
                         ASID value (if appropriate) and VA will be 
                         affected by this operation. 

Example: TLBI VALE2, &lt;Xt&gt;</hint>
			<hint page="421" header="TLB Invalidate by VA, Last level, EL2, Inner Shareable" doc_id="armv8arm" token="VALE2IS">Invalidate EL2 regime stage 1 TLB entries for the last level of 
translation table walk and the given VA on all PEs in the same 
Inner Shareable domain.

Bits [63:44]           - Reserved, RES0.
VA[55:12], bits [43:0] - Bits[55:12] of the virtual address to match. 
                         Any appropriate TLB entries that match the 
                         ASID value (if appropriate) and VA will be 
                         affected by this operation. 

Example: TLBI VALE2IS, &lt;Xt&gt;</hint>
			<hint page="423" header="TLB Invalidate by VA, Last level, EL3" doc_id="armv8arm" token="VALE3">Invalidate EL3 regime stage 1 TLB entries for the last level of 
translation table walk and the given VA.

Bits [63:44]           - Reserved, RES0.
VA[55:12], bits [43:0] - Bits[55:12] of the virtual address to match. 
                         Any appropriate TLB entries that match the 
                         ASID value (if appropriate) and VA will be 
                         affected by this operation. 

Example: TLBI VALE3, &lt;Xt&gt;</hint>
			<hint page="425" header="TLB Invalidate by VA, Last level, EL3, Inner Shareable" doc_id="armv8arm" token="VALE3IS">Invalidate EL3 regime stage 1 TLB entries for the last level of 
translation table walk and the given VA on all PEs in the same 
Inner Shareable domain.

Bits [63:44]           - Reserved, RES0.
VA[55:12], bits [43:0] - Bits[55:12] of the virtual address to match. 
                         Any appropriate TLB entries that match the 
                         ASID value (if appropriate) and VA will be 
                         affected by this operation. 

Example: TLBI VALE3IS, &lt;Xt&gt;</hint>
			<hint page="427" header="TLB Invalidate by VMID, All at stage 1, EL1" doc_id="armv8arm" token="VMALLE1">Invalidate all EL1&amp;0 regime stage 1 TLB entries for the current VMID.

Example: TLBI VMALLE1</hint>
			<hint page="428" header="TLB Invalidate by VMID, All at stage 1, EL1, Inner Shareable" doc_id="armv8arm" token="VMALLE1IS">Invalidate all EL1&amp;0 regime stage 1 TLB entries for the current 
VMID on all PEs in the same Inner Shareable domain.

Example: TLBI VMALLE1IS</hint>
			<hint page="429" header="TLB Invalidate by VMID, All at Stage 1 and 2, EL1" doc_id="armv8arm" token="VMALLS12E1">Invalidate all EL1&amp;0 regime stage 1 and 2 TLB entries 
for the current VMID.

Example: TLBI VMALLS12E1</hint>
			<hint page="430" header="TLB Invalidate by VMID, All at Stage 1 and 2, EL1, Inner Shareable" doc_id="armv8arm" token="VMALLS12E1IS">Invalidate all EL1&amp;0 regime stage 1 and 2 TLB entries for the current 
VMID on all PEs in the same Inner Shareable domain.

Example: TLBI VMALLS12E1IS</hint>
		</group>
		<group type="reg" name="A64 System Registers (Control)">
			<hint page="1896" header="Auxiliary Control Register (EL1)" doc_id="armv8arm" token="ACTLR_EL1">Provides IMPLEMENTATION DEFINED configuration and 
control options for execution at EL1 and EL0.

bits [63:0] - IMPLEMENTATION DEFINED</hint>
			<hint page="1897" header="Auxiliary Control Register (EL2)" doc_id="armv8arm" token="ACTLR_EL2">Provides IMPLEMENTATION DEFINED configuration and
control options for EL2.

bits [63:0] - IMPLEMENTATION DEFINED</hint>
			<hint page="1898" header="Auxiliary Control Register (EL3)" doc_id="armv8arm" token="ACTLR_EL3">Provides IMPLEMENTATION DEFINED configuration and
control options for EL3.

bits [63:0] - IMPLEMENTATION DEFINED</hint>
			<hint page="1899" header="Auxiliary Fault Status Register 0 (EL1)" doc_id="armv8arm" token="AFSR0_EL1">Provides additional IMPLEMENTATION DEFINED fault 
status information for exceptions taken to EL1.

bits [31:0] - IMPLEMENTATION DEFINED</hint>
			<hint page="1900" header="Auxiliary Fault Status Register 0 (EL2) " doc_id="armv8arm" token="AFSR0_EL2">Provides additional IMPLEMENTATION DEFINED fault 
status information for exceptions taken to EL2.

bits [31:0] - IMPLEMENTATION DEFINED</hint>
			<hint page="1901" header="Auxiliary Fault Status Register 0 (EL3)" doc_id="armv8arm" token="AFSR0_EL3">Provides additional IMPLEMENTATION DEFINED fault 
status information for exceptions taken to EL3.

bits [31:0] - IMPLEMENTATION DEFINED</hint>
			<hint page="1902" header="Auxiliary Fault Status Register 1 (EL1)" doc_id="armv8arm" token="AFSR1_EL1">Provides additional IMPLEMENTATION DEFINED fault 
status information for exceptions taken to EL1.

bits [31:0] - IMPLEMENTATION DEFINED</hint>
			<hint page="1903" header="AFSR1_EL2, Auxiliary Fault Status Register 1 (EL2)" doc_id="armv8arm" token="AFSR1_EL2">Provides additional IMPLEMENTATION DEFINED fault 
status information for exceptions taken to EL2.

bits [31:0] - IMPLEMENTATION DEFINED</hint>
			<hint page="1904" header="Auxiliary Fault Status Register 1 (EL3)" doc_id="armv8arm" token="AFSR1_EL3">Provides additional IMPLEMENTATION DEFINED fault 
status information for exceptions taken to EL3.

bits [31:0] - IMPLEMENTATION DEFINED</hint>
			<hint page="1905" header="Auxiliary ID Register" doc_id="armv8arm" token="AIDR_EL1">Provides IMPLEMENTATION DEFINED identification information.

bits [31:0] - IMPLEMENTATION DEFINED</hint>
			<hint page="1906" header="Auxiliary Memory Attribute Indirection Register (EL1)" doc_id="armv8arm" token="AMAIR_EL1">Provides IMPLEMENTATION DEFINED memory attributes 
for the memory regions specified by MAIR_EL1.

bits [63:0] - IMPLEMENTATION DEFINED</hint>
			<hint page="1908" header="Auxiliary Memory Attribute Indirection Register (EL2)" doc_id="armv8arm" token="AMAIR_EL2">Provides IMPLEMENTATION DEFINED memory attributes 
for the memory regions specified by MAIR_EL2.

bits [63:0] - IMPLEMENTATION DEFINED</hint>
			<hint page="1909" header="Auxiliary Memory Attribute Indirection Register (EL3)" doc_id="armv8arm" token="AMAIR_EL3">Provides IMPLEMENTATION DEFINED memory attributes 
for the memory regions specified by MAIR_EL3.

bits [63:0] - IMPLEMENTATION DEFINED</hint>
			<hint page="1910" header="Current Cache Size ID Register" doc_id="armv8arm" token="CCSIDR_EL1">Provides information about the architecture 
of the currently selected cache.

              bits [31:28] - Reserved, UNKNOWN.
     NumSets, bits [27:13] - (Number of sets in cache) - 1, therefore 
                             a value of 0 indicates 1 set in the cache. 
                             The number of sets does not have to be a 
                             power of 2.
Associativity, bits [12:3] - (Associativity of cache) - 1, therefore 
                             a value of 0 indicates an associativity 
                             of 1. The associativity does not have 
                             to be a power of 2.
     LineSize, bits [2:0]  - (Log2(Number of bytes in cache line)) - 4.</hint>
			<hint page="1912" header="Cache Level ID Register" doc_id="armv8arm" token="CLIDR_EL1">Identifies the type of cache, or caches, that are implemented at each level 
and can be managed using the architected cache maintenance instructions that 
operate by set/way, up to a maximum of seven levels. Also identifies the 
Level of Coherence (LoC) and Level of Unification (LoU) for the cache hierarchy.

Bits [63:33]       - Reserved, RES0
ICB, bits [32:30]  - Inner cache boundary. This field indicates the boundary for 
                     caching Inner Cacheable memory regions.
                       000 Not disclosed by this mechanism.
                       001 L1 cache is the highest Inner Cacheable level.
                       010 L2 cache is the highest Inner Cacheable level.
                       011 L3 cache is the highest Inner Cacheable level.
                       100 L4 cache is the highest Inner Cacheable level.
                       101 L5 cache is the highest Inner Cacheable level.
                       110 L6 cache is the highest Inner Cacheable level.
                       111 L7 cache is the highest Inner Cacheable level.
LoUU, bits [29:27]  - Level of Unification Uniprocessor for the cache hierarchy.
LoC, bits [26:24]   - Level of Coherence for the cache hierarchy.
LoUIS, bits [23:21] - Level of Unification Inner Shareable for the cache hierarchy.
Ctype&lt;n&gt;, bits [3(n-1)+2:3(n-1)], for n = 1 to 7 - 
                    Cache Type fields. Indicate the type of cache that is implemented 
                    and can be managed using the architected cache maintenance instructions 
                    that operate by set/way at each level, from Level 1 up to a maximum of 
                    seven levels of cache hierarchy.
                      000 No cache.
                      001 Instruction cache only.
                      010 Data cache only.
                      011 Separate instruction and data caches.
                      100 Unified cache.</hint>
			<hint page="1914" header="Context ID Register (EL1)" doc_id="armv8arm" token="CONTEXTIDR_EL1">Identifies the current Process Identifier.
The value of the whole of this register is called the Context ID and is used by:
- The debug logic, for Linked and Unlinked Context ID matching.
- The trace logic, to identify the current process.

PROCID, bits [31:0] - Process Identifier. This field must be programmed with a 
                      unique value that identifies the current process.</hint>
			<hint page="1916" header="Architectural Feature Access Control Register" doc_id="armv8arm" token="CPACR_EL1">Controls access to trace, and to Advanced SIMD and floating-point functionality.

Bits [31:29]       - Reserved, RES0
TTA, bit [28]      - Traps EL0 and EL1 System register accesses to all implemented trace 
                     registers to EL1, from both Execution states.
                       0 EL0 and EL1 System register accesses to all implemented trace 
                         registers are not trapped to EL1.
                       1 EL0 and EL1 System register accesses to all implemented trace 
                         registers are trapped to EL1.
Bits [27:22]       - Reserved, RES0
FPEN, bits [21:20] - Traps EL0 and EL1 accesses to the SIMD and floating-point 
                     registers to EL1, from both Execution states.
                       00 Causes any instructions in EL0 or EL1 that use the registers 
                          associated with floating-point and Advanced SIMD execution to 
                          be trapped.
                       01 Causes any instructions in EL0 that use the registers associated 
                          with floating-point and Advanced SIMD execution to be trapped, 
                          but does not cause any instruction in EL1 to be trapped.
                       10 Causes any instructions in EL0 or EL1 that use the registers 
                          associated with floating-point and Advanced SIMD execution to 
                          be trapped.
                       11 Does not cause any instruction to be trapped.
Bits [19:0]        - Reserved, RES0.</hint>
			<hint page="1918" header="Architectural Feature Trap Register (EL2)" doc_id="armv8arm" token="CPTR_EL2">Controls trapping to EL2 of access to CPACR, CPACR_EL1, trace functionality 
and registers associated with Advanced SIMD and floating-point execution. 
Also controls EL2 access to this functionality.

TCPAC, bit [31] - Traps Non-secure EL1 accesses to the CPACR_EL1 or CPACR to 
                  EL2, from both Execution states. 
                    0 This control has no effect on Non-secure EL1 accesses
                      to the CPACR_EL1 or CPACR. 
                    1 Non-secure EL1 accesses to the CPACR_EL1 or CPACR are 
                      trapped to EL2.
Bits [30:21]    - Reserved, RES0.
TTA, bit [20]   - Traps Non-secure System register accesses to the trace 
                  registers to EL2, from both Execution states.
                    0 Non-secure System register accesses to the trace 
                      registers are not trapped to EL2.
                    1 Any attempt at EL2, or Non-secure EL0 or EL1, to execute
                      a System register access to a trace register is trapped 
                      to EL2, subject to the exception prioritization rules.
Bits [19:14]    - Reserved, RES0.
Bits [13:12]    - Reserved, RES1.
Bit [11]        - Reserved, RES0.
TFP, bit [10]   - Traps Non-secure accesses to SIMD and floating-point 
                  functionality to EL2, from both Execution states.
                    0 Does not cause any instruction to be trapped.
                    1 Any attempt at EL2, or Non-secure EL0 or EL1, to execute
                      an instruction that uses the registers associated with 
                      floating-point and Advanced SIMD execution is trapped to 
                      EL2, subject to the exception prioritization rules.
Bits [9:0]      - Reserved, RES1.</hint>
			<hint page="1920" header="Architectural Feature Trap Register (EL3)" doc_id="armv8arm" token="CPTR_EL3">Controls trapping to EL3 of access to CPACR, CPACR_EL2, trace functionality 
and registers associated with Advanced SIMD and floating-point execution. 
Also controls EL3 access to this functionality.

TCPAC, bit [31] - Traps Non-secure EL3 accesses to the CPACR_EL2 or CPACR to 
                  EL2, from both Execution states. 
                    0 This control does not cause any accesses to CPACR_EL1, 
                      CPTR_EL2, CPACR, or HCPTR to trap to EL3. 
                    1 EL2 accesses to the CPTR_EL2 or HCPTR, and EL2 and EL1 
                      accesses to the CPACR_EL1 or CPACR, are trapped to EL3 
                      if they are not trapped to EL2 by the CPTR_EL2.TCPAC 
                      control.
Bits [30:21]    - Reserved, RES0.
TTA, bit [20]   - Traps System register accesses to the trace registers, from 
                  all Exception levels, both Security states, and both 
                  Execution states, to EL3.
                    0 Does not cause any instruction to be trapped.

                    1 Any System register access to the trace registers is 
                      trapped to EL3, subject to the exception prioritization 
                      rules.
Bits [19:11]    - Reserved, RES0.
TFP, bit [10]   - Traps all accesses to Advanced SIMD and floating-point 
                  functionality, from all Exception levels, both Security states,
                  and both Execution states, to EL3.
                    0 Does not cause any instruction to be trapped.
                    1 Any attempt at any Exception level to execute an instruction 
                      that uses the registers associated with Advanced SIMD and 
                      floating-point is trapped to EL3, subject to the exception 
                      prioritization rules.
Bits [9:0]      - Reserved, RES1.</hint>
			<hint page="1922" header="Cache Size Selection Register" doc_id="armv8arm" token="CSSELR_EL1">Selects the current Cache Size ID Register, CCSIDR_EL1, 
by specifying the required cache level and the cache 
type (either instruction or data cache).

Bits [31:4]       - Reserved, RES0.
Level, bits [3:1] - Cache level of required cache.
                      000 Level 1 cache
                      001 Level 2 cache
                      010 Level 3 cache
                      011 Level 4 cache
                      100 Level 5 cache
                      101 Level 6 cache
                      110 Level 7 cache
InD, bit [0]      - Instruction not Data bit.
                      0 Data or unified cache.
                      1 Instruction cache.</hint>
			<hint page="1924" header="Cache Type Register " doc_id="armv8arm" token="CTR_EL0">Provides information about the architecture of the caches.

TBD</hint>
			<hint page="1926" header="Domain Access Control Register" doc_id="armv8arm" token="DACR32_EL2">Allows access to the AArch32 DACR register from AArch64 state only. 
Its value has no effect on execution in AArch64 state.

TBD</hint>
			<hint page="1928" header="Data Cache Zero ID register" doc_id="armv8arm" token="DCZID_EL0">Indicates the block size that is written with byte values of 0 
by the DC ZVA (Data Cache Zero by Address) system instruction.

TBD</hint>
			<hint page="1930" header="Exception Syndrome Register (EL1) " doc_id="armv8arm" token="ESR_EL1">Holds syndrome information for an exception taken to EL1.

EC, bits [31:26] - Exception Class. Indicates the reason for the 
                   exception that this register holds information about.
IL, bit [25]     - Instruction Length for synchronous exceptions.
ISS, bits [24:0] - Instruction Specific Syndrome. Architecturally, this 
                   field can be defined independently for each defined 
                   Exception class. However, in practice, some ISS encodings 
                   are used for more than one Exception class.</hint>
			<hint page="1931" header="Exception Syndrome Register (EL2)" doc_id="armv8arm" token="ESR_EL2">Holds syndrome information for an exception taken to EL2.

EC, bits [31:26] - Exception Class. Indicates the reason for the 
                   exception that this register holds information about.
IL, bit [25]     - Instruction Length for synchronous exceptions.
ISS, bits [24:0] - Instruction Specific Syndrome. Architecturally, this 
                   field can be defined independently for each defined 
                   Exception class. However, in practice, some ISS encodings 
                   are used for more than one Exception class.</hint>
			<hint page="1932" header="Exception Syndrome Register (EL3)" doc_id="armv8arm" token="ESR_EL3">Holds syndrome information for an exception taken to EL3.

EC, bits [31:26] - Exception Class. Indicates the reason for the 
                   exception that this register holds information about.
IL, bit [25]     - Instruction Length for synchronous exceptions.
ISS, bits [24:0] - Instruction Specific Syndrome. Architecturally, this 
                   field can be defined independently for each defined 
                   Exception class. However, in practice, some ISS encodings 
                   are used for more than one Exception class.</hint>
			<hint page="1965" header="Fault Address Register (EL1)" doc_id="armv8arm" token="FAR_EL1">Holds the faulting Virtual Address for all synchronous Instruction 
or Data Abort, PC alignment fault and Watchpoint exceptions that 
are taken to EL1.

Bits [63:0] - Faulting Virtual Address for synchronous exceptions 
              taken to EL1.</hint>
			<hint page="1967" header="Fault Address Register (EL2)" doc_id="armv8arm" token="FAR_EL2">Holds the faulting Virtual Address for all synchronous Instruction 
or Data Abort, PC alignment fault and Watchpoint exceptions that 
are taken to EL2.

Bits [63:0] - Faulting Virtual Address for synchronous exceptions 
              taken to EL2.</hint>
			<hint page="1969" header="Fault Address Register (EL3)" doc_id="armv8arm" token="FAR_EL3">Holds the faulting Virtual Address for all synchronous Instruction 
or Data Abort, PC alignment fault and Watchpoint exceptions that 
are taken to EL3.

Bits [63:0] - Faulting Virtual Address for synchronous exceptions 
              taken to EL3.</hint>
			<hint page="1971" header="Floating-Point Exception Control register" doc_id="armv8arm" token="FPEXC32_EL2">Allows access to the AArch32 register FPEXC from AArch64 state only. 
Its value has no effect on execution in AArch64 state.

TBD</hint>
			<hint page="1976" header="Hypervisor Auxiliary Control Register" doc_id="armv8arm" token="HACR_EL2">Controls trapping to EL2 of IMPLEMENTATION DEFINED aspects 
of Non-secure EL1 or EL0 operation.

bits [31:0] - IMPLEMENTATION DEFINED</hint>
			<hint page="1977" header="Hypervisor Configuration Register" doc_id="armv8arm" token="HCR_EL2">Provides configuration controls for virtualization, 
including defining whether various Non-secure 
operations are trapped to EL2.

TBD</hint>
			<hint page="1989" header="Hypervisor IPA Fault Address Register" doc_id="armv8arm" token="HPFAR_EL2">Holds the faulting IPA for some aborts on a stage 2 translation taken to EL2.

TBD</hint>
			<hint page="1991" header="Hypervisor System Trap Register" doc_id="armv8arm" token="HSTR_EL2">Controls trapping to Hyp mode of Non-secure accesses, at EL1 or 
lower in AArch32, to the System register in the coproc == 1111 
encoding space, by the CRn value used to access the register 
using MCR or MRC instruction. When the register is accessible 
using an MCRR or MRRC instruction, this is the CRm value used 
to access the register.

TBD</hint>
			<hint page="1993" header="AArch64 Auxiliary Feature Register 0" doc_id="armv8arm" token="ID_AA64AFR0_EL1">Provides information about the IMPLEMENTATION DEFINED 
features of the PE in AArch64.

Bits [63:0] - IMPLEMENTATION DEFINED</hint>
			<hint page="1995" header="AArch64 Auxiliary Feature Register 1" doc_id="armv8arm" token="ID_AA64AFR1_EL1">Reserved for future expansion of information about the 
IMPLEMENTATION DEFINED features of the PE in AArch64.

Bits [63:0] - Reserved, RES0.</hint>
			<hint page="1996" header="AArch64 Debug Feature Register 0" doc_id="armv8arm" token="ID_AA64DFR0_EL1">Provides top level information about the debug system in AArch64.

TBD</hint>
			<hint page="1998" header="AArch64 Debug Feature Register 1" doc_id="armv8arm" token="ID_AA64DFR1_EL1">Reserved for future expansion of top level information about the debug system in AArch64.

Bits [63:0] - Reserved, RES0.</hint>
			<hint page="1999" header="AArch64 Instruction Set Attribute Register 0" doc_id="armv8arm" token="ID_AA64ISAR0_EL1">Provides information about the instructions implemented in AArch64 state.

TBD</hint>
			<hint page="2001" header="AArch64 Instruction Set Attribute Register 1" doc_id="armv8arm" token="ID_AA64ISAR1_EL1">Reserved for future expansion of the information about the 
instructions implemented in AArch64 state.

Bits [63:0] - Reserved, RES0.</hint>
			<hint page="2002" header="AArch64 Memory Model Feature Register 0" doc_id="armv8arm" token="ID_AA64MMFR0_EL1">Provides information about the implemented memory 
model and memory management support in AArch64.

TBD</hint>
			<hint page="2005" header="AArch64 Memory Model Feature Register 1" doc_id="armv8arm" token="ID_AA64MMFR1_EL1">Reserved for future expansion of the information about the implemented 
memory model and memory management support in AArch64.

Bits [63:0] - Reserved, RES0.</hint>
			<hint page="2006" header="AArch64 Processor Feature Register 0" doc_id="armv8arm" token="ID_AA64PFR0_EL1">Provides additional information about implemented PE features in AArch64.

TBD</hint>
			<hint page="2008" header="AArch64 Processor Feature Register 1" doc_id="armv8arm" token="ID_AA64PFR1_EL1">Reserved for future expansion of information 
about implemented PE features in AArch64.

Bits [63:0] - Reserved, RES0.</hint>
			<hint page="2051" header="Instruction Fault Status Register (EL2)" doc_id="armv8arm" token="IFSR32_EL2">Allows access to the AArch32 IFSR register from AArch64 state only. 
Its value has no effect on execution in AArch64 state.

TBD</hint>
			<hint page="2055" header="Interrupt Status Register" doc_id="armv8arm" token="ISR_EL1">Shows whether any IRQ, FIQ, or SError interrupt is pending. 
In an implementation that includes EL2, when the register 
is accessed from Non-secure EL1, a pending interrupt or 
external abort might be physical or virtual, and the 
architecture does not provide any mechanism that software 
executing at Non-secure EL1 can use to determine whether a 
pending interrupt or external abort is physical or virtual. 
For all other accesses, any indicated interrupt or external 
abort must be physical.

TBD</hint>
			<hint page="2057" header="Memory Attribute Indirection Register (EL1)" doc_id="armv8arm" token="MAIR_EL1">Provides the memory attribute encodings corresponding to the 
possible AttrIndx values in a Long-descriptor format 
translation table entry for stage 1 translations at EL1.

TBD</hint>
			<hint page="2059" header="Memory Attribute Indirection Register (EL2)" doc_id="armv8arm" token="MAIR_EL2">Provides the memory attribute encodings corresponding to the 
possible AttrIndx values in a Long-descriptor format translation 
table entry for stage 1 translations at EL2.

TBD</hint>
			<hint page="2061" header="Memory Attribute Indirection Register (EL3)" doc_id="armv8arm" token="MAIR_EL3">Provides the memory attribute encodings corresponding to the 
possible AttrIndx values in a Long-descriptor format translation 
table entry for stage 1 translations at EL3.

TBD</hint>
			<hint page="2063" header="Main ID Register" doc_id="armv8arm" token="MIDR_EL1">Provides identification information for the PE, including an 
implementer code for the device and a device ID number.

TBD</hint>
			<hint page="2065" header="Multiprocessor Affinity Register" doc_id="armv8arm" token="MPIDR_EL1">In a multiprocessor system, provides an additional PE 
identification mechanism for scheduling purposes.

TBD</hint>
			<hint page="2067" header="AArch32 Media and VFP Feature Register 0" doc_id="armv8arm" token="MVFR0_EL1">Describes the features provided by the AArch32 
Advanced SIMD and Floating-point implementation.

TBD</hint>
			<hint page="2070" header="AArch32 Media and VFP Feature Register 1 " doc_id="armv8arm" token="MVFR1_EL1">Describes the features provided by the AArch32 
Advanced SIMD and Floating-point implementation.

TBD</hint>
			<hint page="2073" header="AArch32 Media and VFP Feature Register 2" doc_id="armv8arm" token="MVFR2_EL1">Describes the features provided by the AArch32 
Advanced SIMD and Floating-point implementation.

TBD</hint>
			<hint page="2075" header="Physical Address Register" doc_id="armv8arm" token="PAR_EL1">Returns the output address (OA) from an address translation 
instruction that executed successfully, or fault information 
if the instruction did not execute successfully.

TBD</hint>
			<hint page="2079" header="Revision ID Register" doc_id="armv8arm" token="REVIDR_EL1">Provides implementation-specific minor revision information.

bits [31:0] - IMPLEMENTATION DEFINED</hint>
			<hint page="2080" header="Reset Management Register (if EL2 and EL3 not implemented)" doc_id="armv8arm" token="RMR_EL1">When this register is implemented:
- A write to the register can request a Warm reset.
- If EL1 can use AArch32 and AArch64, this register 
  specifies the Execution state that the PE boots 
  into on a Warm reset.

TBD</hint>
			<hint page="2082" header="Reset Management Register (if EL2 implemented and EL3 not implemented)" doc_id="armv8arm" token="RMR_EL2">When this register is implemented:
- A write to the register can request a Warm reset.
- If EL2 can use AArch32 and AArch64, this register 
  specifies the Execution state that the PE boots 
  into on a Warm reset.

TBD</hint>
			<hint page="2084" header="Reset Management Register (if EL3 implemented) " doc_id="armv8arm" token="RMR_EL3">When this register is implemented:
- A write to the register can request a Warm reset.
- If EL3 can use AArch32 and AArch64, the register 
  specifies the Execution state that the PE boots 
  into on a Warm reset.

TBD</hint>
			<hint page="2086" header="Reset Vector Base Address Register (if EL2 and EL3 not implemented)" doc_id="armv8arm" token="RVBAR_EL1">If EL1 is the highest Exception level implemented, contains 
the IMPLEMENTATION DEFINED address that execution starts 
from after reset when executing in AArch64 state.

Bits [63:0] - Reset Address. The IMPLEMENTATION DEFINED address
              that execution starts from after reset when 
              executing in 64-bit state. Bits[1:0] of this 
              register are 00, as this address must be aligned, 
              and the address must be within the physical 
              address size supported by the PE.</hint>
			<hint page="2087" header="Reset Vector Base Address Register (if EL3 not implemented)" doc_id="armv8arm" token="RVBAR_EL2">If EL2 is the highest Exception level implemented, contains 
the IMPLEMENTATION DEFINED address that execution starts 
from after reset when executing in AArch64 state.

Bits [63:0] - Reset Address. The IMPLEMENTATION DEFINED address 
              that execution starts from after reset when 
              executing in 64-bit state. Bits[1:0] of this 
              register are 00, as this address must be aligned, 
              and the address must be within the physical 
              address size supported by the PE.</hint>
			<hint page="2088" header="Reset Vector Base Address Register (if EL3 implemented) " doc_id="armv8arm" token="RVBAR_EL3">If EL3 is the highest Exception level implemented, contains 
the IMPLEMENTATION DEFINED address that execution starts 
from after reset when executing in AArch64 state.

Bits [63:0] - Reset Address. The IMPLEMENTATION DEFINED address 
              that execution starts from after reset when 
              executing in 64-bit state. Bits[1:0] of this 
              register are 00, as this address must be aligned,
              and the address must be within the physical 
              address size supported by the PE.</hint>
			<hint page="2089" header="S3_&lt;op1&gt;_&lt;Cn&gt;_&lt;Cm&gt;_&lt;op2&gt;, IMPLEMENTATION DEFINED registers" doc_id="armv8arm" token="S3_">This area of the instruction set space is reserved 
for IMPLEMENTATION DEFINED registers.

bits [63:0] - IMPLEMENTATION DEFINED</hint>
			<hint page="2090" header="Secure Configuration Register" doc_id="armv8arm" token="SCR_EL3">Defines the configuration of the current Security state. It specifies:
- The Security state of EL0 and EL1, either Secure or Non-secure.
- The Execution state at lower Exception levels.
- Whether IRQ, FIQ, and External Abort interrupts are taken to EL3.

TBD</hint>
			<hint page="2094" header="System Control Register (EL1)" doc_id="armv8arm" token="SCTLR_EL1">Provides top level control of the system, 
including its memory system, at EL1 and EL0.

TBD</hint>
			<hint page="2101" header="System Control Register (EL2)" doc_id="armv8arm" token="SCTLR_EL2">Provides top level control of the system, 
including its memory system, at EL2.

TBD</hint>
			<hint page="2105" header="System Control Register (EL3)" doc_id="armv8arm" token="SCTLR_EL3">Provides top level control of the system, 
including its memory system, at EL3.

TBD</hint>
			<hint page="2109" header="Translation Control Register (EL1)" doc_id="armv8arm" token="TCR_EL1">Determines which of the Translation Table Base Registers 
defines the base address for a translation table walk 
required for the stage 1 translation of a memory access 
from EL0 or EL1. Also controls the translation table 
format and holds cacheability and shareability information.

TBD</hint>
			<hint page="2114" header="Translation Control Register (EL2)" doc_id="armv8arm" token="TCR_EL2">Controls translation table walks required for the stage 1 
translation of memory accesses from EL2, and holds 
cacheability and shareability information for the accesses.

TBD</hint>
			<hint page="2117" header="Translation Control Register (EL3)" doc_id="armv8arm" token="TCR_EL3">Controls translation table walks required for the stage 1 
translation of memory accesses from EL3, and holds 
cacheability and shareability information for the accesses.

TBD</hint>
			<hint page="2120" header="EL0 Read/Write Software Thread ID Register" doc_id="armv8arm" token="TPIDR_EL0">Provides a location where software executing at EL0 can store 
thread identifying information, for OS management purposes.

Bits [63:0] - Thread ID. Thread identifying information stored 
              by software running at this Exception level.</hint>
			<hint page="2121" header="EL1 Software Thread ID Register" doc_id="armv8arm" token="TPIDR_EL1">Provides a location where software executing at EL1 can store 
thread identifying information, for OS management purposes.

Bits [63:0] - Thread ID. Thread identifying information stored 
              by software running at this Exception level.</hint>
			<hint page="2122" header="EL2 Software Thread ID Register" doc_id="armv8arm" token="TPIDR_EL2">Provides a location where software executing at EL2 can store 
thread identifying information, for OS management purposes.

Bits [63:0] - Thread ID. Thread identifying information stored
              by software running at this Exception level.</hint>
			<hint page="2123" header="EL3 Software Thread ID Register" doc_id="armv8arm" token="TPIDR_EL3">Provides a location where software executing at EL3 can store 
thread identifying information, for OS management purposes.

Bits [63:0] - Thread ID. Thread identifying information stored 
              by software running at this Exception level.</hint>
			<hint page="2124" header="EL0 Read-Only Software Thread ID Register" doc_id="armv8arm" token="TPIDRRO_EL0">Provides a location where software executing at EL1 or higher 
can store thread identifying information that is visible to 
software executing at EL0, for OS management purposes.

Bits [63:0] - Thread ID. Thread identifying information stored 
              by software running at this Exception level.</hint>
			<hint page="2125" header="Translation Table Base Register 0 (EL1)" doc_id="armv8arm" token="TTBR0_EL1">Holds the base address of translation table 0, and information 
about the memory it occupies. 
This is one of the translation tables for the stage 1 
translation of memory accesses at EL0 and EL1.

ASID, bits [63:48] - An ASID for the translation table base address. 
                     The TCR_EL1.A1 field selects either TTBR0_EL1.ASID 
                     or TTBR1_EL1.ASID.
BADDR, bits [47:0] - Translation table base address, bits[47:x].</hint>
			<hint page="2127" header="Translation Table Base Register 0 (EL2)" doc_id="armv8arm" token="TTBR0_EL2">Holds the base address of the translation table for the 
stage 1 translation of memory accesses from EL2.

Bits [63:48]       - Reserved, RES0
BADDR, bits [47:0] - Translation table base address, bits[47:x].</hint>
			<hint page="2129" header="Translation Table Base Register 0 (EL3)" doc_id="armv8arm" token="TTBR0_EL3">Holds the base address of the translation table for the 
stage 1 translation of memory accesses from EL3.

Bits [63:48]       - Reserved, RES0
BADDR, bits [47:0] - Translation table base address, bits[47:x].</hint>
			<hint page="2131" header="Translation Table Base Register 1 (EL1)" doc_id="armv8arm" token="TTBR1_EL1">Holds the base address of translation table 1, and information 
about the memory it occupies.
This is one of the translation tables for the stage 1 
translation of memory accesses at EL0 and EL1.

ASID, bits [63:48] - An ASID for the translation table base address. 
                     The TCR_EL1.A1 field selects either TTBR0_EL1.ASID 
                     or TTBR1_EL1.ASID.
BADDR, bits [47:0] - Translation table base address, bits[47:x].</hint>
			<hint page="2133" header="Vector Base Address Register (EL1)" doc_id="armv8arm" token="VBAR_EL1">Holds the vector base address for any exception that is taken to EL1.

Bits [63:11] - Vector Base Address. Base address of the exception 
               vectors for exceptions taken to EL1.
Bits [10:0]  - Reserved, RES0.</hint>
			<hint page="2135" header="Vector Base Address Register (EL2)" doc_id="armv8arm" token="VBAR_EL2">Holds the vector base address for any exception that is taken to EL2.

Bits [63:11] - Vector Base Address. Base address of the exception 
               vectors for exceptions taken to EL2.
Bits [10:0]  - Reserved, RES0.</hint>
			<hint page="2137" header="Vector Base Address Register (EL3)" doc_id="armv8arm" token="VBAR_EL3">Holds the vector base address for any exception that is taken to EL3.

Bits [63:11] - Vector Base Address. Base address of the exception 
               vectors for exceptions taken to EL3.
Bits [10:0]  - Reserved, RES0.</hint>
			<hint page="2138" header="Virtualization Multiprocessor ID Register" doc_id="armv8arm" token="VMPIDR_EL2">Holds the value of the Virtualization Multiprocessor ID. 
This is the value returned by Non-secure EL1 reads of MPIDR_EL1.

TBD</hint>
			<hint page="2140" header="Virtualization Processor ID Register " doc_id="armv8arm" token="VPIDR_EL2">Holds the value of the Virtualization Processor ID. 
This is the value returned by Non-secure EL1 reads of MIDR_EL1.

TBD</hint>
			<hint page="2142" header="Virtualization Translation Control Register" doc_id="armv8arm" token="VTCR_EL2">Controls the translation table walks required for the stage 2 
translation of memory accesses from Non-secure EL0 and EL1, 
and holds cacheability and shareability information for the accesses.

TBD</hint>
			<hint page="2145" header="Virtualization Translation Table Base Register" doc_id="armv8arm" token="VTTBR_EL2">Holds the base address of the translation table for the stage 2 
translation of memory accesses from Non-secure EL0 and EL1.

TBD</hint>
		</group>
		<group type="reg" name="A64 System Registers (Debug)">
			<hint page="2148" header="Debug Authentication Status register" doc_id="armv8arm" token="DBGAUTHSTATUS_EL1">Provides information about the state of the IMPLEMENTATION DEFINED 
authentication interface for debug.</hint>
			<hint page="2150" header="Debug Breakpoint Control Register 0" doc_id="armv8arm" token="DBGBCR0_EL1">Holds control information for a breakpoint. 
Forms breakpoint 0 together with value register DBGBVR0_EL1.

TBD</hint>
			<hint page="2150" header="Debug Breakpoint Control Register 1" doc_id="armv8arm" token="DBGBCR1_EL1">Holds control information for a breakpoint. 
Forms breakpoint 1 together with value register DBGBVR1_EL1.

TBD</hint>
			<hint page="2150" header="Debug Breakpoint Control Register 2" doc_id="armv8arm" token="DBGBCR2_EL1">Holds control information for a breakpoint. 
Forms breakpoint 2 together with value register DBGBVR2_EL1.

TBD</hint>
			<hint page="2150" header="Debug Breakpoint Control Register 3" doc_id="armv8arm" token="DBGBCR3_EL1">Holds control information for a breakpoint. 
Forms breakpoint 3 together with value register DBGBVR3_EL1.

TBD</hint>
			<hint page="2150" header="Debug Breakpoint Control Register 4" doc_id="armv8arm" token="DBGBCR4_EL1">Holds control information for a breakpoint. 
Forms breakpoint 4 together with value register DBGBVR4_EL1.

TBD</hint>
			<hint page="2150" header="Debug Breakpoint Control Register 5" doc_id="armv8arm" token="DBGBCR5_EL1">Holds control information for a breakpoint. 
Forms breakpoint 5 together with value register DBGBVR5_EL1.

TBD</hint>
			<hint page="2150" header="Debug Breakpoint Control Register 6" doc_id="armv8arm" token="DBGBCR6_EL1">Holds control information for a breakpoint. 
Forms breakpoint 6 together with value register DBGBVR6_EL1.

TBD</hint>
			<hint page="2150" header="Debug Breakpoint Control Register 7" doc_id="armv8arm" token="DBGBCR7_EL1">Holds control information for a breakpoint. 
Forms breakpoint 7 together with value register DBGBVR7_EL1.

TBD</hint>
			<hint page="2150" header="Debug Breakpoint Control Register 8" doc_id="armv8arm" token="DBGBCR8_EL1">Holds control information for a breakpoint. 
Forms breakpoint 8 together with value register DBGBVR8_EL1.

TBD</hint>
			<hint page="2150" header="Debug Breakpoint Control Register 9" doc_id="armv8arm" token="DBGBCR9_EL1">Holds control information for a breakpoint. 
Forms breakpoint 9 together with value register DBGBVR9_EL1.

TBD</hint>
			<hint page="2150" header="Debug Breakpoint Control Register 10" doc_id="armv8arm" token="DBGBCR10_EL1">Holds control information for a breakpoint. 
Forms breakpoint 10 together with value register DBGBVR10_EL1.

TBD</hint>
			<hint page="2150" header="Debug Breakpoint Control Register 11" doc_id="armv8arm" token="DBGBCR11_EL1">Holds control information for a breakpoint. 
Forms breakpoint 11 together with value register DBGBVR11_EL1.

TBD</hint>
			<hint page="2150" header="Debug Breakpoint Control Register 12" doc_id="armv8arm" token="DBGBCR12_EL1">Holds control information for a breakpoint. 
Forms breakpoint 12 together with value register DBGBVR12_EL1.

TBD</hint>
			<hint page="2150" header="Debug Breakpoint Control Register 13" doc_id="armv8arm" token="DBGBCR13_EL1">Holds control information for a breakpoint. 
Forms breakpoint 13 together with value register DBGBVR13_EL1.

TBD</hint>
			<hint page="2150" header="Debug Breakpoint Control Register 14" doc_id="armv8arm" token="DBGBCR14_EL1">Holds control information for a breakpoint. 
Forms breakpoint 14 together with value register DBGBVR14_EL1.

TBD</hint>
			<hint page="2150" header="Debug Breakpoint Control Register 15" doc_id="armv8arm" token="DBGBCR15_EL1">Holds control information for a breakpoint. 
Forms breakpoint 15 together with value register DBGBVR15_EL1.

TBD</hint>
			<hint page="2153" header="Debug Breakpoint Value Register 0" doc_id="armv8arm" token="DBGBVR0_EL1">Holds a virtual address, or a VMID and/or a context ID, for 
use in breakpoint matching. Forms breakpoint 0 together 
with control register DBGBCR0_EL1.

TBD</hint>
			<hint page="2153" header="Debug Breakpoint Value Register 1" doc_id="armv8arm" token="DBGBVR1_EL1">Holds a virtual address, or a VMID and/or a context ID, for 
use in breakpoint matching. Forms breakpoint 1 together 
with control register DBGBCR1_EL1.

TBD</hint>
			<hint page="2153" header="Debug Breakpoint Value Register 2" doc_id="armv8arm" token="DBGBVR2_EL1">Holds a virtual address, or a VMID and/or a context ID, for 
use in breakpoint matching. Forms breakpoint 2 together 
with control register DBGBCR2_EL1.

TBD</hint>
			<hint page="2153" header="Debug Breakpoint Value Register 3" doc_id="armv8arm" token="DBGBVR3_EL1">Holds a virtual address, or a VMID and/or a context ID, for 
use in breakpoint matching. Forms breakpoint 3 together 
with control register DBGBCR3_EL1.

TBD</hint>
			<hint page="2153" header="Debug Breakpoint Value Register 4" doc_id="armv8arm" token="DBGBVR4_EL1">Holds a virtual address, or a VMID and/or a context ID, for 
use in breakpoint matching. Forms breakpoint 4 together 
with control register DBGBCR4_EL1.

TBD</hint>
			<hint page="2153" header="Debug Breakpoint Value Register 5" doc_id="armv8arm" token="DBGBVR5_EL1">Holds a virtual address, or a VMID and/or a context ID, for 
use in breakpoint matching. Forms breakpoint 5 together 
with control register DBGBCR5_EL1.

TBD</hint>
			<hint page="2153" header="Debug Breakpoint Value Register 6" doc_id="armv8arm" token="DBGBVR6_EL1">Holds a virtual address, or a VMID and/or a context ID, for 
use in breakpoint matching. Forms breakpoint 6 together 
with control register DBGBCR6_EL1.

TBD</hint>
			<hint page="2153" header="Debug Breakpoint Value Register 7" doc_id="armv8arm" token="DBGBVR7_EL1">Holds a virtual address, or a VMID and/or a context ID, for 
use in breakpoint matching. Forms breakpoint 7 together 
with control register DBGBCR7_EL1.

TBD</hint>
			<hint page="2153" header="Debug Breakpoint Value Register 8" doc_id="armv8arm" token="DBGBVR8_EL1">Holds a virtual address, or a VMID and/or a context ID, for 
use in breakpoint matching. Forms breakpoint 8 together 
with control register DBGBCR8_EL1.

TBD</hint>
			<hint page="2153" header="Debug Breakpoint Value Register 9" doc_id="armv8arm" token="DBGBVR9_EL1">Holds a virtual address, or a VMID and/or a context ID, for 
use in breakpoint matching. Forms breakpoint 9 together 
with control register DBGBCR9_EL1.

TBD</hint>
			<hint page="2153" header="Debug Breakpoint Value Register 10" doc_id="armv8arm" token="DBGBVR10_EL1">Holds a virtual address, or a VMID and/or a context ID, for 
use in breakpoint matching. Forms breakpoint 10 together 
with control register DBGBCR10_EL1.

TBD</hint>
			<hint page="2153" header="Debug Breakpoint Value Register 11" doc_id="armv8arm" token="DBGBVR11_EL1">Holds a virtual address, or a VMID and/or a context ID, for 
use in breakpoint matching. Forms breakpoint 11 together 
with control register DBGBCR11_EL1.

TBD</hint>
			<hint page="2153" header="Debug Breakpoint Value Register 12" doc_id="armv8arm" token="DBGBVR12_EL1">Holds a virtual address, or a VMID and/or a context ID, for 
use in breakpoint matching. Forms breakpoint 12 together 
with control register DBGBCR12_EL1.

TBD</hint>
			<hint page="2153" header="Debug Breakpoint Value Register 13" doc_id="armv8arm" token="DBGBVR13_EL1">Holds a virtual address, or a VMID and/or a context ID, for 
use in breakpoint matching. Forms breakpoint 13 together 
with control register DBGBCR13_EL1.

TBD</hint>
			<hint page="2153" header="Debug Breakpoint Value Register 14" doc_id="armv8arm" token="DBGBVR14_EL1">Holds a virtual address, or a VMID and/or a context ID, for 
use in breakpoint matching. Forms breakpoint 14 together 
with control register DBGBCR14_EL1.

TBD</hint>
			<hint page="2153" header="Debug Breakpoint Value Register 15" doc_id="armv8arm" token="DBGBVR15_EL1">Holds a virtual address, or a VMID and/or a context ID, for 
use in breakpoint matching. Forms breakpoint 15 together 
with control register DBGBCR15_EL1.

TBD</hint>
			<hint page="2156" header="Debug Claim Tag Clear register" doc_id="armv8arm" token="DBGCLAIMCLR_EL1">Used by software to read the values of the CLAIM tag bits, 
and to clear these bits to 0. The architecture does not 
define any functionality for the CLAIM tag bits.


TBD</hint>
			<hint page="2158" header="Debug Claim Tag Set register " doc_id="armv8arm" token="DBGCLAIMSET_EL1">Used by software to set the CLAIM tag bits to 1.
The architecture does not define any functionality 
for the CLAIM tag bits.

TBD</hint>
			<hint page="2160" header="Debug Data Transfer Register, half-duplex" doc_id="armv8arm" token="DBGDTR_EL0">Transfers 64 bits of data between the PE and an external debugger. 
Can transfer both ways using only a single register.

TBD</hint>
			<hint page="2162" header="Debug Data Transfer Register, Receive" doc_id="armv8arm" token="DBGDTRRX_EL0">Transfers data from an external debugger to the PE. 
For example, it is used by a debugger transferring 
commands and data to a debug target. It is a 
component of the Debug Communications Channel.

TBD</hint>
			<hint page="2164" header="Debug Data Transfer Register, Transmit" doc_id="armv8arm" token="DBGDTRTX_EL0">Transfers data from the PE to an external debugger. 
For example, it is used by a debug target to transfer 
data to the debugger. It is a component of the 
Debug Communication Channel.

TBD</hint>
			<hint page="2166" header="Debug Power Control Register" doc_id="armv8arm" token="DBGPRCR_EL1">Controls behavior of the PE on powerdown request.

TBD</hint>
			<hint page="2168" header="Debug Vector Catch Register" doc_id="armv8arm" token="DBGVCR32_EL2">Allows access to the AArch32 register DBGVCR from 
AArch64 state only. Its value has no effect on 
execution in AArch64 state.

TBD</hint>
			<hint page="2172" header="Debug Watchpoint Control Register 0" doc_id="armv8arm" token="DBGWCR0_EL1">Holds control information for a watchpoint. 
Forms watchpoint 0 together with value register DBGWVR0_EL1.

TBD</hint>
			<hint page="2172" header="Debug Watchpoint Control Register 1" doc_id="armv8arm" token="DBGWCR1_EL1">Holds control information for a watchpoint. 
Forms watchpoint 1 together with value register DBGWVR1_EL1.

TBD</hint>
			<hint page="2172" header="Debug Watchpoint Control Register 2" doc_id="armv8arm" token="DBGWCR2_EL1">Holds control information for a watchpoint. 
Forms watchpoint 2 together with value register DBGWVR2_EL1.

TBD</hint>
			<hint page="2172" header="Debug Watchpoint Control Register 3" doc_id="armv8arm" token="DBGWCR3_EL1">Holds control information for a watchpoint. 
Forms watchpoint 3 together with value register DBGWVR3_EL1.

TBD</hint>
			<hint page="2172" header="Debug Watchpoint Control Register 4" doc_id="armv8arm" token="DBGWCR4_EL1">Holds control information for a watchpoint. 
Forms watchpoint 4 together with value register DBGWVR4_EL1.

TBD</hint>
			<hint page="2172" header="Debug Watchpoint Control Register 5" doc_id="armv8arm" token="DBGWCR5_EL1">Holds control information for a watchpoint. 
Forms watchpoint 5 together with value register DBGWVR5_EL1.

TBD</hint>
			<hint page="2172" header="Debug Watchpoint Control Register 6" doc_id="armv8arm" token="DBGWCR6_EL1">Holds control information for a watchpoint. 
Forms watchpoint 6 together with value register DBGWVR6_EL1.

TBD</hint>
			<hint page="2172" header="Debug Watchpoint Control Register 7" doc_id="armv8arm" token="DBGWCR7_EL1">Holds control information for a watchpoint. 
Forms watchpoint 7 together with value register DBGWVR7_EL1.

TBD</hint>
			<hint page="2172" header="Debug Watchpoint Control Register 8" doc_id="armv8arm" token="DBGWCR8_EL1">Holds control information for a watchpoint. 
Forms watchpoint 8 together with value register DBGWVR8_EL1.

TBD</hint>
			<hint page="2172" header="Debug Watchpoint Control Register 9" doc_id="armv8arm" token="DBGWCR9_EL1">Holds control information for a watchpoint. 
Forms watchpoint 9 together with value register DBGWVR9_EL1.

TBD</hint>
			<hint page="2172" header="Debug Watchpoint Control Register 10" doc_id="armv8arm" token="DBGWCR10_EL1">Holds control information for a watchpoint. 
Forms watchpoint 10 together with value register DBGWVR10_EL1.

TBD</hint>
			<hint page="2172" header="Debug Watchpoint Control Register 11" doc_id="armv8arm" token="DBGWCR11_EL1">Holds control information for a watchpoint. 
Forms watchpoint 11 together with value register DBGWVR11_EL1.

TBD</hint>
			<hint page="2172" header="Debug Watchpoint Control Register 12" doc_id="armv8arm" token="DBGWCR12_EL1">Holds control information for a watchpoint. 
Forms watchpoint 12 together with value register DBGWVR12_EL1.

TBD</hint>
			<hint page="2172" header="Debug Watchpoint Control Register 13" doc_id="armv8arm" token="DBGWCR13_EL1">Holds control information for a watchpoint. 
Forms watchpoint 13 together with value register DBGWVR13_EL1.

TBD</hint>
			<hint page="2172" header="Debug Watchpoint Control Register 14" doc_id="armv8arm" token="DBGWCR14_EL1">Holds control information for a watchpoint. 
Forms watchpoint 14 together with value register DBGWVR14_EL1.

TBD</hint>
			<hint page="2172" header="Debug Watchpoint Control Register 15" doc_id="armv8arm" token="DBGWCR15_EL1">Holds control information for a watchpoint. 
Forms watchpoint 15 together with value register DBGWVR15_EL1.

TBD</hint>
			<hint page="2175" header="Debug Watchpoint Value Register 0" doc_id="armv8arm" token="DBGWVR0_EL1">Holds a data address value for use in watchpoint matching. 
Forms watchpoint 0 together with control register DBGWCR0_EL1.

TBD</hint>
			<hint page="2175" header="Debug Watchpoint Value Register 1" doc_id="armv8arm" token="DBGWVR1_EL1">Holds a data address value for use in watchpoint matching. 
Forms watchpoint 1 together with control register DBGWCR1_EL1.

TBD</hint>
			<hint page="2175" header="Debug Watchpoint Value Register 2" doc_id="armv8arm" token="DBGWVR2_EL1">Holds a data address value for use in watchpoint matching. 
Forms watchpoint 2 together with control register DBGWCR2_EL1.

TBD</hint>
			<hint page="2175" header="Debug Watchpoint Value Register 3" doc_id="armv8arm" token="DBGWVR3_EL1">Holds a data address value for use in watchpoint matching. 
Forms watchpoint 3 together with control register DBGWCR3_EL1.

TBD</hint>
			<hint page="2175" header="Debug Watchpoint Value Register 4" doc_id="armv8arm" token="DBGWVR4_EL1">Holds a data address value for use in watchpoint matching. 
Forms watchpoint 4 together with control register DBGWCR4_EL1.

TBD</hint>
			<hint page="2175" header="Debug Watchpoint Value Register 5" doc_id="armv8arm" token="DBGWVR5_EL1">Holds a data address value for use in watchpoint matching. 
Forms watchpoint 5 together with control register DBGWCR5_EL1.

TBD</hint>
			<hint page="2175" header="Debug Watchpoint Value Register 6" doc_id="armv8arm" token="DBGWVR6_EL1">Holds a data address value for use in watchpoint matching. 
Forms watchpoint 6 together with control register DBGWCR6_EL1.

TBD</hint>
			<hint page="2175" header="Debug Watchpoint Value Register 7" doc_id="armv8arm" token="DBGWVR7_EL1">Holds a data address value for use in watchpoint matching. 
Forms watchpoint 7 together with control register DBGWCR7_EL1.

TBD</hint>
			<hint page="2175" header="Debug Watchpoint Value Register 8" doc_id="armv8arm" token="DBGWVR8_EL1">Holds a data address value for use in watchpoint matching. 
Forms watchpoint 8 together with control register DBGWCR8_EL1.

TBD</hint>
			<hint page="2175" header="Debug Watchpoint Value Register 9" doc_id="armv8arm" token="DBGWVR9_EL1">Holds a data address value for use in watchpoint matching. 
Forms watchpoint 9 together with control register DBGWCR9_EL1.

TBD</hint>
			<hint page="2175" header="Debug Watchpoint Value Register 10" doc_id="armv8arm" token="DBGWVR10_EL1">Holds a data address value for use in watchpoint matching. 
Forms watchpoint 10 together with control register DBGWCR10_EL1.

TBD</hint>
			<hint page="2175" header="Debug Watchpoint Value Register 11" doc_id="armv8arm" token="DBGWVR11_EL1">Holds a data address value for use in watchpoint matching. 
Forms watchpoint 11 together with control register DBGWCR11_EL1.

TBD</hint>
			<hint page="2175" header="Debug Watchpoint Value Register 12" doc_id="armv8arm" token="DBGWVR12_EL1">Holds a data address value for use in watchpoint matching. 
Forms watchpoint 12 together with control register DBGWCR12_EL1.

TBD</hint>
			<hint page="2175" header="Debug Watchpoint Value Register 13" doc_id="armv8arm" token="DBGWVR13_EL1">Holds a data address value for use in watchpoint matching. 
Forms watchpoint 13 together with control register DBGWCR13_EL1.

TBD</hint>
			<hint page="2175" header="Debug Watchpoint Value Register 14" doc_id="armv8arm" token="DBGWVR14_EL1">Holds a data address value for use in watchpoint matching. 
Forms watchpoint 14 together with control register DBGWCR14_EL1.

TBD</hint>
			<hint page="2175" header="Debug Watchpoint Value Register 15" doc_id="armv8arm" token="DBGWVR15_EL1">Holds a data address value for use in watchpoint matching. 
Forms watchpoint 15 together with control register DBGWCR15_EL1.

TBD</hint>
			<hint page="2177" header="Debug Link Register" doc_id="armv8arm" token="DLR_EL0">In Debug state, holds the address to restart from.

Bits [63:0] - Restart address.</hint>
			<hint page="2178" header="Debug Saved Program Status Register" doc_id="armv8arm" token="DSPSR_EL0">Holds the saved process state on entry to Debug state.

TBD</hint>
			<hint page="2183" header="Monitor DCC Interrupt Enable Register" doc_id="armv8arm" token="MDCCINT_EL1">Enables interrupt requests to be signaled based 
on the DCC status flags.

TBD</hint>
			<hint page="2185" header="Monitor DCC Status Register" doc_id="armv8arm" token="MDCCSR_EL0">Main control register for the debug implementation, 
containing flow-control flags for the DCC. This is 
an internal, read-only view.

TBD</hint>
			<hint page="2187" header="Monitor Debug Configuration Register (EL2)" doc_id="armv8arm" token="MDCR_EL2">Provides EL2 configuration options for self-hosted 
debug and the Performance Monitors Extension.

TBD</hint>
			<hint page="2191" header="Monitor Debug Configuration Register (EL3)" doc_id="armv8arm" token="MDCR_EL3">Provides EL3 configuration options for self-hosted 
debug and the Performance Monitors Extension.

TBD</hint>
			<hint page="2195" header="Monitor Debug ROM Address Register" doc_id="armv8arm" token="MDRAR_EL1">Defines the base physical address of a 4KB-aligned 
memory-mapped debug component, usually a ROM table 
that locates and describes the memory-mapped debug 
components in the system. ARMv8 deprecates any use 
of this register.

TBD</hint>
			<hint page="2197" header="Monitor Debug System Control Register" doc_id="armv8arm" token="MDSCR_EL1">Main control register for the debug implementation.

TBD</hint>
			<hint page="2201" header="OS Double Lock Register" doc_id="armv8arm" token="OSDLR_EL1">Used to control the OS Double Lock.

Bits [31:1]  - Reserved, RES0.
DLK, bit [0] - OS Double Lock control bit. Possible values are:
                 0 OS Double Lock unlocked.
                 1 OS Double Lock locked, if DBGPRCR_EL1.CORENPDRQ
                   (Core no powerdown request) bit is set to 0 and 
                   the PE is in Non-debug state.</hint>
			<hint page="2203" header="OS Lock Data Transfer Register, Receive" doc_id="armv8arm" token="OSDTRRX_EL1">Used for save/restore of DBGDTRRX_EL0. 
It is a component of the Debug Communications Channel.

Bits [31:0]  - Update DTRRX without side-effect.
               Writes to this register update the value 
               in DTRRX and do not change RXfull.
               Reads of this register return the last value 
               written to DTRRX and do not change RXfull.</hint>
			<hint page="2205" header="OS Lock Data Transfer Register, Transmit" doc_id="armv8arm" token="OSDTRTX_EL1">Used for save/restore of DBGDTRTX_EL0. 
It is a component of the Debug Communications Channel.

Bits [31:0]  - Return DTRTX without side-effect.

               Reads of this register return the value 
               in DTRTX and do not change TXfull.
               Writes of this register update the value 
               in DTRTX and do not change TXfull.</hint>
			<hint page="2207" header="OS Lock Exception Catch Control Register" doc_id="armv8arm" token="OSECCR_EL1">Provides a mechanism for an operating system to access 
the contents of EDECCR that are otherwise invisible to 
software, so it can save/restore the contents of EDECCR 
over powerdown on behalf of the external debugger.

EDECCR, bits [31:0] - Used for save/restore to EDECCR 
                      over powerdown.</hint>
			<hint page="2209" header="OS Lock Access Register" doc_id="armv8arm" token="OSLAR_EL1">Used to lock or unlock the OS lock.

Bits [31:1]   - Reserved, RES0.
OSLK, bit [0] - On writes to OSLAR_EL1, bit[0] is copied 
                to the OS lock. Use OSLSR_EL1.OSLK to check
                the current status of the lock.</hint>
			<hint page="2211" header="OS Lock Status Register" doc_id="armv8arm" token="OSLSR_EL1">Provides the status of the OS lock.

TBD</hint>
			<hint page="2213" header="AArch32 Secure Debug Enable Register" doc_id="armv8arm" token="SDER32_EL3">Allows access to the AArch32 register SDER from 
AArch64 state only. Its value has no effect on 
execution in AArch64 state.

TBD</hint>
		</group>
		<group type="reg" name="A64 System Registers (Performance Monitors)">
			<hint page="2216" header="Performance Monitors Cycle Count Filter Register" doc_id="armv8arm" token="PMCCFILTR_EL0">Determines the modes in which the Cycle Counter, 
PMCCNTR_EL0, increments.

TBD</hint>
			<hint page="2218" header="Performance Monitors Cycle Count Register" doc_id="armv8arm" token="PMCCNTR_EL0">Holds the value of the processor Cycle Counter, 
CCNT, that counts processor clock cycles.

TBD</hint>
			<hint page="2220" header="Performance Monitors Common Event Identification register 0" doc_id="armv8arm" token="PMCEID0_EL0">Defines which common architectural and common microarchitectural 
feature events in the range 0x000 to 0x01F are implemented. 
If a particular bit is set to 1, then the event for that bit 
is implemented.

ID[31:0], bits [31:0] - PMCEID0_EL0[n] maps to event n.
                        For each bit:
                          0 The common event is not implemented.
                          1 The common event is implemented.</hint>
			<hint page="2222" header="Performance Monitors Common Event Identification register 1" doc_id="armv8arm" token="PMCEID1_EL0">Defines which common architectural and common microarchitectural 
feature events in the range 0x020 to 0x03F are implemented. 
If a particular bit is set to 1, then the event for that 
bit is implemented.

ID[63:32], bits [31:0] - PMCEID1_EL0[n] maps to event (n + 32).
                         For each bit:
                           0 The common event is not implemented.
                           1 The common event is implemented.</hint>
			<hint page="2224" header="Performance Monitors Count Enable Clear register " doc_id="armv8arm" token="PMCNTENCLR_EL0">Disables the Cycle Count Register, PMCCNTR_EL0, 
and any implemented event counters PMEVCNTR&lt;n&gt;. 
Reading this register shows which counters are enabled.

TBD</hint>
			<hint page="2226" header="Performance Monitors Count Enable Set register" doc_id="armv8arm" token="PMCNTENSET_EL0">Enables the Cycle Count Register, PMCCNTR_EL0, 
and any implemented event counters PMEVCNTR&lt;n&gt;. 
Reading this register shows which counters are enabled.

TBD</hint>
			<hint page="2228" header="Performance Monitors Control Register" doc_id="armv8arm" token="PMCR_EL0">Provides details of the Performance Monitors implementation, 
including the number of counters implemented, and configures 
and controls the counters.

TBD</hint>
			<hint page="2231" header="Performance Monitors Event Count Register 0" doc_id="armv8arm" token="PMEVCNTR0_EL0">Holds event counter 0, which counts events.

Bits [31:0] - Event counter 0. Value of event counter 0.</hint>
			<hint page="2231" header="Performance Monitors Event Count Register 1" doc_id="armv8arm" token="PMEVCNTR1_EL0">Holds event counter 1, which counts events.

Bits [31:0] - Event counter 1. Value of event counter 1.</hint>
			<hint page="2231" header="Performance Monitors Event Count Register 2" doc_id="armv8arm" token="PMEVCNTR2_EL0">Holds event counter 2, which counts events.

Bits [31:0] - Event counter 2. Value of event counter 2.</hint>
			<hint page="2231" header="Performance Monitors Event Count Register 3" doc_id="armv8arm" token="PMEVCNTR3_EL0">Holds event counter 3, which counts events.

Bits [31:0] - Event counter 3. Value of event counter 3.</hint>
			<hint page="2231" header="Performance Monitors Event Count Register 4" doc_id="armv8arm" token="PMEVCNTR4_EL0">Holds event counter 4, which counts events.

Bits [31:0] - Event counter 4. Value of event counter 4.</hint>
			<hint page="2231" header="Performance Monitors Event Count Register 5" doc_id="armv8arm" token="PMEVCNTR5_EL0">Holds event counter 5, which counts events.

Bits [31:0] - Event counter 5. Value of event counter 5.</hint>
			<hint page="2231" header="Performance Monitors Event Count Register 6" doc_id="armv8arm" token="PMEVCNTR6_EL0">Holds event counter 6, which counts events.

Bits [31:0] - Event counter 6. Value of event counter 6.</hint>
			<hint page="2231" header="Performance Monitors Event Count Register 7" doc_id="armv8arm" token="PMEVCNTR7_EL0">Holds event counter 7, which counts events.

Bits [31:0] - Event counter 7. Value of event counter 7.</hint>
			<hint page="2231" header="Performance Monitors Event Count Register 8" doc_id="armv8arm" token="PMEVCNTR8_EL0">Holds event counter 8, which counts events.

Bits [31:0] - Event counter 8. Value of event counter 8.</hint>
			<hint page="2231" header="Performance Monitors Event Count Register 9" doc_id="armv8arm" token="PMEVCNTR9_EL0">Holds event counter 9, which counts events.

Bits [31:0] - Event counter 9. Value of event counter 9.</hint>
			<hint page="2231" header="Performance Monitors Event Count Register 10" doc_id="armv8arm" token="PMEVCNTR10_EL0">Holds event counter 10, which counts events.

Bits [31:0] - Event counter 10. Value of event counter 10.</hint>
			<hint page="2231" header="Performance Monitors Event Count Register 11" doc_id="armv8arm" token="PMEVCNTR11_EL0">Holds event counter 11, which counts events.

Bits [31:0] - Event counter 11. Value of event counter 11.</hint>
			<hint page="2231" header="Performance Monitors Event Count Register 12" doc_id="armv8arm" token="PMEVCNTR12_EL0">Holds event counter 12, which counts events.

Bits [31:0] - Event counter 12. Value of event counter 12.</hint>
			<hint page="2231" header="Performance Monitors Event Count Register 13" doc_id="armv8arm" token="PMEVCNTR13_EL0">Holds event counter 13, which counts events.

Bits [31:0] - Event counter 13. Value of event counter 13.</hint>
			<hint page="2231" header="Performance Monitors Event Count Register 14" doc_id="armv8arm" token="PMEVCNTR14_EL0">Holds event counter 14, which counts events.

Bits [31:0] - Event counter 14. Value of event counter 14.</hint>
			<hint page="2231" header="Performance Monitors Event Count Register 15" doc_id="armv8arm" token="PMEVCNTR15_EL0">Holds event counter 15, which counts events.

Bits [31:0] - Event counter 15. Value of event counter 15.</hint>
			<hint page="2231" header="Performance Monitors Event Count Register 16" doc_id="armv8arm" token="PMEVCNTR16_EL0">Holds event counter 16, which counts events.

Bits [31:0] - Event counter 16. Value of event counter 16.</hint>
			<hint page="2231" header="Performance Monitors Event Count Register 17" doc_id="armv8arm" token="PMEVCNTR17_EL0">Holds event counter 17, which counts events.

Bits [31:0] - Event counter 17. Value of event counter 17.</hint>
			<hint page="2231" header="Performance Monitors Event Count Register 18" doc_id="armv8arm" token="PMEVCNTR18_EL0">Holds event counter 18, which counts events.

Bits [31:0] - Event counter 18. Value of event counter 18.</hint>
			<hint page="2231" header="Performance Monitors Event Count Register 19" doc_id="armv8arm" token="PMEVCNTR19_EL0">Holds event counter 19, which counts events.

Bits [31:0] - Event counter 19. Value of event counter 19.</hint>
			<hint page="2231" header="Performance Monitors Event Count Register 20" doc_id="armv8arm" token="PMEVCNTR20_EL0">Holds event counter 20, which counts events.

Bits [31:0] - Event counter 20. Value of event counter 20.</hint>
			<hint page="2231" header="Performance Monitors Event Count Register 21" doc_id="armv8arm" token="PMEVCNTR21_EL0">Holds event counter 21, which counts events.

Bits [31:0] - Event counter 21. Value of event counter 21.</hint>
			<hint page="2231" header="Performance Monitors Event Count Register 22" doc_id="armv8arm" token="PMEVCNTR22_EL0">Holds event counter 22, which counts events.

Bits [31:0] - Event counter 22. Value of event counter 22.</hint>
			<hint page="2231" header="Performance Monitors Event Count Register 23" doc_id="armv8arm" token="PMEVCNTR23_EL0">Holds event counter 23, which counts events.

Bits [31:0] - Event counter 23. Value of event counter 23.</hint>
			<hint page="2231" header="Performance Monitors Event Count Register 24" doc_id="armv8arm" token="PMEVCNTR24_EL0">Holds event counter 24, which counts events.

Bits [31:0] - Event counter 24. Value of event counter 24.</hint>
			<hint page="2231" header="Performance Monitors Event Count Register 25" doc_id="armv8arm" token="PMEVCNTR25_EL0">Holds event counter 25, which counts events.

Bits [31:0] - Event counter 25. Value of event counter 25.</hint>
			<hint page="2231" header="Performance Monitors Event Count Register 26" doc_id="armv8arm" token="PMEVCNTR26_EL0">Holds event counter 26, which counts events.

Bits [31:0] - Event counter 26. Value of event counter 26.</hint>
			<hint page="2231" header="Performance Monitors Event Count Register 27" doc_id="armv8arm" token="PMEVCNTR27_EL0">Holds event counter 27, which counts events.

Bits [31:0] - Event counter 27. Value of event counter 27.</hint>
			<hint page="2231" header="Performance Monitors Event Count Register 28" doc_id="armv8arm" token="PMEVCNTR28_EL0">Holds event counter 28, which counts events.

Bits [31:0] - Event counter 28. Value of event counter 28.</hint>
			<hint page="2231" header="Performance Monitors Event Count Register 29" doc_id="armv8arm" token="PMEVCNTR29_EL0">Holds event counter 29, which counts events.

Bits [31:0] - Event counter 29. Value of event counter 29.</hint>
			<hint page="2231" header="Performance Monitors Event Count Register 30" doc_id="armv8arm" token="PMEVCNTR30_EL0">Holds event counter 30, which counts events.

Bits [31:0] - Event counter 30. Value of event counter 30.</hint>
			<hint page="2233" header="Performance Monitors Event Type Register 0" doc_id="armv8arm" token="PMEVTYPER0_EL0">Configures event counter 0.

TBD</hint>
			<hint page="2233" header="Performance Monitors Event Type Register 1" doc_id="armv8arm" token="PMEVTYPER1_EL0">Configures event counter 1.

TBD</hint>
			<hint page="2233" header="Performance Monitors Event Type Register 2" doc_id="armv8arm" token="PMEVTYPER2_EL0">Configures event counter 2.

TBD</hint>
			<hint page="2233" header="Performance Monitors Event Type Register 3" doc_id="armv8arm" token="PMEVTYPER3_EL0">Configures event counter 3.

TBD</hint>
			<hint page="2233" header="Performance Monitors Event Type Register 4" doc_id="armv8arm" token="PMEVTYPER4_EL0">Configures event counter 4.

TBD</hint>
			<hint page="2233" header="Performance Monitors Event Type Register 5" doc_id="armv8arm" token="PMEVTYPER5_EL0">Configures event counter 5.

TBD</hint>
			<hint page="2233" header="Performance Monitors Event Type Register 6" doc_id="armv8arm" token="PMEVTYPER6_EL0">Configures event counter 6.

TBD</hint>
			<hint page="2233" header="Performance Monitors Event Type Register 7" doc_id="armv8arm" token="PMEVTYPER7_EL0">Configures event counter 7.

TBD</hint>
			<hint page="2233" header="Performance Monitors Event Type Register 8" doc_id="armv8arm" token="PMEVTYPER8_EL0">Configures event counter 8.

TBD</hint>
			<hint page="2233" header="Performance Monitors Event Type Register 9" doc_id="armv8arm" token="PMEVTYPER9_EL0">Configures event counter 9.

TBD</hint>
			<hint page="2233" header="Performance Monitors Event Type Register 10" doc_id="armv8arm" token="PMEVTYPER10_EL0">Configures event counter 10.

TBD</hint>
			<hint page="2233" header="Performance Monitors Event Type Register 11" doc_id="armv8arm" token="PMEVTYPER11_EL0">Configures event counter 11.

TBD</hint>
			<hint page="2233" header="Performance Monitors Event Type Register 12" doc_id="armv8arm" token="PMEVTYPER12_EL0">Configures event counter 12.

TBD</hint>
			<hint page="2233" header="Performance Monitors Event Type Register 13" doc_id="armv8arm" token="PMEVTYPER13_EL0">Configures event counter 13.

TBD</hint>
			<hint page="2233" header="Performance Monitors Event Type Register 14" doc_id="armv8arm" token="PMEVTYPER14_EL0">Configures event counter 14.

TBD</hint>
			<hint page="2233" header="Performance Monitors Event Type Register 15" doc_id="armv8arm" token="PMEVTYPER15_EL0">Configures event counter 15.

TBD</hint>
			<hint page="2233" header="Performance Monitors Event Type Register 16" doc_id="armv8arm" token="PMEVTYPER16_EL0">Configures event counter 16.

TBD</hint>
			<hint page="2233" header="Performance Monitors Event Type Register 17" doc_id="armv8arm" token="PMEVTYPER17_EL0">Configures event counter 17.

TBD</hint>
			<hint page="2233" header="Performance Monitors Event Type Register 18" doc_id="armv8arm" token="PMEVTYPER18_EL0">Configures event counter 18.

TBD</hint>
			<hint page="2233" header="Performance Monitors Event Type Register 19" doc_id="armv8arm" token="PMEVTYPER19_EL0">Configures event counter 19.

TBD</hint>
			<hint page="2233" header="Performance Monitors Event Type Register 20" doc_id="armv8arm" token="PMEVTYPER20_EL0">Configures event counter 20.

TBD</hint>
			<hint page="2233" header="Performance Monitors Event Type Register 21" doc_id="armv8arm" token="PMEVTYPER21_EL0">Configures event counter 21.

TBD</hint>
			<hint page="2233" header="Performance Monitors Event Type Register 22" doc_id="armv8arm" token="PMEVTYPER22_EL0">Configures event counter 22.

TBD</hint>
			<hint page="2233" header="Performance Monitors Event Type Register 23" doc_id="armv8arm" token="PMEVTYPER23_EL0">Configures event counter 23.

TBD</hint>
			<hint page="2233" header="Performance Monitors Event Type Register 24" doc_id="armv8arm" token="PMEVTYPER24_EL0">Configures event counter 24.

TBD</hint>
			<hint page="2233" header="Performance Monitors Event Type Register 25" doc_id="armv8arm" token="PMEVTYPER25_EL0">Configures event counter 25.

TBD</hint>
			<hint page="2233" header="Performance Monitors Event Type Register 26" doc_id="armv8arm" token="PMEVTYPER26_EL0">Configures event counter 26.

TBD</hint>
			<hint page="2233" header="Performance Monitors Event Type Register 27" doc_id="armv8arm" token="PMEVTYPER27_EL0">Configures event counter 27.

TBD</hint>
			<hint page="2233" header="Performance Monitors Event Type Register 28" doc_id="armv8arm" token="PMEVTYPER28_EL0">Configures event counter 28.

TBD</hint>
			<hint page="2233" header="Performance Monitors Event Type Register 29" doc_id="armv8arm" token="PMEVTYPER29_EL0">Configures event counter 29.

TBD</hint>
			<hint page="2233" header="Performance Monitors Event Type Register 30" doc_id="armv8arm" token="PMEVTYPER30_EL0">Configures event counter 30.

TBD</hint>
			<hint page="2237" header="Performance Monitors Interrupt Enable Clear register" doc_id="armv8arm" token="PMINTENCLR_EL1">Disables the generation of interrupt requests on overflows 
from the Cycle Count Register, PMCCNTR_EL0, and the event 
counters PMEVCNTR&lt;n&gt;_EL0. Reading the register shows which 
overflow interrupt requests are enabled.

TBD</hint>
			<hint page="2239" header="Performance Monitors Interrupt Enable Set register" doc_id="armv8arm" token="PMINTENSET_EL1">Enables the generation of interrupt requests on overflows 
from the Cycle Count Register, PMCCNTR_EL0, and the event 
counters PMEVCNTR&lt;n&gt;_EL0. Reading the register shows which 
overflow interrupt requests are enabled.

TBD</hint>
			<hint page="2241" header="Performance Monitors Overflow Flag Status Clear Register" doc_id="armv8arm" token="PMOVSCLR_EL0">Contains the state of the overflow bit for the Cycle Count Register, 
PMCCNTR_EL0, and each of the implemented event counters PMEVCNTR&lt;n&gt;. 
Writing to this register clears these bits.

TBD</hint>
			<hint page="2243" header="Performance Monitors Overflow Flag Status Set register" doc_id="armv8arm" token="PMOVSSET_EL0">Sets the state of the overflow bit for the Cycle Count Register, 
PMCCNTR_EL0, and each of the implemented event counters PMEVCNTR&lt;n&gt;.

TBD</hint>
			<hint page="2245" header="Performance Monitors Event Counter Selection Register" doc_id="armv8arm" token="PMSELR_EL0">Selects the current event counter PMEVCNTR&lt;n&gt; or the cycle counter, CCNT.

TBD</hint>
			<hint page="2247" header="Performance Monitors Software Increment register" doc_id="armv8arm" token="PMSWINC_EL0">Increments a counter that is configured to count the Software 
increment event, event 0x00. For more information, see SW_INCR.

TBD</hint>
			<hint page="2249" header="Performance Monitors User Enable Register" doc_id="armv8arm" token="PMUSERENR_EL0">Enables or disables EL0 access to the Performance Monitors.

TBD</hint>
			<hint page="2251" header="Performance Monitors Selected Event Count Register" doc_id="armv8arm" token="PMXEVCNTR_EL0">Reads or writes the value of the selected event counter, 
PMEVCNTR&lt;n&gt;_EL0. PMSELR_EL0.SEL determines which event 
counter is selected.

PMEVCNTR&lt;n&gt;, bits [31:0] - Value of the selected event counter, 
                           PMEVCNTR&lt;n&gt;_EL0, where n is the value 
                           stored in PMSELR_EL0.SEL.</hint>
			<hint page="2253" header="Performance Monitors Selected Event Type Register" doc_id="armv8arm" token="PMXEVTYPER_EL0">When PMSELR_EL0.SEL selects an event counter, this accesses a 
PMEVTYPER&lt;n&gt;_EL0 register. When PMSELR_EL0.SEL selects the 
cycle counter, this accesses PMCCFILTR_EL0.

Bits [31:0] - Event type register or PMCCFILTR_EL0.</hint>
		</group>
		<group type="reg" name="A64 System Registers (Generic Timer)">
			<hint page="2256" header="Counter-timer Frequency register" doc_id="armv8arm" token="CNTFRQ_EL0">This register is provided so that software can discover the 
frequency of the system counter.

Bits [31:0] - Clock frequency. Indicates the system counter 
              clock frequency, in Hz.</hint>
			<hint page="2258" header="Counter-timer Hypervisor Control register" doc_id="armv8arm" token="CNTHCTL_EL2">Controls the generation of an event stream from the physical counter, 
and access from Non-secure EL1 to the physical counter and the 
Non-secure EL1 physical timer.

TBD</hint>
			<hint page="2260" header="Counter-timer Hypervisor Physical Timer Control register" doc_id="armv8arm" token="CNTHP_CTL_EL2">Control register for the EL2 physical timer.

TBD</hint>
			<hint page="2262" header="Counter-timer Hypervisor Physical Timer CompareValue register" doc_id="armv8arm" token="CNTHP_CVAL_EL2">Holds the compare value for the EL2 physical timer.

Bits [63:0] - EL2 physical timer compare value.</hint>
			<hint page="2263" header="Counter-timer Hypervisor Physical Timer TimerValue register" doc_id="armv8arm" token="CNTHP_TVAL_EL2">Holds the timer value for the EL2 physical timer.

Bits [31:0] - EL2 physical timer value.</hint>
			<hint page="2264" header="Counter-timer Kernel Control register" doc_id="armv8arm" token="CNTKCTL_EL1">Controls the generation of an event stream from the virtual counter, 
and access from EL0 to the physical counter, virtual counter, 
EL1 physical timers, and the virtual timer.

TBD</hint>
			<hint page="2267" header="Counter-timer Physical Timer Control register" doc_id="armv8arm" token="CNTP_CTL_EL0">Control register for the EL1 physical timer.

TBD</hint>
			<hint page="2269" header="Counter-timer Physical Timer CompareValue register" doc_id="armv8arm" token="CNTP_CVAL_EL0">Holds the compare value for the EL1 physical timer.

Bits [63:0] - EL1 physical timer compare value.</hint>
			<hint page="2270" header="Counter-timer Physical Timer TimerValue register" doc_id="armv8arm" token="CNTP_TVAL_EL0">Holds the timer value for the EL1 physical timer.

Bits [31:0] - EL1 physical timer value.</hint>
			<hint page="2272" header="Counter-timer Physical Count register" doc_id="armv8arm" token="CNTPCT_EL0">Holds the 64-bit physical count value.

Bits [63:0] - Physical count value.</hint>
			<hint page="2273" header="Counter-timer Physical Secure Timer Control register" doc_id="armv8arm" token="CNTPS_CTL_EL1">Control register for the secure physical timer, usually accessible 
at EL3 but configurably accessible at EL1 in Secure state.

TBD</hint>
			<hint page="2275" header="Counter-timer Physical Secure Timer CompareValue register" doc_id="armv8arm" token="CNTPS_CVAL_EL1">Holds the compare value for the secure physical timer, 
usually accessible at EL3 but configurably accessible 
at EL1 in Secure state.

Bits [63:0] - Secure physical timer compare value.</hint>
			<hint page="2276" header="Counter-timer Physical Secure Timer TimerValue register" doc_id="armv8arm" token="CNTPS_TVAL_EL1">Holds the timer value for the secure physical timer, 
usually accessible at EL3 but configurably accessible 
at EL1 in Secure state.

Bits [31:0] - Secure physical timer value.</hint>
			<hint page="2277" header="Counter-timer Virtual Timer Control register" doc_id="armv8arm" token="CNTV_CTL_EL0">Control register for the virtual timer.

TBD</hint>
			<hint page="2279" header="Counter-timer Virtual Timer CompareValue register" doc_id="armv8arm" token="CNTV_CVAL_EL0">Holds the compare value for the virtual timer.

Bits [63:0] - Virtual timer compare value.</hint>
			<hint page="2280" header="Counter-timer Virtual Timer TimerValue register" doc_id="armv8arm" token="CNTV_TVAL_EL0">Holds the timer value for the virtual timer.

Bits [31:0] - Virtual timer value.</hint>
			<hint page="2282" header="Counter-timer Virtual Count register" doc_id="armv8arm" token="CNTVCT_EL0">Holds the 64-bit virtual count value. The virtual count value 
is equal to the physical count value visible in CNTPCT_EL0 
minus the virtual offset visible in CNTVOFF_EL2.

Bits [63:0] - Virtual count value.</hint>
			<hint page="2283" header="Counter-timer Virtual Offset register" doc_id="armv8arm" token="CNTVOFF_EL2">Holds the 64-bit virtual offset. This is the offset between the 
physical count value visible in CNTPCT_EL0 and the virtual 
count value visible in CNTVCT_EL0.</hint>
		</group>
		<group type="reg" name="A64 Barrier Symbols">
			<hint page="515" header="Full system, all" doc_id="armv8arm" token="SY">Full system is the required shareability domain, 
reads and writes are the required access types 
in both Group A and Group B.</hint>
			<hint page="515" header="Full system, store" doc_id="armv8arm" token="ST">Full system is the required shareability domain, 
writes are the required access type in both 
Group A and Group B.</hint>
			<hint page="515" header="Full system, all" doc_id="armv8arm" token="LD">Full system is the required shareability domain, 
reads are the required access type in Group A, 
and reads and writes are the required access 
types in Group B.</hint>
			<hint page="515" header="Inner Shareable, all" doc_id="armv8arm" token="ISH">Inner Shareable is the required shareability domain, 
reads and writes are the required access types in 
both Group A and Group B.</hint>
			<hint page="515" header="Inner Shareable, store" doc_id="armv8arm" token="ISHST">Inner Shareable is the required shareability domain, 
writes are the required access type in both 
Group A and Group B.</hint>
			<hint page="515" header="Inner Shareable, load" doc_id="armv8arm" token="ISHLD">Inner Shareable is the required shareability domain, reads 
are the required access type in Group A, and reads and 
writes are the required access types in Group B.</hint>
			<hint page="515" header="Non-shareable, all" doc_id="armv8arm" token="NSH">Non-shareable is the required shareability domain, 
reads and writes are the required access types in 
both Group A and Group B.</hint>
			<hint page="515" header="Non-shareable, store" doc_id="armv8arm" token="NSHST">Non-shareable is the required shareability domain, 
writes are the required access type in both 
Group A and Group B.</hint>
			<hint page="516" header="Non-shareable, load" doc_id="armv8arm" token="NSHLD">Non-shareable is the required shareability domain, reads 
are the required access type in Group A, and reads and 
writes are the required access types in Group B.</hint>
			<hint page="516" header="Outer Shareable, all" doc_id="armv8arm" token="OSH">Outer Shareable is the required shareability domain, 
reads and writes are the required access types in 
both Group A and Group B.</hint>
			<hint page="516" header="Outer Shareable, store" doc_id="armv8arm" token="OSHST">Outer Shareable is the required shareability domain, 
writes are the required access type in both Group A 
and Group B.</hint>
			<hint page="516" header="Outer Shareable, load" doc_id="armv8arm" token="OSHLD">Outer Shareable is the required shareability domain, reads 
are the required access type in Group A, and reads and 
writes are the required access types in Group B.</hint>
		</group>
		<group type="ins" name="A64 Base instructions">
			<hint page="435" header="Add with Carry" doc_id="armv8arm" token="ADC">Adds two register values and the Carry flag value, 
and writes the result to the destination register.

ADC &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;</hint>
			<hint page="436" header="Add with Carry (setting flags)" doc_id="armv8arm" token="ADCS">Adds two register values and the Carry flag value,
and writes the result to the destination register. 
It updates the condition flags based on the result.

ADCS &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;</hint>
			<hint page="437" header="Addition" doc_id="armv8arm" token="ADD">1. Extended register
Adds a register value and a sign or zero-extended register value, 
followed by an optional left shift amount, and writes the result to the destination register. 

ADD &lt;Xd|SP&gt;, &lt;Xn|SP&gt;, &lt;R&gt;&lt;m&gt;{, &lt;extend&gt; {#&lt;amount&gt;}}

2. Immediate
Adds a register value and an optionally-shifted immediate value, 
and writes the result to the destination register.

ADD &lt;Xd|SP&gt;, &lt;Xn|SP&gt;, #&lt;imm&gt;{, &lt;shift&gt;}

3. Shifted register
Adds a register value and an optionally-shifted register value, 
and writes the result to the destination register.

ADD &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;{, &lt;shift&gt; #&lt;amount&gt;}</hint>
			<hint page="443" header="Addition (setting flags)" doc_id="armv8arm" token="ADDS">1. Extended register
Adds a register value and a sign or zero-extended register value, 
followed by an optional left shift amount, and writes the result to the destination register. 
It updates the condition flags based on the result.

ADDS &lt;Xd&gt;, &lt;Xn|SP&gt;, &lt;R&gt;&lt;m&gt;{, &lt;extend&gt; {#&lt;amount&gt;}}

2. Immediate
Adds a register value and an optionally-shifted immediate value, 
and writes the result to the destination register. 
It updates the condition flags based on the result.

ADDS &lt;Xd&gt;, &lt;Xn|SP&gt;, #&lt;imm&gt;{, &lt;shift&gt;}

3. Shifted register
Adds a register value and an optionally-shifted register value, 
and writes the result to the destination register. 
It updates the condition flags based on the result.

ADDS &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;{, &lt;shift&gt; #&lt;amount&gt;}</hint>
			<hint page="449" header="Load address" doc_id="armv8arm" token="ADR">Form PC-relative address adds an immediate value 
to the PC value to form a PC-relative address, 
and writes the result to the destination register.

ADR &lt;Xd&gt;, &lt;label&gt;</hint>
			<hint page="450" header="Load address" doc_id="armv8arm" token="ADRP">Form PC-relative address to 4KB page adds an immediate value that is shifted left by 12 bits, 
to the PC value to form a PC-relative address, with the bottom 12 bits masked out, 
and writes the result to the destination register.

ADRP &lt;Xd&gt;, &lt;label&gt;</hint>
			<hint page="451" header="Bitwise AND" doc_id="armv8arm" token="AND">1. Immediate
Performs a bitwise AND of a register value and an immediate value, 
and writes the result to the destination register.

AND &lt;Xd|SP&gt;, &lt;Xn&gt;, #&lt;imm&gt;

2. Shifted register
Performs a bitwise AND of a register value and an optionally-shifted register value, 
and writes the result to the destination register.

AND &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;{, &lt;shift&gt; #&lt;amount&gt;}</hint>
			<hint page="454" header="Bitwise AND (setting flags)" doc_id="armv8arm" token="ANDS">1. Immediate
Performs a bitwise AND of a register value and an immediate value, 
and writes the result to the destination register. 
It updates the condition flags based on the result.

ANDS &lt;Xd&gt;, &lt;Xn&gt;, #&lt;imm&gt;

2. Shifted register
Performs a bitwise AND of a register value and an optionally-shifted register value, 
and writes the result to the destination register. 
It updates the condition flags based on the result.

ANDS &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;{, &lt;shift&gt; #&lt;amount&gt;}</hint>
			<hint page="458" header="Arithmetic Shift Right" doc_id="armv8arm" token="ASR">1. Register
Shifts a register value right by a variable number of bits, 
shifting in copies of its sign bit, and writes the result to the destination register. 
The remainder obtained by dividing the second source register by the data size defines 
the number of bits by which the first source register is right-shifted.

ASR &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;

  is equivalent to

ASRV &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;

2. Immediate
Shifts a register value right by an immediate number of bits, 
shifting in copies of the sign bit in the upper bits and zeros in the lower bits, 
and writes the result to the destination register.

ASR &lt;Xd&gt;, &lt;Xn&gt;, #&lt;shift&gt;

  is equivalent to

SBFM &lt;Xd&gt;, &lt;Xn&gt;, #&lt;shift&gt;, #63</hint>
			<hint page="460" header="Arithmetic Shift Right Variable" doc_id="armv8arm" token="ASRV">Shifts a register value right by a variable number of bits, 
shifting in copies of its sign bit, 
and writes the result to the destination register. 
The remainder obtained by dividing the second source register 
by the data size defines the number of bits by which the first 
source register is right-shifted.

ASRV &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;</hint>
			<hint page="462" header="Branch conditionally" doc_id="armv8arm" token="B.EQ">Branch conditionally to a label at a PC-relative offset, 
with a hint that this is not a subroutine call or return.

EQ - Equal (Z==1)

B.EQ &lt;label&gt;</hint>
			<hint page="462" token="B.NE" doc_id="armv8arm" header="Branch conditionally">Branch conditionally to a label at a PC-relative offset, 
with a hint that this is not a subroutine call or return.

NE - Not equal (Z==0)

B.NE &lt;label&gt;</hint>
			<hint page="462" token="B.CS" doc_id="armv8arm" header="Branch conditionally">Branch conditionally to a label at a PC-relative offset, 
with a hint that this is not a subroutine call or return.

CS - Carry set (C==1)

B.CS &lt;label&gt;</hint>
			<hint page="462" token="B.HS" doc_id="armv8arm" header="Branch conditionally">Branch conditionally to a label at a PC-relative offset, 
with a hint that this is not a subroutine call or return.

HS - Carry set (C==1)

B.HS &lt;label&gt;</hint>
			<hint page="462" token="B.CC" doc_id="armv8arm" header="Branch conditionally">Branch conditionally to a label at a PC-relative offset, 
with a hint that this is not a subroutine call or return.

CC - Carry clear (C==0)

B.CC &lt;label&gt;</hint>
			<hint page="462" token="B.LO" doc_id="armv8arm" header="Branch conditionally">Branch conditionally to a label at a PC-relative offset, 
with a hint that this is not a subroutine call or return.

LO - Carry clear (C==0)

B.LO &lt;label&gt;</hint>
			<hint page="462" token="B.MI" doc_id="armv8arm" header="Branch conditionally">Branch conditionally to a label at a PC-relative offset, 
with a hint that this is not a subroutine call or return.

MI - Minus, negative (N==1)

B.MI &lt;label&gt;</hint>
			<hint page="462" token="B.PL" doc_id="armv8arm" header="Branch conditionally">Branch conditionally to a label at a PC-relative offset, 
with a hint that this is not a subroutine call or return.

PL - Plus, positive or zero (N==0)

B.PL &lt;label&gt;</hint>
			<hint page="462" token="B.VS" doc_id="armv8arm" header="Branch conditionally">Branch conditionally to a label at a PC-relative offset, 
with a hint that this is not a subroutine call or return.

VS - Overflow (V==1)

B.VS &lt;label&gt;</hint>
			<hint page="462" token="B.VC" doc_id="armv8arm" header="Branch conditionally">Branch conditionally to a label at a PC-relative offset, 
with a hint that this is not a subroutine call or return.

VC - No overflow (V==0)

B.VC &lt;label&gt;</hint>
			<hint page="462" token="B.HI" doc_id="armv8arm" header="Branch conditionally">Branch conditionally to a label at a PC-relative offset, 
with a hint that this is not a subroutine call or return.

HI - Unsigned higher (C ==1 &amp;&amp; Z == 0)

B.HI &lt;label&gt;</hint>
			<hint page="462" token="B.LS" doc_id="armv8arm" header="Branch conditionally">Branch conditionally to a label at a PC-relative offset, 
with a hint that this is not a subroutine call or return.

LS - Unsigned lower or same (!(C ==1 &amp;&amp; Z ==0))

B.LS &lt;label&gt;</hint>
			<hint page="462" token="B.GE" doc_id="armv8arm" header="Branch conditionally">Branch conditionally to a label at a PC-relative offset, 
with a hint that this is not a subroutine call or return.

GE - Signed greater than or equal (N == V)

B.GE &lt;label&gt;</hint>
			<hint page="462" token="B.LT" doc_id="armv8arm" header="Branch conditionally">Branch conditionally to a label at a PC-relative offset, 
with a hint that this is not a subroutine call or return.

LT - Signed less than (N! = V)

B.LT &lt;label&gt;</hint>
			<hint page="462" token="B.GT" doc_id="armv8arm" header="Branch conditionally">Branch conditionally to a label at a PC-relative offset, 
with a hint that this is not a subroutine call or return.

GT - Signed greater than (Z == 0 &amp;&amp; N == V)

B.GT &lt;label&gt;</hint>
			<hint page="462" token="B.LE" doc_id="armv8arm" header="Branch conditionally">Branch conditionally to a label at a PC-relative offset, 
with a hint that this is not a subroutine call or return.

LE - Signed less than or equal (!(Z == 0 &amp;&amp; N == V))

B.LE &lt;label&gt;</hint>
			<hint page="462" token="B.AL" doc_id="armv8arm" header="Branch conditionally">Branch conditionally to a label at a PC-relative offset, 
with a hint that this is not a subroutine call or return.

AL - Always (Any)

B.AL &lt;label&gt;</hint>
			<hint page="462" token="B.NV" doc_id="armv8arm" header="Branch conditionally">Branch conditionally to a label at a PC-relative offset, 
with a hint that this is not a subroutine call or return.

NV - Always (Any)

B.NV &lt;label&gt;</hint>
			<hint page="463" header="Branch unconditionally" doc_id="armv8arm" token="B">Branch causes an unconditional branch to a label at a PC-relative offset, 
with a hint that this is not a subroutine call or return.

B &lt;label&gt;</hint>
			<hint page="464" header="Bitfield Insert" doc_id="armv8arm" token="BFI">Copies any number of low-order bits from a source register into the 
same number of adjacent bits at any position in the destination register, 
leaving other bits unchanged.

BFI &lt;Xd&gt;, &lt;Xn&gt;, #&lt;lsb&gt;, #&lt;width&gt;
  
  is equivalent to

BFM &lt;Xd&gt;, &lt;Xn&gt;, #(-&lt;lsb&gt; MOD 64), #(&lt;width&gt;-1)</hint>
			<hint page="465" header="Bitfield Move" doc_id="armv8arm" token="BFM">Copies any number of low-order bits from a source register into the
same number of adjacent bits at any position in the destination register, 
leaving other bits unchanged.

BFM &lt;Xd&gt;, &lt;Xn&gt;, #&lt;immr&gt;, #&lt;imms&gt;</hint>
			<hint page="467" header="Bitfield extract and insert" doc_id="armv8arm" token="BFXIL">At low end copies any number of low-order bits from a source register into the 
same number of adjacent bits at the low end in the destination register, 
leaving other bits unchanged.

BFXIL &lt;Xd&gt;, &lt;Xn&gt;, #&lt;lsb&gt;, #&lt;width&gt;

  is equivalent to

BFM &lt;Xd&gt;, &lt;Xn&gt;, #&lt;lsb&gt;, #(&lt;lsb&gt;+&lt;width&gt;-1)</hint>
			<hint page="468" header="Bitwise Bit Clear" doc_id="armv8arm" token="BIC">Performs a bitwise AND of a register value and the complement of an optionally-shifted 
register value, and writes the result to the destination register.

BIC &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;{, &lt;shift&gt; #&lt;amount&gt;}</hint>
			<hint page="470" header="Bitwise Bit Clear (setting flags)" doc_id="armv8arm" token="BICS">Performs a bitwise AND of a register value and the complement of an optionally-shifted 
register value, and writes the result to the destination register. 
It updates the condition flags based on the result.

BICS &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;{, &lt;shift&gt; #&lt;amount&gt;}</hint>
			<hint page="472" header="Branch with Link" doc_id="armv8arm" token="BL">Branches to a PC-relative offset, setting the register X30 to PC+4. 
It provides a hint that this is a subroutine call.

BL &lt;label&gt;</hint>
			<hint page="473" header="Branch with Link to Register" doc_id="armv8arm" token="BLR">Calls a subroutine at an address in a register, 
setting register X30 to PC+4.

BLR &lt;Xn&gt;</hint>
			<hint page="474" header="Branch to Register" doc_id="armv8arm" token="BR">Branches unconditionally to an address in a register, 
with a hint that this is not a subroutine return.

BR &lt;Xn&gt;</hint>
			<hint page="476" header="Compare and Branch on Nonzero" doc_id="armv8arm" token="CBNZ">Compares the value in a register with zero, and conditionally branches to a label 
at a PC-relative offset if the comparison is not equal. 
It provides a hint that this is not a subroutine call or return. 
This instruction does not affect the condition flags.

CBNZ &lt;Xt&gt;, &lt;label&gt;</hint>
			<hint page="477" header="Compare and Branch on Zero" doc_id="armv8arm" token="CBZ">Compares the value in a register with zero, and conditionally branches to a label 
at a PC-relative offset if the comparison is equal. I
t provides a hint that this is not a subroutine call or return. 
This instruction does not affect condition flags.

CBZ &lt;Xt&gt;, &lt;label&gt;</hint>
			<hint page="478" header="Conditional Compare Negative" doc_id="armv8arm" token="CCMN">1. Immediate
Sets the value of the condition flags to the result of the comparison of a 
register value and a negated immediate value if the condition is TRUE, 
and an immediate value otherwise.

CCMN &lt;Xn&gt;, #&lt;imm&gt;, #&lt;nzcv&gt;, &lt;cond&gt;

2. Register
Sets the value of the condition flags to the result of the comparison of a 
register value and the inverse of another register value if the condition 
is TRUE, and an immediate value otherwise.

CCMN &lt;Xn&gt;, &lt;Xm&gt;, #&lt;nzcv&gt;, &lt;cond&gt;</hint>
			<hint page="480" header="Conditional Compare" doc_id="armv8arm" token="CCMP">1. Immediate
Sets the value of the condition flags to the result of the comparison of a 
register value and an immediate value if the condition is TRUE, 
and an immediate value otherwise.

CCMP &lt;Xn&gt;, #&lt;imm&gt;, #&lt;nzcv&gt;, &lt;cond&gt;

2. Register
Sets the value of the condition flags to the result of the comparison of two 
registers if the condition is TRUE, and an immediate value otherwise.

CCMP &lt;Xn&gt;, &lt;Xm&gt;, #&lt;nzcv&gt;, &lt;cond&gt;</hint>
			<hint page="482" header="Conditional Increment" doc_id="armv8arm" token="CINC">Returns, in the destination register, the value of the source 
register incremented by 1 if the condition is TRUE, 
and otherwise returns the value of the source register.

CINC &lt;Xd&gt;, &lt;Xn&gt;, &lt;cond&gt;

  is equivalent to

CSINC &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xn&gt;, invert(&lt;cond&gt;)</hint>
			<hint page="483" header="Conditional Invert" doc_id="armv8arm" token="CINV">Returns, in the destination register, the bitwise inversion 
of the value of the source register if the condition is TRUE,
and otherwise returns the value of the source register.

CINV &lt;Xd&gt;, &lt;Xn&gt;, &lt;cond&gt;

  is equivalent to

CSINV &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xn&gt;, invert(&lt;cond&gt;)</hint>
			<hint page="485" header="Count leading sign bits" doc_id="armv8arm" token="CLS">Count leading sign bits : Rd = CLS(Rn)

CLS &lt;Xd&gt;, &lt;Xn&gt;</hint>
			<hint page="486" header="Count leading zero bits" doc_id="armv8arm" token="CLZ">Count leading zero bits : Rd = CLZ(Rn)

CLZ &lt;Wd&gt;, &lt;Wn&gt;</hint>
			<hint page="487" header="Compare Negative" doc_id="armv8arm" token="CMN">1. Extended register
Adds a register value and a sign or zero-extended register value, 
followed by an optional left shift amount. 
It updates the condition flags based on the result, and discards the result.

CMN &lt;Xn|SP&gt;, &lt;R&gt;&lt;m&gt;{, &lt;extend&gt; {#&lt;amount&gt;}}

  is equivalent to

ADDS XZR, &lt;Xn|SP&gt;, &lt;R&gt;&lt;m&gt;{, &lt;extend&gt; {#&lt;amount&gt;}}

2. Immediate
Adds a register value and an optionally-shifted immediate value. 
It updates the condition flags based on the result, and discards the result.

CMN &lt;Xn|SP&gt;, #&lt;imm&gt;{, &lt;shift&gt;}

  is equivalent to

ADDS XZR, &lt;Xn|SP&gt;, #&lt;imm&gt; {, &lt;shift&gt;}

3. Shifted register
Adds a register value and an optionally-shifted register value. 
It updates the condition flags based on the result, and discards the result.

CMN &lt;Xn&gt;, &lt;Xm&gt;{, &lt;shift&gt; #&lt;amount&gt;}

  is equivalent to

ADDS XZR, &lt;Xn&gt;, &lt;Xm&gt; {, &lt;shift&gt; #&lt;amount&gt;}</hint>
			<hint page="492" header="Compare" doc_id="armv8arm" token="CMP">1. Extended register
Subtracts a sign or zero-extended register value, followed by an optional left shift amount, 
from a register value. 
It updates the condition flags based on the result, and discards the result.

CMP &lt;Xn|SP&gt;, &lt;R&gt;&lt;m&gt;{, &lt;extend&gt; {#&lt;amount&gt;}}

  is equivalent to

SUBS XZR, &lt;Xn|SP&gt;, &lt;R&gt;&lt;m&gt;{, &lt;extend&gt; {#&lt;amount&gt;}}

2. Immediate
subtracts an optionally-shifted immediate value from a register value. 
It updates the condition flags based on the result, and discards the result.

CMP &lt;Xn|SP&gt;, #&lt;imm&gt;{, &lt;shift&gt;}

  is equivalent to

SUBS XZR, &lt;Xn|SP&gt;, #&lt;imm&gt; {, &lt;shift&gt;}

3. Shifted register
Subtracts an optionally-shifted register value from a register value. 
It updates the condition flags based on the result, and discards the result.

CMP &lt;Xn&gt;, &lt;Xm&gt;{, &lt;shift&gt; #&lt;amount&gt;}

  is equivalent to

SUBS XZR, &lt;Xn&gt;, &lt;Xm&gt; {, &lt;shift&gt; #&lt;amount&gt;}</hint>
			<hint page="497" header="Conditional Negate" doc_id="armv8arm" token="CNEG">Returns, in the destination register, the negated value of the source 
register if the condition is TRUE, and otherwise returns the value of 
the source register.

CNEG &lt;Xd&gt;, &lt;Xn&gt;, &lt;cond&gt;

  is equivalent to

CSNEG &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xn&gt;, invert(&lt;cond&gt;)</hint>
			<hint page="502" header="Conditional Select" doc_id="armv8arm" token="CSEL">Returns, in the destination register, the value of the first source 
register if the condition is TRUE, and otherwise returns the value 
of the second source register.

CSEL &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;, &lt;cond&gt;</hint>
			<hint page="503" header="Conditional Set" doc_id="armv8arm" token="CSET">Sets the destination register to 1 if the condition is TRUE, 
and otherwise sets it to 0.

CSET &lt;Xd&gt;, &lt;cond&gt;

  is equivalent to

CSINC &lt;Xd&gt;, XZR, XZR, invert(&lt;cond&gt;)</hint>
			<hint page="504" header="Conditional Set Mask" doc_id="armv8arm" token="CSETM">Sets all bits of the destination register to 1 if the 
condition is TRUE, and otherwise sets all bits to 0.

CSETM &lt;Xd&gt;, &lt;cond&gt;

  is equivalent to

CSINV &lt;Xd&gt;, XZR, XZR, invert(&lt;cond&gt;)</hint>
			<hint page="505" header="Conditional Select Increment" doc_id="armv8arm" token="CSINC">Returns, in the destination register, the value of the first source 
register if the condition is TRUE, and otherwise returns the value 
of the second source register incremented by 1.

CSINC &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;, &lt;cond&gt;</hint>
			<hint page="507" header="Conditional Select Invert" doc_id="armv8arm" token="CSINV">Returns, in the destination register, the value of the first source 
register if the condition is TRUE, and otherwise returns the bitwise 
inversion value of the second source register.

CSINV &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;, &lt;cond&gt;</hint>
			<hint page="509" header="Conditional Select Negation" doc_id="armv8arm" token="CSNEG">Returns, in the destination register, the value of the first source 
register if the condition is TRUE, and otherwise returns the negated 
value of the second source register.

CSNEG &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;, &lt;cond&gt;</hint>
			<hint page="520" header="Bitwise Exclusive OR NOT" doc_id="armv8arm" token="EON">Performs a bitwise Exclusive OR NOT of a register value 
and an optionally-shifted register value, and writes 
the result to the destination register.

EON &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;{, &lt;shift&gt; #&lt;amount&gt;}</hint>
			<hint page="522" header="Bitwise Exclusive OR" doc_id="armv8arm" token="EOR">1. Immediate
Performs a bitwise Exclusive OR of a register value 
and an immediate value, and writes the result to 
the destination register.

EOR &lt;Xd|SP&gt;, &lt;Xn&gt;, #&lt;imm&gt;

2. Shifted register
Performs a bitwise Exclusive OR of a register value 
and an optionally-shifted register value, and writes 
the result to the destination register.

EOR &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;{, &lt;shift&gt; #&lt;amount&gt;}</hint>
			<hint page="526" header="Extract register" doc_id="armv8arm" token="EXTR">Extracts a register from a pair of registers.

EXTR &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;, #&lt;lsb&gt;</hint>
			<hint page="533" header="Load-Acquire Register" doc_id="armv8arm" token="LDAR">Derives an address from a base register value, 
loads a 32-bit word or 64-bit doubleword from 
memory, and writes it to a register.

LDAR &lt;Xt&gt;, [&lt;Xn|SP&gt;{,#0}]</hint>
			<hint page="534" header="Load-Acquire Register Byte" doc_id="armv8arm" token="LDARB">Derives an address from a base register value, 
loads a byte from memory, zero-extends it and 
writes it to a register. 

LDARB &lt;Wt&gt;, [&lt;Xn|SP&gt;{,#0}]</hint>
			<hint page="535" header="Load-Acquire Register Halfword" doc_id="armv8arm" token="LDARH">Derives an address from a base register value, 
loads a halfword from memory, zero-extends it, 
and writes it to a register. 

LDARH &lt;Wt&gt;, [&lt;Xn|SP&gt;{,#0}]</hint>
			<hint page="536" header="Load-Acquire Exclusive Pair of Registers" doc_id="armv8arm" token="LDAXP">Derives an address from a base register value, loads two 32-bit words or 
two 64-bit doublewords from memory, and writes them to two registers. 
A 32-bit pair requires the address to be doubleword aligned and is 
single-copy atomic at doubleword granularity. A 64-bit pair requires 
the address to be quadword aligned and is single-copy atomic for each 
doubleword at doubleword granularity. The PE marks the physical address 
being accessed as an exclusive access. This exclusive access mark is 
checked by Store Exclusive instructions.

LDAXP &lt;Xt1&gt;, &lt;Xt2&gt;, [&lt;Xn|SP&gt;{,#0}]</hint>
			<hint page="538" header="Load-Acquire Exclusive Register" doc_id="armv8arm" token="LDAXR">Derives an address from a base register value, loads a 32-bit word 
or 64-bit doubleword from memory, and writes it to a register. 
The memory access is atomic. The PE marks the physical address 
being accessed as an exclusive access. This exclusive access mark 
is checked by Store Exclusive instructions.

LDAXR &lt;Xt&gt;, [&lt;Xn|SP&gt;{,#0}]</hint>
			<hint page="540" header="Load-Acquire Exclusive Register Byte" doc_id="armv8arm" token="LDAXRB">Derives an address from a base register value, loads a byte from memory, 
zero-extends it and writes it to a register. The memory access is atomic.
The PE marks the physical address being accessed as an exclusive access. 
This exclusive access mark is checked by Store Exclusive instructions. 

LDAXRB &lt;Wt&gt;, [&lt;Xn|SP&gt;{,#0}]</hint>
			<hint page="541" header="Load-Acquire Exclusive Register Halfword" doc_id="armv8arm" token="LDAXRH">Derives an address from a base register value, loads a halfword from memory, 
zero-extends it and writes it to a register. The memory access is atomic.
The PE marks the physical address being accessed as an exclusive access. 
This exclusive access mark is checked by Store Exclusive instructions.

LDAXRH &lt;Wt&gt;, [&lt;Xn|SP&gt;{,#0}]</hint>
			<hint page="542" header="Load Pair of Registers w non-temporal hint" doc_id="armv8arm" token="LDNP">Calculates an address from a base register value and an 
immediate offset, loads two 32-bit words or two 64-bit 
doublewords from memory, and writes them to two registers.

LDNP &lt;Xt1&gt;, &lt;Xt2&gt;, [&lt;Xn|SP&gt;{, #&lt;imm&gt;}]</hint>
			<hint page="544" header="Load Pair of Registers" doc_id="armv8arm" token="LDP">Calculates an address from a base register value and an 
immediate offset, loads two 32-bit words or two 64-bit 
doublewords from memory, and writes them to two registers.

Post-index:    LDP &lt;Xt1&gt;, &lt;Xt2&gt;, [&lt;Xn|SP&gt;], #&lt;imm&gt;
Pre-index:     LDP &lt;Xt1&gt;, &lt;Xt2&gt;, [&lt;Xn|SP&gt;, #&lt;imm&gt;]!
Signed offset: LDP &lt;Xt1&gt;, &lt;Xt2&gt;, [&lt;Xn|SP&gt;{, #&lt;imm&gt;}]</hint>
			<hint page="547" header="Load Pair of Registers Signed Word" doc_id="armv8arm" token="LDPSW">Calculates an address from a base register value and an 
immediate offset, loads two 32-bit words from memory, 
sign-extends them, and writes them to two registers.

Post-index:    LDPSW &lt;Xt1&gt;, &lt;Xt2&gt;, [&lt;Xn|SP&gt;], #&lt;imm&gt;
Pre-index:     LDPSW &lt;Xt1&gt;, &lt;Xt2&gt;, [&lt;Xn|SP&gt;, #&lt;imm&gt;]!
Signed offset: LDPSW &lt;Xt1&gt;, &lt;Xt2&gt;, [&lt;Xn|SP&gt;{, #&lt;imm&gt;}]</hint>
			<hint page="550" header="Load Register" doc_id="armv8arm" token="LDR">1. Immediate
Loads a word or doubleword from memory and writes it to a register. 
The address that is used for the load is calculated from a base 
register and an immediate offset.

Post-index:      LDR &lt;Xt&gt;, [&lt;Xn|SP&gt;], #&lt;simm&gt;
Pre-index:       LDR &lt;Xt&gt;, [&lt;Xn|SP&gt;, #&lt;simm&gt;]!
Unsigned offset: LDR &lt;Xt&gt;, [&lt;Xn|SP&gt;{, #&lt;pimm&gt;}]

2. Literal
Calculates an address from the PC value and an immediate offset, 
loads a word from memory, and writes it to a register.

LDR &lt;Xt&gt;, &lt;label&gt;

3. Register
Calculates an address from a base register value and an offset register 
value, loads a word from memory, and writes it to a register. The offset 
register value can optionally be shifted and extended.

LDR &lt;Xt&gt;, [&lt;Xn|SP&gt;, (&lt;Wm&gt;|&lt;Xm&gt;){, &lt;extend&gt; {&lt;amount&gt;}}]</hint>
			<hint page="557" header="Load Register Byte" doc_id="armv8arm" token="LDRB">1. Immediate
Loads a byte from memory, zero-extends it, and writes the result 
to a register. The address that is used for the load is calculated 
from a base register and an immediate offset.

Post-index:      LDRB &lt;Wt&gt;, [&lt;Xn|SP&gt;], #&lt;simm&gt;
Pre-index:       LDRB &lt;Wt&gt;, [&lt;Xn|SP&gt;, #&lt;simm&gt;]!
Unsigned offset: LDRB &lt;Wt&gt;, [&lt;Xn|SP&gt;{, #&lt;pimm&gt;}]

2. Register
Calculates an address from a base register value and an offset 
register value, loads a byte from memory, zero-extends it, 
and writes it to a register.

Extended register variant:
  LDR &lt;Xt&gt;, [&lt;Xn|SP&gt;, (&lt;Wm&gt;|&lt;Xm&gt;){, &lt;extend&gt; {&lt;amount&gt;}}]

Shifted register variant:
  LDRB &lt;Wt&gt;, [&lt;Xn|SP&gt;, &lt;Xm&gt;{, LSL &lt;amount&gt;}]</hint>
			<hint page="561" header="Load Register Halfword" doc_id="armv8arm" token="LDRH">1. Immediate
Loads a halfword from memory, zero-extends it, and writes the 
result to a register. The address that is used for the load is 
calculated from a base register and an immediate offset.

Post-index:      LDRH &lt;Wt&gt;, [&lt;Xn|SP&gt;], #&lt;simm&gt;

Pre-index:       LDRH &lt;Wt&gt;, [&lt;Xn|SP&gt;, #&lt;simm&gt;]!
Unsigned offset: LDRH &lt;Wt&gt;, [&lt;Xn|SP&gt;{, #&lt;pimm&gt;}]

2. Register
Calculates an address from a base register value and an offset 
register value, loads a halfword from memory, zero-extends it, 
and writes it to a register.

32-bit variant:
  LDRH &lt;Wt&gt;, [&lt;Xn|SP&gt;, (&lt;Wm&gt;|&lt;Xm&gt;){, &lt;extend&gt; {&lt;amount&gt;}}]</hint>
			<hint page="565" header="Load Register Signed Byte" doc_id="armv8arm" token="LDRSB">1. Immediate
Loads a byte from memory, sign-extends it to either 32 bits or 64 bits, 
and writes the result to a register. The address that is used for the 
load is calculated from a base register and an immediate offset.

Post-index:      LDRSB &lt;Xt&gt;, [&lt;Xn|SP&gt;], #&lt;simm&gt;
Pre-index:       LDRSB &lt;Xt&gt;, [&lt;Xn|SP&gt;, #&lt;simm&gt;]!
Unsigned offset: LDRSB &lt;Xt&gt;, [&lt;Xn|SP&gt;{, #&lt;pimm&gt;}]

2. Register
Calculates an address from a base register value and an offset register value, 
loads a byte from memory, sign-extends it, and writes it to a register.

64-bit with extended register offset variant
  LDRSB &lt;Xt&gt;, [&lt;Xn|SP&gt;, (&lt;Wm&gt;|&lt;Xm&gt;), &lt;extend&gt; {&lt;amount&gt;}]
64-bit with shifted register offset variant
  LDRSB &lt;Xt&gt;, [&lt;Xn|SP&gt;, &lt;Xm&gt;{, LSL &lt;amount&gt;}]</hint>
			<hint page="570" header="Load Register Signed Halfword" doc_id="armv8arm" token="LDRSH">1. Immediate
Loads a halfword from memory, sign-extends it to 32 bits or 64 bits, 
and writes the result to a register. The address that is used for the 
load is calculated from a base register and an immediate offset.

Post-index:      LDRSH &lt;Xt&gt;, [&lt;Xn|SP&gt;], #&lt;simm&gt;
Pre-index:       LDRSH &lt;Xt&gt;, [&lt;Xn|SP&gt;, #&lt;simm&gt;]!
Unsigned offset: LDRSH &lt;Xt&gt;, [&lt;Xn|SP&gt;{, #&lt;pimm&gt;}]

2. Register
Calculates an address from a base register value and an offset register 
value, loads a halfword from memory, sign-extends it, and writes it to 
a register.

LDRSH &lt;Xt&gt;, [&lt;Xn|SP&gt;, (&lt;Wm&gt;|&lt;Xm&gt;){, &lt;extend&gt; {&lt;amount&gt;}}]</hint>
			<hint page="578" header="Load Register Signed Word" doc_id="armv8arm" token="LDRSW">1. Immediate
Loads a word from memory, sign-extends it to 64 bits, and writes the 
result to a register. The address that is used for the load is 
calculated from a base register and an immediate offset. 

Post-index:      LDRSW &lt;Xt&gt;, [&lt;Xn|SP&gt;], #&lt;simm&gt;
Pre-index:       LDRSW &lt;Xt&gt;, [&lt;Xn|SP&gt;, #&lt;simm&gt;]!
Unsigned offset: LDRSW &lt;Xt&gt;, [&lt;Xn|SP&gt;{, #&lt;pimm&gt;}]

2. Literal
Calculates an address from the PC value and an immediate offset, 
loads a word from memory, and writes it to a register.

LDRSW &lt;Xt&gt;, &lt;label&gt;

3. Register
Calculates an address from a base register value and an offset register 
value, loads a word from memory, sign-extends it to form a 64-bit value, 
and writes it to a register. The offset register value can be shifted 
left by 0 or 2 bits.

LDRSW &lt;Xt&gt;, [&lt;Xn|SP&gt;, (&lt;Wm&gt;|&lt;Xm&gt;){, &lt;extend&gt; {&lt;amount&gt;}}]</hint>
			<hint page="580" header="Load Register (unprivileged)" doc_id="armv8arm" token="LDTR">Loads a word or doubleword from memory, and writes it to a register. 
The address that is used for the load is calculated from a base 
register and an immediate offset.

LDTR &lt;Xt&gt;, [&lt;Xn|SP&gt;{, #&lt;simm&gt;}]</hint>
			<hint page="582" header="Load Register Byte (unprivileged)" doc_id="armv8arm" token="LDTRB">Loads a byte from memory, zero-extends it, and writes the result 
to a register. The address that is used for the load is 
calculated from a base register and an immediate offset.

LDTRB &lt;Wt&gt;, [&lt;Xn|SP&gt;{, #&lt;simm&gt;}]</hint>
			<hint page="583" header="Load Register Halfword (unprivileged)" doc_id="armv8arm" token="LDTRH">Loads a halfword from memory, zero-extends it, and writes the 
result to a register. The address that is used for the load is 
calculated from a base register and an immediate offset.

LDTRH &lt;Wt&gt;, [&lt;Xn|SP&gt;{, #&lt;simm&gt;}]</hint>
			<hint page="584" header="Load Register Signed Byte (unprivileged)" doc_id="armv8arm" token="LDTRSB">Loads a byte from memory, sign-extends it to 32 bits or 64 bits, 
and writes the result to a register. The address that is used 
for the load is calculated from a base register and an immediate offset.

LDTRSB &lt;Xt&gt;, [&lt;Xn|SP&gt;{, #&lt;simm&gt;}]</hint>
			<hint page="586" header="Load Register Signed Halfword (unprivileged)" doc_id="armv8arm" token="LDTRSH">Loads a halfword from memory, sign-extends it to 32 bits or 64 bits, 
and writes the result to a register. The address that is used for 
the load is calculated from a base register and an immediate offset.

LDTRSH &lt;Xt&gt;, [&lt;Xn|SP&gt;{, #&lt;simm&gt;}]</hint>
			<hint page="588" header="Load Register Signed Word (unprivileged)" doc_id="armv8arm" token="LDTRSW">Loads a word from memory, sign-extends it to 64 bits, and writes 
the result to a register. The address that is used for the load 
is calculated from a base register and an immediate offset.

LDTRSW &lt;Xt&gt;, [&lt;Xn|SP&gt;{, #&lt;simm&gt;}]</hint>
			<hint page="589" header="Load Register (unscaled) " doc_id="armv8arm" token="LDUR">Calculates an address from a base register and an immediate offset, 
loads a 32-bit word or 64-bit doubleword from memory, zero-extends 
it, and writes it to a register.

LDUR &lt;Xt&gt;, [&lt;Xn|SP&gt;{, #&lt;simm&gt;}]</hint>
			<hint page="591" header="Load Register Byte (unscaled) " doc_id="armv8arm" token="LDURB">Calculates an address from a base register and an immediate offset, 
loads a byte from memory, zero-extends it, and writes it to a register.

LDURB &lt;Wt&gt;, [&lt;Xn|SP&gt;{, #&lt;simm&gt;}]</hint>
			<hint page="592" header="Load Register Halfword (unscaled) " doc_id="armv8arm" token="LDURH">Calculates an address from a base register and an immediate 
offset, loads a halfword from memory, zero-extends it, and 
writes it to a register.

LDURH &lt;Wt&gt;, [&lt;Xn|SP&gt;{, #&lt;simm&gt;}]</hint>
			<hint page="593" header="Load Register Signed Byte (unscaled) " doc_id="armv8arm" token="LDURSB">Calculates an address from a base register and an immediate 
offset, loads a signed byte from memory, sign-extends it, 
and writes it to a register.

LDURSB &lt;Xt&gt;, [&lt;Xn|SP&gt;{, #&lt;simm&gt;}]</hint>
			<hint page="595" header="Load Register Signed Halfword (unscaled) " doc_id="armv8arm" token="LDURSH">Calculates an address from a base register and an immediate 
offset, loads a signed halfword from memory, sign-extends 
it, and writes it to a register.

LDURSH &lt;Xt&gt;, [&lt;Xn|SP&gt;{, #&lt;simm&gt;}]</hint>
			<hint page="597" header="Load Register Signed Word (unscaled) " doc_id="armv8arm" token="LDURSW">Calculates an address from a base register and an immediate 
offset, loads a signed word from memory, sign-extends it, 
and writes it to a register.

LDURSW &lt;Xt&gt;, [&lt;Xn|SP&gt;{, #&lt;simm&gt;}]</hint>
			<hint page="598" header="Load Exclusive Pair of Registers" doc_id="armv8arm" token="LDXP">Derives an address from a base register value, loads two 32-bit 
words or two 64-bit doublewords from memory, and writes them to 
two registers. A 32-bit pair requires the address to be doubleword 
aligned and is single-copy atomic at doubleword granularity.
 A 64-bit pair requires the address to be quadword aligned and is 
single-copy atomic for each doubleword at doubleword granularity. 
The PE marks the physical address being accessed as an exclusive 
access. This exclusive access mark is checked by Store Exclusive 
instructions. 

LDXP &lt;Xt1&gt;, &lt;Xt2&gt;, [&lt;Xn|SP&gt;{,#0}]</hint>
			<hint page="600" header="Load Exclusive Register" doc_id="armv8arm" token="LDXR">Derives an address from a base register value, loads a 32-bit word 
or a 64-bit doubleword from memory, and writes it to a register. 
The memory access is atomic. The PE marks the physical address 
being accessed as an exclusive access. This exclusive access mark 
is checked by Store Exclusive instructions.  

LDXR &lt;Xt&gt;, [&lt;Xn|SP&gt;{,#0}]</hint>
			<hint page="601" header="Load Exclusive Register Byte" doc_id="armv8arm" token="LDXRB">Derives an address from a base register value, loads a byte from memory, 
zero-extends it and writes it to a register. The memory access is atomic. 
The PE marks the physical address being accessed as an exclusive access. 
This exclusive access mark is checked by Store Exclusive instructions.

LDXRB &lt;Wt&gt;, [&lt;Xn|SP&gt;{,#0}]</hint>
			<hint page="602" header="Load Exclusive Register Halfword" doc_id="armv8arm" token="LDXRH">Derives an address from a base register value, loads a halfword from memory, 
zero-extends it and writes it to a register. The memory access is atomic. 
The PE marks the physical address being accessed as an exclusive access. 
This exclusive access mark is checked by Store Exclusive instructions. 

LDXRH &lt;Wt&gt;, [&lt;Xn|SP&gt;{,#0}]</hint>
			<hint page="603" header="Logical Shift Left" doc_id="armv8arm" token="LSL">1. Register
Shifts a register value left by a variable number of bits, shifting 
in zeros, and writes the result to the destination register. The 
remainder obtained by dividing the second source register by the 
data size defines the number of bits by which the first source 
register is left-shifted.

LSL &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;

  is equivalent to

LSLV &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;

2. Immediate
Shifts a register value left by an immediate number of bits, shifting 
in zeros, and writes the result to the destination register.

LSL &lt;Xd&gt;, &lt;Xn&gt;, #&lt;shift&gt;

  is equivalent to

UBFM &lt;Xd&gt;, &lt;Xn&gt;, #(-&lt;shift&gt; MOD 64), #(63-&lt;shift&gt;)</hint>
			<hint page="605" header="Logical Shift Left Variable" doc_id="armv8arm" token="LSLV">Shifts a register value left by a variable number of bits, shifting 
in zeros, and writes the result to the destination register. The 
remainder obtained by dividing the second source register by the 
data size defines the number of bits by which the first source 
register is left-shifted.

LSLV &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;</hint>
			<hint page="606" header="Logical Shift Right" doc_id="armv8arm" token="LSR">1. Register
Shifts a register value right by a variable number of bits, shifting in 
zeros, and writes the result to the destination register. The remainder 
obtained by dividing the second source register by the data size defines 
the number of bits by which the first source register is right-shifted.

LSR &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;

  is equivalent to

LSRV &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;

2. Immediate
Shifts a register value right by an immediate number of bits, shifting 
in zeros, and writes the result to the destination register.

LSR &lt;Xd&gt;, &lt;Xn&gt;, #&lt;shift&gt;

  is equivalent to

UBFM &lt;Xd&gt;, &lt;Xn&gt;, #&lt;shift&gt;, #63</hint>
			<hint page="608" header="Logical Shift Right Variable" doc_id="armv8arm" token="LSRV">Shifts a register value right by a variable number of bits, 
shifting in zeros, and writes the result to the destination 
register. The remainder obtained by dividing the second 
source register by the data size defines the number of bits 
by which the first source register is right-shifted.

LSRV &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;</hint>
			<hint page="609" header="Multiply-Add" doc_id="armv8arm" token="MADD">Multiplies two register values, adds a third register value, 
and writes the result to the destination register.

MADD &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;, &lt;Xa&gt;</hint>
			<hint page="611" header="Multiply-Negate" doc_id="armv8arm" token="MNEG">Multiplies two register values, negates the product, and writes 
the result to the destination register.

MNEG &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;

  is equivalent to

MSUB &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;, XZR</hint>
			<hint page="612" header="Move" doc_id="armv8arm" token="MOV">1. To/from SP - moves between register and stack pointer : Rd = Rn

MOV &lt;Xd|SP&gt;, &lt;Xn|SP&gt;
  is equivalent to
ADD &lt;Xd|SP&gt;, &lt;Xn|SP&gt;, #0

2. Inverted wide immediate - moves an inverted 16-bit immediate 
   value to a register.

MOV &lt;Xd&gt;, #&lt;imm&gt;
  is equivalent to
MOVN &lt;Xd&gt;, #&lt;imm16&gt;, LSL #&lt;shift&gt;

3. Wide immediate - moves a 16-bit immediate value to a register.

MOV &lt;Xd&gt;, #&lt;imm&gt;
  is equivalent to
MOVZ &lt;Xd&gt;, #&lt;imm16&gt;, LSL #&lt;shift&gt;

4. Bitmask immediate - writes a bitmask immediate value to a register.

MOV &lt;Xd|SP&gt;, #&lt;imm&gt;
  is equivalent to
ORR &lt;Xd|SP&gt;, XZR, #&lt;imm&gt;

5. Register - copies the value in a source register to the destination register.

MOV &lt;Xd&gt;, &lt;Xm&gt;
  is equivalent to
ORR &lt;Xd&gt;, XZR, &lt;Xm&gt;</hint>
			<hint page="617" header="Move wide with keep" doc_id="armv8arm" token="MOVK">Moves an optionally-shifted 16-bit immediate value into a register, 
keeping other bits unchanged.

MOVK &lt;Xd&gt;, #&lt;imm&gt;{, LSL #&lt;shift&gt;}</hint>
			<hint page="618" header="Move wide with NOT" doc_id="armv8arm" token="MOVN">Moves the inverse of an optionally-shifted 16-bit immediate 
value to a register.

MOVN &lt;Xd&gt;, #&lt;imm&gt;{, LSL #&lt;shift&gt;}</hint>
			<hint page="620" header="Move wide with zero" doc_id="armv8arm" token="MOVZ">Moves an optionally-shifted 16-bit immediate value to a register.

MOVZ &lt;Xd&gt;, #&lt;imm&gt;{, LSL #&lt;shift&gt;}</hint>
			<hint page="626" header="Multiply-Subtract" doc_id="armv8arm" token="MSUB">Multiplies two register values, subtracts the product from a third 
register value, and writes the result to the destination register.

MSUB &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;, &lt;Xa&gt;</hint>
			<hint page="628" header="Multiply" doc_id="armv8arm" token="MUL">Multiply : Rd = Rn * Rm

MUL &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;

  is equivalent to

MADD &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;, XZR</hint>
			<hint page="629" header="Bitwise NOT" doc_id="armv8arm" token="MVN">Writes the bitwise inverse of a register value to the destination register.

MVN &lt;Xd&gt;, &lt;Xm&gt;{, &lt;shift&gt; #&lt;amount&gt;}

  is equivalent to

ORN &lt;Xd&gt;, XZR, &lt;Xm&gt;{, &lt;shift&gt; #&lt;amount&gt;}</hint>
			<hint page="631" header="Negate" doc_id="armv8arm" token="NEG">Negates (shifted register) an optionally-shifted register value, 
and writes the result to the destination register.

NEG &lt;Xd&gt;, &lt;Xm&gt;{, &lt;shift&gt; #&lt;amount&gt;}

  is equivalent to

SUB &lt;Xd&gt;, XZR, &lt;Xm&gt; {, &lt;shift&gt; #&lt;amount&gt;}</hint>
			<hint page="633" header="Negate (setting flags)" doc_id="armv8arm" token="NEGS">Negates an optionally-shifted register value, and writes the 
result to the destination register. It updates the condition 
flags based on the result.

NEGS &lt;Xd&gt;, &lt;Xm&gt;{, &lt;shift&gt; #&lt;amount&gt;}

  is equivalent to

SUBS &lt;Xd&gt;, XZR, &lt;Xm&gt; {, &lt;shift&gt; #&lt;amount&gt;}</hint>
			<hint page="635" header="Negate with Carry" doc_id="armv8arm" token="NGC">Negates the sum of a register value and the value of NOT (Carry flag), 
and writes the result to the destination register.

NGC &lt;Xd&gt;, &lt;Xm&gt;

  is equivalent to

SBC &lt;Xd&gt;, XZR, &lt;Xm&gt;</hint>
			<hint page="636" header="Negate with Carry (setting flags)" doc_id="armv8arm" token="NGCS">Negates the sum of a register value and the value of NOT (Carry flag), 
and writes the result to the destination register. It updates the 
condition flags based on the result.

NGCS &lt;Xd&gt;, &lt;Xm&gt;

  is equivalent to

SBCS &lt;Xd&gt;, XZR, &lt;Xm&gt;</hint>
			<hint page="638" header="Bitwise OR NOT" doc_id="armv8arm" token="ORN">Performs a bitwise (inclusive) OR of a register value and the 
complement of an optionally-shifted register value, and writes 
the result to the destination register.

ORN &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;{, &lt;shift&gt; #&lt;amount&gt;}</hint>
			<hint page="640" header="Bitwise OR" doc_id="armv8arm" token="ORR">1. Immediate
Performs a bitwise (inclusive) OR of a register value and an immediate 
register value, and writes the result to the destination register.

ORR &lt;Xd|SP&gt;, &lt;Xn&gt;, #&lt;imm&gt;

2. Shifted register
Performs a bitwise (inclusive) OR of a register value and an 
optionally-shifted register value, and writes the result to the 
destination register.

ORR &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;{, &lt;shift&gt; #&lt;amount&gt;}</hint>
			<hint page="644" header="Prefetch Memory" doc_id="armv8arm" token="PRFM">Signals the memory system that data memory accesses from a specified 
address are likely to occur in the near future. The memory system can 
respond by taking actions that are expected to speed up the memory 
accesses when they do occur, such as preloading the cache line 
containing the specified address into one or more caches.

1. Immediate

PRFM (&lt;prfop&gt;|#&lt;imm5&gt;), [&lt;Xn|SP&gt;{, #&lt;pimm&gt;}]

2. Literal

PRFM (&lt;prfop&gt;|#&lt;imm5&gt;), &lt;label&gt;

3. Register

PRFM (&lt;prfop&gt;|#&lt;imm5&gt;), [&lt;Xn|SP&gt;, (&lt;Wm&gt;|&lt;Xm&gt;){, &lt;extend&gt; {&lt;amount&gt;}}]

4. Unscaled offset

PRFUM (&lt;prfop&gt;|#&lt;imm5&gt;), [&lt;Xn|SP&gt;{, #&lt;simm&gt;}]</hint>
			<hint page="652" header="Reverse Bits" doc_id="armv8arm" token="RBIT">Reverses the bit order in a register.

RBIT &lt;Xd&gt;, &lt;Xn&gt;</hint>
			<hint page="653" header="Return" doc_id="armv8arm" token="RET">Return from subroutine branches unconditionally to an address in a 
register, with a hint that this is a subroutine return.

RET {&lt;Xn&gt;}</hint>
			<hint page="654" header="Reverse Bytes" doc_id="armv8arm" token="REV">Reverses the byte order in a register.

REV &lt;Xd&gt;, &lt;Xn&gt;</hint>
			<hint page="656" header="Reverse bytes in 16-bit halfwords" doc_id="armv8arm" token="REV16">Reverses the byte order in each 16-bit halfword of a register.

REV16 &lt;Xd&gt;, &lt;Xn&gt;</hint>
			<hint page="658" header="Reverse bytes in 32-bit words" doc_id="armv8arm" token="REV32">Reverses the byte order in each 32-bit word of a register.

REV32 &lt;Xd&gt;, &lt;Xn&gt;</hint>
			<hint page="659" header="Reverse bytes in 64-bit words" doc_id="armv8arm" token="REV64">Reverse Bytes reverses the byte order in a 64-bit general-purpose register.

REV64 &lt;Xd&gt;, &lt;Xn&gt;

  is equivalent to

REV &lt;Xd&gt;, &lt;Xn&gt;</hint>
			<hint page="660" header="Rotate right" doc_id="armv8arm" token="ROR">1. Immediate
Provides the value of the contents of a register rotated by a variable 
number of bits. The bits that are rotated off the right end are inserted 
into the vacated bit positions on the left.

ROR &lt;Xd&gt;, &lt;Xs&gt;, #&lt;shift&gt;

  is equivalent to

EXTR &lt;Xd&gt;, &lt;Xs&gt;, &lt;Xs&gt;, #&lt;shift&gt;

2. Register
Provides the value of the contents of a register rotated by a variable number 
of bits. The bits that are rotated off the right end are inserted into the 
vacated bit positions on the left. The remainder obtained by dividing the 
second source register by the data size defines the number of bits by which 
the first source register is right-shifted.

ROR &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;

  is equivalent to

RORV &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;</hint>
			<hint page="662" header="Rotate Right Variable" doc_id="armv8arm" token="RORV">Provides the value of the contents of a register rotated by a variable 
number of bits. The bits that are rotated off the right end are inserted 
into the vacated bit positions on the left. The remainder obtained by 
dividing the second source register by the data size defines the number 
of bits by which the first source register is right-shifted.

RORV &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;</hint>
			<hint page="663" header="Subtract with Carry" doc_id="armv8arm" token="SBC">Subtracts a register value and the value of NOT (Carry flag) from a 
register value, and writes the result to the destination register.

SBC &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;</hint>
			<hint page="665" header="Subtract with Carry (setting flags)" doc_id="armv8arm" token="SBCS">Subtracts a register value and the value of NOT (Carry flag) from a 
register value, and writes the result to the destination register. 
It updates the condition flags based on the result.

SBCS &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;</hint>
			<hint page="667" header="Signed Bitfield Insert in Zero " doc_id="armv8arm" token="SBFIZ">Zeroes the destination register and copies any number of contiguous bits
 from a source register into any position in the destination register, 
sign-extending the most significant bit of the transferred value.

SBFIZ &lt;Xd&gt;, &lt;Xn&gt;, #&lt;lsb&gt;, #&lt;width&gt;

  is equivalent to

SBFM &lt;Xd&gt;, &lt;Xn&gt;, #(-&lt;lsb&gt; MOD 64), #(&lt;width&gt;-1)</hint>
			<hint page="668" header="Signed Bitfield Move" doc_id="armv8arm" token="SBFM">Copies any number of low-order bits from a source register into the 
same number of adjacent bits at any position in the destination 
register, shifting in copies of the sign bit in the upper bits and 
zeros in the lower bits.

SBFM &lt;Xd&gt;, &lt;Xn&gt;, #&lt;immr&gt;, #&lt;imms&gt;</hint>
			<hint page="670" header="Signed Bitfield Extract" doc_id="armv8arm" token="SBFX">Extracts any number of adjacent bits at any position from a register, 
sign-extends them to the size of the register, and writes the result 
to the destination register.

SBFX &lt;Xd&gt;, &lt;Xn&gt;, #&lt;lsb&gt;, #&lt;width&gt;

  is equivalent to

SBFM &lt;Xd&gt;, &lt;Xn&gt;, #&lt;lsb&gt;, #(&lt;lsb&gt;+&lt;width&gt;-1)</hint>
			<hint page="671" header="Signed Divide" doc_id="armv8arm" token="SDIV">Divides a signed integer register value by another signed integer 
register value, and writes the result to the destination register. 
The condition flags are not affected.

SDIV &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;</hint>
			<hint page="674" header="Signed Multiply-Add Long" doc_id="armv8arm" token="SMADDL">Multiplies two 32-bit register values, adds a 64-bit register value, 
and writes the result to the 64-bit destination register.

SMADDL &lt;Xd&gt;, &lt;Wn&gt;, &lt;Wm&gt;, &lt;Xa&gt;</hint>
			<hint page="676" header="Signed Multiply-Negate Long" doc_id="armv8arm" token="SMNEGL">Multiplies two 32-bit register values, negates the product, 
and writes the result to the 64-bit destination register.

SMSUBL &lt;Xd&gt;, &lt;Wn&gt;, &lt;Wm&gt;, XZR</hint>
			<hint page="677" header="Signed Multiply-Subtract Long" doc_id="armv8arm" token="SMSUBL">Multiplies two 32-bit register values, subtracts the product from a 64-bit 
register value, and writes the result to the 64-bit destination register.

SMSUBL &lt;Xd&gt;, &lt;Wn&gt;, &lt;Wm&gt;, &lt;Xa&gt;</hint>
			<hint page="678" header="Signed Multiply High" doc_id="armv8arm" token="SMULH">Multiplies two 64-bit register values, and writes bits[127:64] 
of the 128-bit result to the 64-bit destination register.

SMULH &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;</hint>
			<hint page="678" header="Signed Multiply Long" doc_id="armv8arm" token="SMULL">Multiplies two 32-bit register values, and writes the 
result to the 64-bit destination register.

SMADDL &lt;Xd&gt;, &lt;Wn&gt;, &lt;Wm&gt;, XZR</hint>
			<hint page="680" header="Store-Release Register" doc_id="armv8arm" token="STLR">Stores a 32-bit word or a 64-bit doubleword to a 
memory location, from a register. 

STLR &lt;Xt&gt;, [&lt;Xn|SP&gt;{,#0}]</hint>
			<hint page="681" header="Store-Release Register Byte" doc_id="armv8arm" token="STLRB">Stores a byte from a 32-bit register to a memory location.

STLRB &lt;Wt&gt;, [&lt;Xn|SP&gt;{,#0}]</hint>
			<hint page="682" header="Store-Release Register Halfword" doc_id="armv8arm" token="STLRH">Stores a halfword from a 32-bit register to a memory location.

STLRH &lt;Wt&gt;, [&lt;Xn|SP&gt;{,#0}]</hint>
			<hint page="683" header="Store-Release Exclusive Pair of registers" doc_id="armv8arm" token="STLXP">Stores two 32-bit words or two 64-bit doublewords to a memory location 
if the PE has exclusive access to the memory address, from two registers, 
and returns a status value of 0 if the store was successful, or of 1 if 
no store was performed.

STLXP &lt;Ws&gt;, &lt;Xt1&gt;, &lt;Xt2&gt;, [&lt;Xn|SP&gt;{,#0}]</hint>
			<hint page="686" header="Store-Release Exclusive Register" doc_id="armv8arm" token="STLXR">Stores a 32-bit word or a 64-bit doubleword to memory if the PE has exclusive 
access to the memory address, from two registers, and returns a status value 
of 0 if the store was successful, or of 1 if no store was performed. 

STLXR &lt;Ws&gt;, &lt;Xt&gt;, [&lt;Xn|SP&gt;{,#0}]</hint>
			<hint page="688" header="Store-Release Exclusive Register Byte" doc_id="armv8arm" token="STLXRB">Stores a byte from a 32-bit register to memory if the PE has exclusive 
access to the memory address, and returns a status value of 0 if the 
store was successful, or of 1 if no store was performed.

STLXRB &lt;Ws&gt;, &lt;Wt&gt;, [&lt;Xn|SP&gt;{,#0}]</hint>
			<hint page="690" header="Store-Release Exclusive Register Halfword" doc_id="armv8arm" token="STLXRH">Stores a halfword from a 32-bit register to memory if the PE has exclusive access 
to the memory address, and returns a status value of 0 if the store was successful, 
or of 1 if no store was performed.

STLXRH &lt;Ws&gt;, &lt;Wt&gt;, [&lt;Xn|SP&gt;{,#0}]</hint>
			<hint page="692" header="Store Pair of Registers, with non-temporal hint" doc_id="armv8arm" token="STNP">Calculates an address from a base register value and an immediate offset, 
and stores two 32-bit words or two 64-bit doublewords to the calculated 
address, from two registers. 

STNP &lt;Xt1&gt;, &lt;Xt2&gt;, [&lt;Xn|SP&gt;{, #&lt;imm&gt;}]</hint>
			<hint page="694" header="Store Pair of Registers" doc_id="armv8arm" token="STP">Calculates an address from a base register value and an immediate offset, 
and stores two 32-bit words or two 64-bit doublewords to the calculated 
address, from two registers.

STP &lt;Xt1&gt;, &lt;Xt2&gt;, [&lt;Xn|SP&gt;], #&lt;imm&gt;</hint>
			<hint page="697" header="Store Register" doc_id="armv8arm" token="STR">1. Immediate
Stores a word or a doubleword from a register to memory. The address that 
is used for the store is calculated from a base register and an immediate 
offset.

Post-index:      STR &lt;Xt&gt;, [&lt;Xn|SP&gt;], #&lt;simm&gt;
Pre-index:       STR &lt;Xt&gt;, [&lt;Xn|SP&gt;, #&lt;simm&gt;]!
Unsigned offset: STR &lt;Xt&gt;, [&lt;Xn|SP&gt;{, #&lt;pimm&gt;}]

2. Register
Calculates an address from a base register value and an offset register 
value, and stores a 32-bit word or a 64-bit doubleword to the calculated 
address, from a register.

STR &lt;Xt&gt;, [&lt;Xn|SP&gt;, (&lt;Wm&gt;|&lt;Xm&gt;){, &lt;extend&gt; {&lt;amount&gt;}}]</hint>
			<hint page="702" header="Store Register Byte" doc_id="armv8arm" token="STRB">1. Immediate
Stores the least significant byte of a 32-bit register to memory. The 
address that is used for the store is calculated from a base register 
and an immediate offset. 

Post-index:      STRB &lt;Wt&gt;, [&lt;Xn|SP&gt;], #&lt;simm&gt;
Pre-index:       STRB &lt;Wt&gt;, [&lt;Xn|SP&gt;, #&lt;simm&gt;]!
Unsigned offset: STRB &lt;Wt&gt;, [&lt;Xn|SP&gt;{, #&lt;pimm&gt;}]

2. Register
Calculates an address from a base register value and an offset register 
value, and stores a byte from a 32-bit register to the calculated address. 

Extended register variant: 
  STRB &lt;Wt&gt;, [&lt;Xn|SP&gt;, (&lt;Wm&gt;|&lt;Xm&gt;), &lt;extend&gt; {&lt;amount&gt;}]
Shifted register variant:
  STRB &lt;Wt&gt;, [&lt;Xn|SP&gt;, &lt;Xm&gt;{, LSL &lt;amount&gt;}]</hint>
			<hint page="706" header="Store Register Halfword" doc_id="armv8arm" token="STRH">1. Immediate
Stores the least significant halfword of a 32-bit register to memory. The 
address that is used for the store is calculated from a base register and 
an immediate offset.

Post-index:      STRH &lt;Wt&gt;, [&lt;Xn|SP&gt;], #&lt;simm&gt;
Pre-index:       STRH &lt;Wt&gt;, [&lt;Xn|SP&gt;, #&lt;simm&gt;]!
Unsigned offset: STRH &lt;Wt&gt;, [&lt;Xn|SP&gt;{, #&lt;pimm&gt;}]

2. Register
Calculates an address from a base register value and an offset register 
value, and stores a halfword from a 32-bit register to the calculated 
address.

32-bit variant:
  STRH &lt;Wt&gt;, [&lt;Xn|SP&gt;, (&lt;Wm&gt;|&lt;Xm&gt;){, &lt;extend&gt; {&lt;amount&gt;}}]</hint>
			<hint page="710" header="Store Register (unprivileged)" doc_id="armv8arm" token="STTR">Stores a word or doubleword from a register to memory. The address that is 
used for the store is calculated from a base register and an immediate offset.

STTR &lt;Xt&gt;, [&lt;Xn|SP&gt;{, #&lt;simm&gt;}]</hint>
			<hint page="712" header="Store Register Byte (unprivileged)" doc_id="armv8arm" token="STTRB">Stores a byte from a 32-bit register to memory. The address that is used 
for the store is calculated from a base register and an immediate offset.

STTRB &lt;Wt&gt;, [&lt;Xn|SP&gt;{, #&lt;simm&gt;}]</hint>
			<hint page="713" header="Store Register Halfword (unprivileged)" doc_id="armv8arm" token="STTRH">Stores a halfword from a 32-bit register to memory. The address that is used 
for the store is calculated from a base register and an immediate offset.

STTRH &lt;Wt&gt;, [&lt;Xn|SP&gt;{, #&lt;simm&gt;}]</hint>
			<hint page="714" header="Store Register (unscaled)" doc_id="armv8arm" token="STUR">Calculates an address from a base register value and an immediate offset, 
and stores a 32-bit word or a 64-bit doubleword to the calculated address, 
from a register.

STUR &lt;Xt&gt;, [&lt;Xn|SP&gt;{, #&lt;simm&gt;}]</hint>
			<hint page="715" header="Store Register Byte (unscaled)" doc_id="armv8arm" token="STURB">Calculates an address from a base register value and an immediate offset, 
and stores a byte to the calculated address, from a 32-bit register.

STURB &lt;Wt&gt;, [&lt;Xn|SP&gt;{, #&lt;simm&gt;}]</hint>
			<hint page="716" header="Store Register Halfword (unscaled)" doc_id="armv8arm" token="STURH">Calculates an address from a base register value and an immediate offset, 
and stores a halfword to the calculated address, from a 32-bit register.

STURH &lt;Wt&gt;, [&lt;Xn|SP&gt;{, #&lt;simm&gt;}]</hint>
			<hint page="717" header="Store Exclusive Pair of registers" doc_id="armv8arm" token="STXP">Stores two 32-bit words or two 64-bit doublewords from two registers to a 
memory location if the PE has exclusive access to the memory address, and 
returns a status value of 0 if the store was successful, or of 1 if no 
store was performed.

STXP &lt;Ws&gt;, &lt;Xt1&gt;, &lt;Xt2&gt;, [&lt;Xn|SP&gt;{,#0}]</hint>
			<hint page="720" header="Store Exclusive Register" doc_id="armv8arm" token="STXR">Stores a 32-bit word or a 64-bit doubleword from a register to memory 
if the PE has exclusive access to the memory address, and returns a 
status value of 0 if the store was successful, or of 1 if no store 
was performed.

STXR &lt;Ws&gt;, &lt;Xt&gt;, [&lt;Xn|SP&gt;{,#0}]</hint>
			<hint page="722" header="Store Exclusive Register Byte" doc_id="armv8arm" token="STXRB">Stores a byte from a register to memory if the PE has exclusive access 
to the memory address, and returns a status value of 0 if the store was 
successful, or of 1 if no store was performed.

STXRB &lt;Ws&gt;, &lt;Wt&gt;, [&lt;Xn|SP&gt;{,#0}]</hint>
			<hint page="724" header="Store Exclusive Register Halfword" doc_id="armv8arm" token="STXRH">Stores a halfword from a register to memory if the PE has exclusive access 
to the memory address, and returns a status value of 0 if the store was 
successful, or of 1 if no store was performed.

STXRH &lt;Ws&gt;, &lt;Wt&gt;, [&lt;Xn|SP&gt;{,#0}]</hint>
			<hint page="726" header="Subtract" doc_id="armv8arm" token="SUB">1. Extended register
Subtracts a sign or zero-extended register value, followed by an 
optional left shift amount, from a register value, and writes the 
result to the destination register. The argument that is extended 
from the &lt;Rm&gt; register can be a byte, halfword, word, or doubleword.

SUB &lt;Xd|SP&gt;, &lt;Xn|SP&gt;, &lt;R&gt;&lt;m&gt;{, &lt;extend&gt; {#&lt;amount&gt;}}

2. Immediate
Subtracts an optionally-shifted immediate value from a register 
value, and writes the result to the destination register.

SUB &lt;Xd|SP&gt;, &lt;Xn|SP&gt;, #&lt;imm&gt;{, &lt;shift&gt;}

3. Shifted register
Subtracts an optionally-shifted register value from a register value, 
and writes the result to the destination register.

SUB &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;{, &lt;shift&gt; #&lt;amount&gt;}</hint>
			<hint page="732" header="Subtract (setting flags)" doc_id="armv8arm" token="SUBS">1. Extended register
Subtracts a sign or zero-extended register value, followed by an optional 
left shift amount, from a register value, and writes the result to the 
destination register. The argument that is extended from the &lt;Rm&gt; register 
can be a byte, halfword, word, or doubleword. It updates the condition 
flags based on the result.

SUBS &lt;Xd&gt;, &lt;Xn|SP&gt;, &lt;R&gt;&lt;m&gt;{, &lt;extend&gt; {#&lt;amount&gt;}}

2. Immediate
Subtracts an optionally-shifted immediate value from a register value, 
and writes the result to the destination register. It updates the 
condition flags based on the result.

SUBS &lt;Xd&gt;, &lt;Xn|SP&gt;, #&lt;imm&gt;{, &lt;shift&gt;}

3. Shifted register
Subtracts an optionally-shifted register value from a register value, 
and writes the result to the destination register. It updates the 
condition flags based on the result.


SUBS &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;{, &lt;shift&gt; #&lt;amount&gt;}</hint>
			<hint page="739" header="Signed Extend Byte" doc_id="armv8arm" token="SXTB">Extracts an 8-bit value from a register, sign-extends it to the size 
of the register, and writes the result to the destination register.

SXTB &lt;Xd&gt;, &lt;Wn&gt;

  is equivalent to

SBFM &lt;Xd&gt;, &lt;Xn&gt;, #0, #7</hint>
			<hint page="740" header="Sign Extend Halfword" doc_id="armv8arm" token="SXTH">Extracts a 16-bit value, sign-extends it to the size of the register, 
and writes the result to the destination register.

SXTH &lt;Xd&gt;, &lt;Wn&gt;

  is equivalent to

SBFM &lt;Xd&gt;, &lt;Xn&gt;, #0, #15</hint>
			<hint page="741" header="Sign Extend Word" doc_id="armv8arm" token="SXTW">Sign-extends a word to the size of the register, and 
writes the result to the destination register.

SBFM &lt;Xd&gt;, &lt;Xn&gt;, #0, #31</hint>
			<hint page="744" header="Test bit and Branch if Nonzero" doc_id="armv8arm" token="TBNZ">Compares the value of a bit in a general-purpose register with zero, 
and conditionally branches to a label at a PC-relative offset if the 
comparison is not equal. It provides a hint that this is not a subroutine 
call or return. This instruction does not affect condition flags.

TBNZ &lt;R&gt;&lt;t&gt;, #&lt;imm&gt;, &lt;label&gt;</hint>
			<hint page="745" header="Test bit and Branch if Zero" doc_id="armv8arm" token="TBZ">Compares the value of a test bit with zero, and conditionally branches 
to a label at a PC-relative offset if the comparison is equal. 
It provides a hint that this is not a subroutine call or return. 
This instruction does not affect condition flags.

TBZ &lt;R&gt;&lt;t&gt;, #&lt;imm&gt;, &lt;label&gt;</hint>
			<hint page="748" header="Test bits" doc_id="armv8arm" token="TST">1. Immediate
Setting the condition flags and discarding the result : Rn AND imm

TST &lt;Xn&gt;, #&lt;imm&gt;

  is equivalent to

ANDS XZR, &lt;Xn&gt;, #&lt;imm&gt;

2. Shifted register
Performs a bitwise AND operation on a register value and an 
optionally-shifted register value. It updates the condition 
flags based on the result, and discards the result.

TST &lt;Xn&gt;, &lt;Xm&gt;{, &lt;shift&gt; #&lt;amount&gt;}

  is equivalent to

ANDS XZR, &lt;Xn&gt;, &lt;Xm&gt;{, &lt;shift&gt; #&lt;amount&gt;}</hint>
			<hint page="751" header="Unsigned Bitfield Insert in Zero" doc_id="armv8arm" token="UBFIZ">Zeroes the destination register and copies any number of 
contiguous bits from a source register into any position
in the destination register.

UBFIZ &lt;Xd&gt;, &lt;Xn&gt;, #&lt;lsb&gt;, #&lt;width&gt;

  is equivalent to

UBFM &lt;Xd&gt;, &lt;Xn&gt;, #(-&lt;lsb&gt; MOD 64), #(&lt;width&gt;-1)</hint>
			<hint page="752" header="Unsigned Bitfield Move" doc_id="armv8arm" token="UBFM">Copies any number of low-order bits from a source register 
into the same number of adjacent bits at any position in the 
destination register, with zeros in the upper and lower bits.

UBFM &lt;Xd&gt;, &lt;Xn&gt;, #&lt;immr&gt;, #&lt;imms&gt;</hint>
			<hint page="754" header="Unsigned Bitfield Extract" doc_id="armv8arm" token="UBFX">Extracts any number of adjacent bits at any position from a register, 
zero-extends them to the size of the register, and writes the result 
to the destination register.

UBFX &lt;Xd&gt;, &lt;Xn&gt;, #&lt;lsb&gt;, #&lt;width&gt;

  is equivalent to

UBFM &lt;Xd&gt;, &lt;Xn&gt;, #&lt;lsb&gt;, #(&lt;lsb&gt;+&lt;width&gt;-1)</hint>
			<hint page="755" header="Unsigned Divide" doc_id="armv8arm" token="UDIV">Divides an unsigned integer register value by another unsigned 
integer register value, and writes the result to the destination 
register. The condition flags are not affected.

UDIV &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;</hint>
			<hint page="756" header="Unsigned Multiply-Add Long" doc_id="armv8arm" token="UMADDL">Multiplies two 32-bit register values, adds a 64-bit register value, 
and writes the result to the 64-bit destination register.

UMADDL &lt;Xd&gt;, &lt;Wn&gt;, &lt;Wm&gt;, &lt;Xa&gt;</hint>
			<hint page="757" header="Unsigned Multiply-Negate Long" doc_id="armv8arm" token="UMNEGL">Multiplies two 32-bit register values, negates the product, 
and writes the result to the 64-bit destination register.

UMSUBL &lt;Xd&gt;, &lt;Wn&gt;, &lt;Wm&gt;, XZR</hint>
			<hint page="758" header="Unsigned Multiply-Subtract Long" doc_id="armv8arm" token="UMSUBL">Multiplies two 32-bit register values, subtracts the product from 
a 64-bit register value, and writes the result to the 64-bit 
destination register.

UMSUBL &lt;Xd&gt;, &lt;Wn&gt;, &lt;Wm&gt;, &lt;Xa&gt;</hint>
			<hint page="759" header="Unsigned Multiply High" doc_id="armv8arm" token="UMULH">Multiplies two 64-bit register values, and writes bits[127:64] 
of the 128-bit result to the 64-bit destination register.

UMULH &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;</hint>
			<hint page="760" header="Unsigned Multiply Long" doc_id="armv8arm" token="UMULL">Multiplies two 32-bit register values, and writes the 
result to the 64-bit destination register.

UMADDL &lt;Xd&gt;, &lt;Wn&gt;, &lt;Wm&gt;, XZR</hint>
			<hint page="761" header="Unsigned Extend Byte" doc_id="armv8arm" token="UXTB">Extracts an 8-bit value from a register, zero-extends it to the size 
of the register, and writes the result to the destination register.

32-bit variant: 

UXTB &lt;Wd&gt;, &lt;Wn&gt;

  is equivalent to

UBFM &lt;Wd&gt;, &lt;Wn&gt;, #0, #7</hint>
			<hint page="762" header="Unsigned Extend Halfword" doc_id="armv8arm" token="UXTH">Extracts a 16-bit value from a register, zero-extends it to the size 
of the register, and writes the result to the destination register.

32-bit variant:

UXTH &lt;Wd&gt;, &lt;Wn&gt;

  is equivalent to

UBFM &lt;Wd&gt;, &lt;Wn&gt;, #0, #15</hint>
		</group>
		<group type="ins" name="A64 Exception generation/return instructions">
			<hint page="475" header="Breakpoint Instruction" doc_id="armv8arm" token="BRK">Generates a Breakpoint Instruction exception.

The PE records the exception in ESR_ELx, using the EC value 0x3c, 
and captures the value of the immediate argument in ESR_ELx.ISS.

BRK #&lt;imm&gt;</hint>
			<hint page="529" header="Halt Instruction" doc_id="armv8arm" token="HLT">Halt instruction generates a Halt Instruction debug event.

HLT #&lt;imm&gt;</hint>
			<hint page="530" header="Generate exception targeting EL2" doc_id="armv8arm" token="HVC">Hypervisor Call causes an exception to EL2. 
Non-secure software executing at EL1 can use this instruction 
to call the hypervisor to request a service.

HVC #&lt;imm&gt;</hint>
			<hint page="675" header="Secure Monitor Call" doc_id="armv8arm" token="SMC">Causes an exception to EL3.
SMC is available only for software executing at 
EL1 or higher. It is UNDEFINED in EL0.

SMC #&lt;imm&gt;</hint>
			<hint page="738" header="Supervisor Call" doc_id="armv8arm" token="SVC">Causes an exception to be taken to EL1.
On executing an SVC instruction, the PE records the exception as a 
Supervisor Call exception in ESR_ELx, using the EC value 0x15, and 
the value of the immediate argument.

SVC #&lt;imm&gt;</hint>
			<hint page="525" header="Exception Return" doc_id="armv8arm" token="ERET">Exception Return using the ELR and SPSR for the current Exception level. 
When executed, the PE restores PSTATE from the SPSR, and branches to 
the address held in the ELR.

ERET</hint>
			<hint page="512" header="Debug switch to EL1" doc_id="armv8arm" token="DCPS1">Debug Change PE State to EL1.

DCPS1 {#&lt;imm&gt;}</hint>
			<hint page="513" header="Debug switch to EL2" doc_id="armv8arm" token="DCPS2">Debug Change PE State to EL2.

DCPS2 {#&lt;imm&gt;}</hint>
			<hint page="514" header="Debug switch to EL3" doc_id="armv8arm" token="DCPS3">Debug Change PE State to EL3.

DCPS3 {#&lt;imm&gt;}</hint>
			<hint page="517" header="Debug restore PE state" doc_id="armv8arm" token="DRPS">Debug restore process state.

DRPS</hint>
		</group>
		<group type="ins" name="A64 System instructions">
			<hint page="622" header="Move System Register" doc_id="armv8arm" token="MRS">Allows the PE to read an AArch64 System register into a 
general-purpose register.

MRS &lt;Xt&gt;, (&lt;systemreg&gt;|S&lt;op0&gt;_&lt;op1&gt;_&lt;Cn&gt;_&lt;Cm&gt;_&lt;op2&gt;)</hint>
			<hint page="623" header="Move to Special Register" doc_id="armv8arm" token="MSR">1. Immediate
Move immediate value to Special Register moves an immediate 
value to selected bits of the PSTATE.

MSR &lt;pstatefield&gt;, #&lt;imm&gt;

2. Register
Move general-purpose register to System Register allows 
the PE to write an AArch64 System register from a 
general-purpose register.

MSR (&lt;systemreg&gt;|S&lt;op0&gt;_&lt;op1&gt;_&lt;Cn&gt;_&lt;Cm&gt;_&lt;op2&gt;), &lt;Xt&gt;</hint>
			<hint page="742" header="System instruction" doc_id="armv8arm" token="SYS">This instruction is used by the aliases AT, DC, IC, and TLBI.

SYS #&lt;op1&gt;, &lt;Cn&gt;, &lt;Cm&gt;, #&lt;op2&gt;{, &lt;Xt&gt;}</hint>
			<hint page="743" header="System instruction with result" doc_id="armv8arm" token="SYSL">SYSL &lt;Xt&gt;, #&lt;op1&gt;, &lt;Cn&gt;, &lt;Cm&gt;, #&lt;op2&gt;</hint>
			<hint page="531" header="Instruction cache operation" doc_id="armv8arm" token="IC">This instruction is an alias of the SYS instruction.

IC &lt;ic_op&gt;{, &lt;Xt&gt;}

  is equivalent to

SYS #&lt;op1&gt;, C7, &lt;Cm&gt;, #&lt;op2&gt;{, &lt;Xt&gt;}</hint>
			<hint page="511" header="Data Cache operation" doc_id="armv8arm" token="DC">This instruction is an alias of the SYS instruction.

DC &lt;dc_op&gt;, &lt;Xt&gt;

  is equivalent to

SYS #&lt;op1&gt;, C7, &lt;Cm&gt;, #&lt;op2&gt;, &lt;Xt&gt;</hint>
			<hint page="461" header="Address translation operation" doc_id="armv8arm" token="AT">This instruction is an alias of the SYS instruction.

AT &lt;at_op&gt;, &lt;Xt&gt;

  is equivalent to

SYS #&lt;op1&gt;, C7, &lt;Cm&gt;, #&lt;op2&gt;, &lt;Xt&gt;</hint>
			<hint page="746" header="TLB Invalidate operation" doc_id="armv8arm" token="TLBI">This instruction is an alias of the SYS instruction.

TLBI &lt;tlbi_op&gt;{, &lt;Xt&gt;}

  is equivalent to

SYS #&lt;op1&gt;, C8, &lt;Cm&gt;, #&lt;op2&gt;{, &lt;Xt&gt;}</hint>
		</group>
		<group type="ins" name="A64 Hint instructions">
			<hint page="637" header="No Operation" doc_id="armv8arm" token="NOP">Does nothing, other than advance the value of the program counter by 4. 
This instruction can be used for instruction alignment purposes.

NOP</hint>
			<hint page="765" header="Yield hint" doc_id="armv8arm" token="YIELD">Software with a multithreading capability can use a YIELD instruction to 
indicate to the PE that it is performing a task, for example a spin-lock, 
that could be swapped out to improve overall system performance. The PE 
can use this hint to suspend and resume multiple software threads if it 
supports the capability.

YIELD</hint>
			<hint page="763" header="Wait for event" doc_id="armv8arm" token="WFE">Hint instruction that permits the PE to enter a low-power 
state until one of a number of events occurs, including 
events signaled by executing the SEV instruction on any 
PE in the multiprocessor system.

WFE</hint>
			<hint page="764" header="Wait for interrupt" doc_id="armv8arm" token="WFI">Hint instruction that permits the PE to enter a low-power 
state until one of a number of asynchronous event occurs.

WFI</hint>
			<hint page="672" header="Send Event" doc_id="armv8arm" token="SEV">Hint instruction. It causes an event to be signaled to 
all PEs in the multiprocessor system.

SEV</hint>
			<hint page="673" header="Send Event Local" doc_id="armv8arm" token="SEVL">Hint instruction. It causes an event to be signaled locally without 
the requirement to affect other PEs in the multiprocessor system. 
It can prime a wait-loop which starts with a WFE instruction.

SEVL</hint>
			<hint page="528" header="Unallocated hint" doc_id="armv8arm" token="HINT">Hint instruction is for the instruction set space that 
is reserved for architectural hint instructions.

HINT #&lt;imm&gt;</hint>
		</group>
		<group type="ins" name="A64 Barriers and CLREX instructions">
			<hint page="484" header="Clear Exclusive" doc_id="armv8arm" token="CLREX">Clears the local monitor of the executing PE.

CLREX {#&lt;imm&gt;}</hint>
			<hint page="518" header="Data Synchronization Barrier" doc_id="armv8arm" token="DSB">Data Synchronization Barrier is a memory barrier that 
ensures the completion of memory accesses.

DSB &lt;option&gt;|#&lt;imm&gt;</hint>
			<hint page="515" header="Data Memory Barrier" doc_id="armv8arm" token="DMB">Data Memory Barrier is a memory barrier that ensures 
the ordering of observations of memory accesses.

DMB &lt;option&gt;|#&lt;imm&gt;</hint>
			<hint page="532" header="Instruction Synchronization Barrier" doc_id="armv8arm" token="ISB">Instruction Synchronization Barrier flushes the pipeline in the PE, 
so that all instructions following the ISB are fetched from cache 
or memory, after the instruction has been completed. It ensures that 
the effects of context changing operations executed before the ISB 
instruction are visible to the instructions fetched after the ISB. 
Context changing operations include changing the ASID, TLB 
maintenance instructions, and all changes to the System registers. 
In addition, any branches that appear in program order after the 
ISB instruction are written into the branch prediction logic with 
the context that is visible after the ISB instruction. This is 
needed to ensure correct execution of the instruction stream.

ISB {&lt;option&gt;|#&lt;imm&gt;}</hint>
		</group>
		<group type="ins" name="A64 Floating Point instructions">
			<hint page="828" header="Floating-point Absolute Difference (vector)" doc_id="armv8arm" token="FABD">This instruction subtracts the floating-point values in the elements 
of the second source SIMD&amp;FP register, from the corresponding 
floating-point values in the elements of the first source SIMD&amp;FP 
register, places the absolute value of each result in a vector, 
and writes the vector to the destination SIMD&amp;FP register.

FABD &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;</hint>
			<hint page="830" header="Floating-point Absolute value" doc_id="armv8arm" token="FABS">1. Vector
This instruction calculates the absolute value of each vector element 
in the source SIMD&amp;FP register, writes the result to a vector, and 
writes the vector to the destination SIMD&amp;FP register.

FABS &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;

2. Scalar
This instruction calculates the absolute value in the SIMD&amp;FP source 
register and writes the result to the SIMD&amp;FP destination register.

Single-precision variant
  FABS &lt;Sd&gt;, &lt;Sn&gt;
Double-precision variant
  FABS &lt;Dd&gt;, &lt;Dn&gt;</hint>
			<hint page="832" header="Floating-point Absolute Compare Greater than or Equal (vector)" doc_id="armv8arm" token="FACGE">This instruction compares the absolute value of each floating-point 
value in the first source SIMD&amp;FP register with the absolute value 
of the corresponding floating-point value in the second source SIMD&amp;FP 
register and if the first value is greater than or equal to the second 
value sets every bit of the corresponding vector element in the 
destination SIMD&amp;FP register to one, otherwise sets every bit of the 
corresponding vector element in the destination SIMD&amp;FP register to zero.

FACGE &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;</hint>
			<hint page="834" header="Floating-point Absolute Compare Greater than (vector)" doc_id="armv8arm" token="FACGT">This instruction compares the absolute value of each vector element 
in the first source SIMD&amp;FP register with the absolute value of the 
corresponding vector element in the second source SIMD&amp;FP register 
and if the first value is greater than the second value sets every 
bit of the corresponding vector element in the destination SIMD&amp;FP 
register to one, otherwise sets every bit of the corresponding 
vector element in the destination SIMD&amp;FP register to zero.

FACGT &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;</hint>
			<hint page="836" header="Floating-point Add" doc_id="armv8arm" token="FADD">1. Vector
This instruction adds corresponding vector elements in the two source 
SIMD&amp;FP registers, writes the result into a vector, and writes the vector 
to the destination SIMD&amp;FP register. All the values in this instruction 
are floating-point values.

FADD &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;

2. Scalar
This instruction adds the floating-point values of the two source SIMD&amp;FP 
registers, and writes the result to the destination SIMD&amp;FP register.

Single-precision variant
  FADD &lt;Sd&gt;, &lt;Sn&gt;, &lt;Sm&gt;
Double-precision variant
  FADD &lt;Dd&gt;, &lt;Dn&gt;, &lt;Dm&gt;</hint>
			<hint page="840" header="Floating-point Add Pair" doc_id="armv8arm" token="FADDP">1. Vector
This instruction creates a vector by concatenating the vector elements of the 
first source SIMD&amp;FP register after the vector elements of the second source 
SIMD&amp;FP register, reads each pair of adjacent vector elements from the 
concatenated vector, adds each pair of values together, places the result 
into a vector, and writes the vector to the destination SIMD&amp;FP register. 
All the values in this instruction are floating-point values.

FADDP &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;

2. Scalar
This instruction adds two floating-point vector elements in the source SIMD&amp;FP 
register and writes the scalar result into the destination SIMD&amp;FP register.

FADDP &lt;V&gt;&lt;d&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="843" header="Floating-point Conditional quiet Compare (scalar)" doc_id="armv8arm" token="FCCMP">This instruction compares the two SIMD&amp;FP source register values and 
writes the result to the PSTATE.{N, Z, C, V} flags. If the condition 
does not pass then the PSTATE.{N, Z, C, V} flags are set to the flag 
bit specifier.

Single-precision variant
  FCCMP &lt;Sn&gt;, &lt;Sm&gt;, #&lt;nzcv&gt;, &lt;cond&gt;
Double-precision variant
  FCCMP &lt;Dn&gt;, &lt;Dm&gt;, #&lt;nzcv&gt;, &lt;cond&gt;</hint>
			<hint page="845" header="Floating-point Conditional signaling Compare (scalar)" doc_id="armv8arm" token="FCCMPE">This instruction compares the two SIMD&amp;FP source register values and 
writes the result to the PSTATE.{N, Z, C, V} flags. If the condition 
does not pass then the PSTATE.{N, Z, C, V} flags are set to the flag 
bit specifier.

Single-precision variant
  FCCMPE &lt;Sn&gt;, &lt;Sm&gt;, #&lt;nzcv&gt;, &lt;cond&gt;
Double-precision variant
  FCCMPE &lt;Dn&gt;, &lt;Dm&gt;, #&lt;nzcv&gt;, &lt;cond&gt;</hint>
			<hint page="847" header="Floating-point Compare Equal (vector)" doc_id="armv8arm" token="FCMEQ">1. Register
This instruction compares each floating-point value from the first source 
SIMD&amp;FP register, with the corresponding floating-point value from the 
second source SIMD&amp;FP register, and if the comparison is equal sets every 
bit of the corresponding vector element in the destination SIMD&amp;FP register 
to one, otherwise sets every bit of the corresponding vector element in the 
destination SIMD&amp;FP register to zero.

FCMEQ &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;

2. Zero
This instruction reads each floating-point value in the source SIMD&amp;FP 
register and if the value is equal to zero sets every bit of the 
corresponding vector element in the destination SIMD&amp;FP register to one, 
otherwise sets every bit of the corresponding vector element in the 
destination SIMD&amp;FP register to zero.

FCMEQ &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #0.0</hint>
			<hint page="851" header="Floating-point Compare Greater than or Equal (vector)" doc_id="armv8arm" token="FCMGE">1. Register
This instruction reads each floating-point value in the first source 
SIMD&amp;FP register and if the value is greater than or equal to the 
corresponding floating-point value in the second source SIMD&amp;FP 
register sets every bit of the corresponding vector element in the 
destination SIMD&amp;FP register to one, otherwise sets every bit of the 
corresponding vector element in the destination SIMD&amp;FP register to zero.

FCMGE &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;

2. Zero
This instruction reads each floating-point value in the source SIMD&amp;FP 
register and if the value is greater than or equal to zero sets every 
bit of the corresponding vector element in the destination SIMD&amp;FP 
register to one, otherwise sets every bit of the corresponding vector 
element in the destination SIMD&amp;FP register to zero.

FCMGE &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #0.0</hint>
			<hint page="855" header="Floating-point Compare Greater than (vector)" doc_id="armv8arm" token="FCMGT">1. Register
This instruction reads each floating-point value in the first source 
SIMD&amp;FP register and if the value is greater than the corresponding 
floating-point value in the second source SIMD&amp;FP register sets every 
bit of the corresponding vector element in the destination SIMD&amp;FP 
register to one, otherwise sets every bit of the corresponding vector 
element in the destination SIMD&amp;FP register to zero.

FCMGT &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;

2. Zero
This instruction reads each floating-point value in the source SIMD&amp;FP 
register and if the value is greater than zero sets every bit of the 
corresponding vector element in the destination SIMD&amp;FP register to one,
otherwise sets every bit of the corresponding vector element in the 
destination SIMD&amp;FP register to zero.

FCMGT &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #0.0</hint>
			<hint page="859" header="Floating-point Compare Less than or Equal to zero (vector)" doc_id="armv8arm" token="FCMLE">This instruction reads each floating-point value in the source 
SIMD&amp;FP register and if the value is less than or equal to zero 
sets every bit of the corresponding vector element in the 
destination SIMD&amp;FP register to one, otherwise sets every bit 
of the corresponding vector element in the destination SIMD&amp;FP 
register to zero.

FCMLE &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #0.0</hint>
			<hint page="861" header="Floating-point Compare Less than zero (vector)" doc_id="armv8arm" token="FCMLT">This instruction reads each floating-point value in the source 
SIMD&amp;FP register and if the value is less than zero sets every 
bit of the corresponding vector element in the destination SIMD&amp;FP 
register to one, otherwise sets every bit of the corresponding 
vector element in the destination SIMD&amp;FP register to zero.

FCMLT &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #0.0</hint>
			<hint page="863" header="Floating-point quiet Compare (scalar)" doc_id="armv8arm" token="FCMP">This instruction compares the two SIMD&amp;FP source register values, 
or the first SIMD&amp;FP source register value and zero. It writes
the result to the PSTATE.{N, Z, C, V} flags.

Single-precision variant
  FCMP &lt;Sn&gt;, &lt;Sm&gt;
Single-precision, zero variant
  FCMP &lt;Sn&gt;, #0.0
Double-precision variant
  FCMP &lt;Dn&gt;, &lt;Dm&gt;
Double-precision, zero variant
  FCMP &lt;Dn&gt;, #0.0</hint>
			<hint page="865" header="Floating-point signaling Compare (scalar)" doc_id="armv8arm" token="FCMPE">This instruction compares the two SIMD&amp;FP source register values, 
or the first SIMD&amp;FP source register value and zero. It writes 
the result to the PSTATE.{N, Z, C, V} flags.

Single-precision variant
  FCMPE &lt;Sn&gt;, &lt;Sm&gt;
Single-precision, zero variant
  FCMPE &lt;Sn&gt;, #0.0
Double-precision variant
  FCMPE &lt;Dn&gt;, &lt;Dm&gt;
Double-precision, zero variant
  FCMPE &lt;Dn&gt;, #0.0</hint>
			<hint page="867" header="Floating-point Conditional Select (scalar)" doc_id="armv8arm" token="FCSEL">This instruction allows the SIMD&amp;FP destination register to take the 
value from either one or the other of two SIMD&amp;FP source registers. 
If the condition passes, the first SIMD&amp;FP source register value is 
taken, otherwise the second SIMD&amp;FP source register value is taken.

Single-precision variant
  FCSEL &lt;Sd&gt;, &lt;Sn&gt;, &lt;Sm&gt;, &lt;cond&gt;
Double-precision variant
  FCSEL &lt;Dd&gt;, &lt;Dn&gt;, &lt;Dm&gt;, &lt;cond&gt;</hint>
			<hint page="869" header="Floating-point Convert precision (scalar)" doc_id="armv8arm" token="FCVT">This instruction converts the floating-point value in the SIMD&amp;FP 
source register to the precision for the destination register data 
type using the rounding mode that is determined by the FPCR and 
writes the result to the SIMD&amp;FP destination register.

Half-precision to single-precision variant
  FCVT &lt;Sd&gt;, &lt;Hn&gt;
Half-precision to double-precision variant
  FCVT &lt;Dd&gt;, &lt;Hn&gt;
Single-precision to half-precision variant
  FCVT &lt;Hd&gt;, &lt;Sn&gt;
Single-precision to double-precision variant
  FCVT &lt;Dd&gt;, &lt;Sn&gt;
Double-precision to half-precision variant
  FCVT &lt;Hd&gt;, &lt;Dn&gt;
Double-precision to single-precision variant
  FCVT &lt;Sd&gt;, &lt;Dn&gt;</hint>
			<hint page="871" header="Floating-point Convert to Signed integer, rounding to nearest with ties to Away" doc_id="armv8arm" token="FCVTAS">1. Vector
This instruction converts each element in a vector from a 
floating-point value to a signed integer value using the 
Round to Nearest with Ties to Away rounding mode and writes 
the result to the SIMD&amp;FP destination register.

FCVTAS &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;

2. Scalar
This instruction converts the floating-point value in the 
SIMD&amp;FP source register to a 32-bit or 64-bit signed integer 
using the Round to Nearest with Ties to Away rounding mode, 
and writes the result to the general-purpose destination 
register.

Single-precision to 32-bit variant
  FCVTAS &lt;Wd&gt;, &lt;Sn&gt;
Single-precision to 64-bit variant
  FCVTAS &lt;Xd&gt;, &lt;Sn&gt;
Double-precision to 32-bit variant
  FCVTAS &lt;Wd&gt;, &lt;Dn&gt;
Double-precision to 64-bit variant
  FCVTAS &lt;Xd&gt;, &lt;Dn&gt;</hint>
			<hint page="875" header="Floating-point Convert to Unsigned integer, rounding to nearest with ties to Away" doc_id="armv8arm" token="FCVTAU">1. Vector
This instruction converts each element in a vector from a 
floating-point value to an unsigned integer value using the 
Round to Nearest with Ties to Away rounding mode and writes 
the result to the SIMD&amp;FP destination register.

FCVTAU &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;

2. Scalar
This instruction converts the floating-point value in the 
SIMD&amp;FP source register to a 32-bit or 64-bit unsigned integer 
using the Round to Nearest with Ties to Away rounding mode, 
and writes the result to the general-purpose destination register.

Single-precision to 32-bit variant
  FCVTAU &lt;Wd&gt;, &lt;Sn&gt;
Single-precision to 64-bit variant
  FCVTAU &lt;Xd&gt;, &lt;Sn&gt;
Double-precision to 32-bit variant
  FCVTAU &lt;Wd&gt;, &lt;Dn&gt;
Double-precision to 64-bit variant
  FCVTAU &lt;Xd&gt;, &lt;Dn&gt;</hint>
			<hint page="879" header="Floating-point Convert to higher precision Long (vector)" doc_id="armv8arm" token="FCVTL">This instruction reads each element in a vector in the SIMD&amp;FP 
source register, converts each value to double the precision of 
the source element using the rounding mode that is determined 
by the FPCR, and writes each result to the equivalent element 
of the vector in the SIMD&amp;FP destination register.
Where the operation lengthens a 64-bit vector to a 128-bit vector, 
the FCVTL2 variant operates on the elements in the top 64 bits 
of the source register.

FCVTL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;</hint>
			<hint page="879" header="Floating-point Convert to higher precision Long (vector)" doc_id="armv8arm" token="FCVTL2">This instruction reads each element in a vector in the SIMD&amp;FP 
source register, converts each value to double the precision of 
the source element using the rounding mode that is determined 
by the FPCR, and writes each result to the equivalent element 
of the vector in the SIMD&amp;FP destination register.
Where the operation lengthens a 64-bit vector to a 128-bit vector, 
the FCVTL2 variant operates on the elements in the top 64 bits 
of the source register.

FCVTL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;</hint>
			<hint page="881" header="Floating-point Convert to Signed integer, rounding toward Minus infinity" doc_id="armv8arm" token="FCVTMS">1. Vector
This instruction converts a scalar or each element in a vector from a 
floating-point value to a signed integer value using the Round towards 
Minus Infinity rounding mode, and writes the result to the SIMD&amp;FP 
destination register.

FCVTMS &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;

2. Scalar
This instruction converts the floating-point value in the SIMD&amp;FP 
source register to a 32-bit or 64-bit signed integer using the Round 
towards Minus Infinity rounding mode, and writes the result to the 
general-purpose destination register.

Single-precision to 32-bit variant
  FCVTMS &lt;Wd&gt;, &lt;Sn&gt;
Single-precision to 64-bit variant
  FCVTMS &lt;Xd&gt;, &lt;Sn&gt;
Double-precision to 32-bit variant
  FCVTMS &lt;Wd&gt;, &lt;Dn&gt;
Double-precision to 64-bit variant
  FCVTMS &lt;Xd&gt;, &lt;Dn&gt;</hint>
			<hint page="885" header="Floating-point Convert to Unsigned integer, rounding toward Minus infinity" doc_id="armv8arm" token="FCVTMU">1. Vector
This instruction converts a scalar or each element in a vector from a 
floating-point value to an unsigned integer value using the Round 
towards Minus Infinity rounding mode, and writes the result to the 
SIMD&amp;FP destination register.

FCVTMU &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;

2. Scalar
This instruction converts the floating-point value in the SIMD&amp;FP 
source register to a 32-bit or 64-bit unsigned integer using the 
Round towards Minus Infinity rounding mode, and writes the result 
to the general-purpose destination register.

Single-precision to 32-bit variant
  FCVTMU &lt;Wd&gt;, &lt;Sn&gt;
Single-precision to 64-bit variant
  FCVTMU &lt;Xd&gt;, &lt;Sn&gt;
Double-precision to 32-bit variant
  FCVTMU &lt;Wd&gt;, &lt;Dn&gt;
Double-precision to 64-bit variant
  FCVTMU &lt;Xd&gt;, &lt;Dn&gt;</hint>
			<hint page="889" header="Floating-point Convert to lower precision Narrow (vector)" doc_id="armv8arm" token="FCVTN">This instruction reads each vector element in the SIMD&amp;FP source register, 
converts each result to half the precision of the source element, writes 
the final result to a vector, and writes the vector to the lower or upper 
half of the destination SIMD&amp;FP register. The destination vector elements 
are half as long as the source vector elements. The rounding mode is 
determined by the FPCR.
The FCVTN instruction writes the vector to the lower half of the destination
register and clears the upper half, while the FCVTN2 instruction writes 
the vector to the upper half of the destination register without affecting 
the other bits of the register.

FCVTN &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;</hint>
			<hint page="889" header="Floating-point Convert to lower precision Narrow (vector)" doc_id="armv8arm" token="FCVTN2">This instruction reads each vector element in the SIMD&amp;FP source register, 
converts each result to half the precision of the source element, writes 
the final result to a vector, and writes the vector to the lower or upper 
half of the destination SIMD&amp;FP register. The destination vector elements 
are half as long as the source vector elements. The rounding mode is 
determined by the FPCR.
The FCVTN instruction writes the vector to the lower half of the destination
register and clears the upper half, while the FCVTN2 instruction writes 
the vector to the upper half of the destination register without affecting 
the other bits of the register.

FCVTN2 &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;</hint>
			<hint page="891" header="Floating-point Convert to Signed integer, rounding to nearest with ties to even" doc_id="armv8arm" token="FCVTNS">1. Vector
This instruction converts a scalar or each element in a vector from a 
floating-point value to a signed integer value using the Round to 
Nearest rounding mode, and writes the result to the SIMD&amp;FP destination 
register.

FCVTNS &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;

2. Scalar
This instruction converts the floating-point value in the SIMD&amp;FP source 
register to a 32-bit or 64-bit signed integer using the Round to Nearest 
rounding mode, and writes the result to the general-purpose destination 
register.

Single-precision to 32-bit variant
  FCVTNS &lt;Wd&gt;, &lt;Sn&gt;
Single-precision to 64-bit variant
  FCVTNS &lt;Xd&gt;, &lt;Sn&gt;
Double-precision to 32-bit variant
  FCVTNS &lt;Wd&gt;, &lt;Dn&gt;
Double-precision to 64-bit variant
  FCVTNS &lt;Xd&gt;, &lt;Dn&gt;</hint>
			<hint page="895" header="Floating-point Convert to Unsigned integer, rounding to nearest with ties to even" doc_id="armv8arm" token="FCVTNU">1. Vector
This instruction converts a scalar or each element in a vector from a 
floating-point value to an unsigned integer value using the Round to 
Nearest rounding mode, and writes the result to the SIMD&amp;FP destination 
register.

FCVTNU &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;

2. Scalar
This instruction converts the floating-point value in the SIMD&amp;FP source 
register to a 32-bit or 64-bit unsigned integer using the Round to Nearest 
rounding mode, and writes the result to the general-purpose destination 
register.

Single-precision to 32-bit variant
  FCVTNU &lt;Wd&gt;, &lt;Sn&gt;
Single-precision to 64-bit variant
  FCVTNU &lt;Xd&gt;, &lt;Sn&gt;
Double-precision to 32-bit variant
  FCVTNU &lt;Wd&gt;, &lt;Dn&gt;
Double-precision to 64-bit variant
  FCVTNU &lt;Xd&gt;, &lt;Dn&gt;</hint>
			<hint page="899" header="Floating-point Convert to Signed integer, rounding toward Plus infinity" doc_id="armv8arm" token="FCVTPS">1. Vector
This instruction converts a scalar or each element in a vector from a 
floating-point value to a signed integer value using the Round towards 
Plus Infinity rounding mode, and writes the result to the SIMD&amp;FP 
destination register.

FCVTPS &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;

2. Scalar
This instruction converts the floating-point value in the SIMD&amp;FP source 
register to a 32-bit or 64-bit signed integer using the Round towards 
Plus Infinity rounding mode, and writes the result to the general-purpose 
destination register.

Single-precision to 32-bit variant
  FCVTPS &lt;Wd&gt;, &lt;Sn&gt;
Single-precision to 64-bit variant
  FCVTPS &lt;Xd&gt;, &lt;Sn&gt;
Double-precision to 32-bit variant
  FCVTPS &lt;Wd&gt;, &lt;Dn&gt;
Double-precision to 64-bit variant
  FCVTPS &lt;Xd&gt;, &lt;Dn&gt;</hint>
			<hint page="903" header="Floating-point Convert to Unsigned integer, rounding toward Plus infinity" doc_id="armv8arm" token="FCVTPU">1. Vector
This instruction converts a scalar or each element in a vector from a 
floating-point value to an unsigned integer value using the Round 
towards Plus Infinity rounding mode, and writes the result to the 
SIMD&amp;FP destination register.

FCVTPU &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;

2. Scalar
This instruction converts the floating-point value in the SIMD&amp;FP 
source register to a 32-bit or 64-bit unsigned integer using the Round 
towards Plus Infinity rounding mode, and writes the result to the 
general-purpose destination register.

Single-precision to 32-bit variant
  FCVTPU &lt;Wd&gt;, &lt;Sn&gt;
Single-precision to 64-bit variant
  FCVTPU &lt;Xd&gt;, &lt;Sn&gt;
Double-precision to 32-bit variant
  FCVTPU &lt;Wd&gt;, &lt;Dn&gt;
Double-precision to 64-bit variant
  FCVTPU &lt;Xd&gt;, &lt;Dn&gt;</hint>
			<hint page="907" header="Floating-point Convert to lower precision Narrow, rounding to odd (vector)" doc_id="armv8arm" token="FCVTXN">This instruction reads each vector element in the source SIMD&amp;FP register, 
narrows each value to half the precision of the source element using the 
Round to Odd rounding mode, writes the result to a vector, and writes the 
vector to the destination SIMD&amp;FP register.
The FCVTXN instruction writes the vector to the lower half of the destination 
register and clears the upper half, while the FCVTXN2 instruction writes the 
vector to the upper half of the destination register without affecting the 
other bits of the register.

Scalar variant
  FCVTXN &lt;Vb&gt;&lt;d&gt;, &lt;Va&gt;&lt;n&gt;</hint>
			<hint page="907" header="Floating-point Convert to lower precision Narrow, rounding to odd (vector)" doc_id="armv8arm" token="FCVTXN2">This instruction reads each vector element in the source SIMD&amp;FP register, 
narrows each value to half the precision of the source element using the 
Round to Odd rounding mode, writes the result to a vector, and writes the 
vector to the destination SIMD&amp;FP register.
The FCVTXN instruction writes the vector to the lower half of the destination 
register and clears the upper half, while the FCVTXN2 instruction writes the 
vector to the upper half of the destination register without affecting the 
other bits of the register.

Vector variant
  FCVTXN2 &lt;Vb&gt;&lt;d&gt;, &lt;Va&gt;&lt;n&gt;</hint>
			<hint page="909" header="Floating-point Convert, rounding toward Zero" doc_id="armv8arm" token="FCVTZS">1. Vector. Fixed-point
This instruction converts a scalar or each element in a vector from 
floating-point to fixed-point signed integer using the Round towards 
Zero rounding mode, and writes the result to the SIMD&amp;FP destination 
register.

FCVTZS &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #&lt;fbits&gt;

2. Vector. Integer
This instruction converts a scalar or each element in a vector from 
a floating-point value to a signed integer value using the Round 
towards Zero rounding mode, and writes the result to the SIMD&amp;FP
destination register.

FCVTZS &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;

3. Scalar. Fixed-point
This instruction converts the floating-point value in the SIMD&amp;FP 
source register to a 32-bit or 64-bit fixed-point signed integer 
using the Round towards Zero rounding mode, and writes the result 
to the general-purpose destination register.

Single-precision to 32-bit variant: FCVTZS &lt;Wd&gt;, &lt;Sn&gt;, #&lt;fbits&gt;
Single-precision to 64-bit variant: FCVTZS &lt;Xd&gt;, &lt;Sn&gt;, #&lt;fbits&gt;
Double-precision to 32-bit variant: FCVTZS &lt;Wd&gt;, &lt;Dn&gt;, #&lt;fbits&gt;
Double-precision to 64-bit variant: FCVTZS &lt;Xd&gt;, &lt;Dn&gt;, #&lt;fbits&gt;

4. Scalar. Integer
This instruction converts the floating-point value in the SIMD&amp;FP 
source register to a 32-bit or 64-bit signed integer using the Round 
towards Zero rounding mode, and writes the result to the 
general-purpose destination register.

Single-precision to 32-bit variant: FCVTZS &lt;Wd&gt;, &lt;Sn&gt;
Single-precision to 64-bit variant: FCVTZS &lt;Xd&gt;, &lt;Sn&gt;
Double-precision to 32-bit variant: FCVTZS &lt;Wd&gt;, &lt;Dn&gt;
Double-precision to 64-bit variant: FCVTZS &lt;Xd&gt;, &lt;Dn&gt;</hint>
			<hint page="918" header="Floating-point Convert, rounding toward Zero" doc_id="armv8arm" token="FCVTZU">1. Vector. Fixed-point
This instruction converts a scalar or each element in a vector from 
floating-point to fixed-point unsigned integer using the Round towards 
Zero rounding mode, and writes the result to the general-purpose 
destination register.

FCVTZU &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #&lt;fbits&gt;

2. Vector. Integer
This instruction converts a scalar or each element in a vector from a 
floating-point value to an unsigned integer value using the Round towards 
Zero rounding mode, and writes the result to the SIMD&amp;FP destination 
register.

FCVTZU &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;

3. Scalar. Fixed-point
This instruction converts the floating-point value in the SIMD&amp;FP source 
register to a 32-bit or 64-bit fixed-point unsigned integer using the 
Round towards Zero rounding mode, and writes the result to the 
general-purpose destination register.

Single-precision to 32-bit variant: FCVTZU &lt;Wd&gt;, &lt;Sn&gt;, #&lt;fbits&gt;
Single-precision to 64-bit variant: FCVTZU &lt;Xd&gt;, &lt;Sn&gt;, #&lt;fbits&gt;
Double-precision to 32-bit variant: FCVTZU &lt;Wd&gt;, &lt;Dn&gt;, #&lt;fbits&gt;
Double-precision to 64-bit variant: FCVTZU &lt;Xd&gt;, &lt;Dn&gt;, #&lt;fbits&gt;

4. Scalar. Integer
This instruction converts the floating-point value in the SIMD&amp;FP source 
register to a 32-bit or 64-bit unsigned integer using the Round towards 
Zero rounding mode, and writes the result to the general-purpose destination 
register.

Single-precision to 32-bit variant: FCVTZU &lt;Wd&gt;, &lt;Sn&gt;
Single-precision to 64-bit variant: FCVTZU &lt;Xd&gt;, &lt;Sn&gt;
Double-precision to 32-bit variant: FCVTZU &lt;Wd&gt;, &lt;Dn&gt;
Double-precision to 64-bit variant: FCVTZU &lt;Xd&gt;, &lt;Dn&gt;</hint>
			<hint page="927" header="Floating-point Divide" doc_id="armv8arm" token="FDIV">1. Vector
This instruction divides the floating-point values in the elements in 
the first source SIMD&amp;FP register, by the floating-point values in the 
corresponding elements in the second source SIMD&amp;FP register, places 
the results in a vector, and writes the vector to the destination 
SIMD&amp;FP register.

FDIV &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;

2. Scalar
This instruction divides the floating-point value of the first source 
SIMD&amp;FP register by the floating-point value of the second source 
SIMD&amp;FP register, and writes the result to the destination SIMD&amp;FP 
register.

Single-precision variant
  FDIV &lt;Sd&gt;, &lt;Sn&gt;, &lt;Sm&gt;
Double-precision variant
  FDIV &lt;Dd&gt;, &lt;Dn&gt;, &lt;Dm&gt;</hint>
			<hint page="931" header="Floating-point fused Multiply-Add (scalar)" doc_id="armv8arm" token="FMADD">This instruction multiplies the values of the first two SIMD&amp;FP 
source registers, adds the product to the value of the third 
SIMD&amp;FP source register, and writes the result to the SIMD&amp;FP 
destination register.

Single-precision variant
  FMADD &lt;Sd&gt;, &lt;Sn&gt;, &lt;Sm&gt;, &lt;Sa&gt;
Double-precision variant
  FMADD &lt;Dd&gt;, &lt;Dn&gt;, &lt;Dm&gt;, &lt;Da&gt;</hint>
			<hint page="933" header="Floating-point Maximum" doc_id="armv8arm" token="FMAX">1. Vector
This instruction compares corresponding vector elements in the two 
source SIMD&amp;FP registers, places the larger of each of the two 
floating-point values into a vector, and writes the vector to 
the destination SIMD&amp;FP register.

FMAX &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;

2. Scalar
This instruction compares the two source SIMD&amp;FP registers, and 
writes the larger of the two floating-point values to the 
destination SIMD&amp;FP register.

Single-precision variant
  FMAX &lt;Sd&gt;, &lt;Sn&gt;, &lt;Sm&gt;
Double-precision variant
  FMAX &lt;Dd&gt;, &lt;Dn&gt;, &lt;Dm&gt;</hint>
			<hint page="937" header="Floating-point Maximum Number" doc_id="armv8arm" token="FMAXNM">1. Vector
This instruction compares corresponding vector elements in the two 
source SIMD&amp;FP registers, writes the larger of the two 
floating-point values into a vector, and writes the vector to the 
destination SIMD&amp;FP register.

FMAXNM &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;

2. Scalar
This instruction compares the first and second source SIMD&amp;FP 
register values, and writes the larger of the two floating-point 
values to the destination SIMD&amp;FP register.

Single-precision variant
  FMAXNM &lt;Sd&gt;, &lt;Sn&gt;, &lt;Sm&gt;
Double-precision variant
  FMAXNM &lt;Dd&gt;, &lt;Dn&gt;, &lt;Dm&gt;</hint>
			<hint page="941" header="Floating-point Maximum Number of Pair of elements" doc_id="armv8arm" token="FMAXNMP">1. Vector
This instruction creates a vector by concatenating the vector elements 
of the first source SIMD&amp;FP register after the vector elements of the 
second source SIMD&amp;FP register, reads each pair of adjacent vector 
elements in the two source SIMD&amp;FP registers, writes the largest of 
each pair of values into a vector, and writes the vector to the 
destination SIMD&amp;FP register. All the values in this instruction 
are floating-point values.

FMAXNMP &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;

2. Scalar
This instruction compares two vector elements in the source SIMD&amp;FP 
register and writes the largest of the floating-point values as a 
scalar to the destination SIMD&amp;FP register.

FMAXNMP &lt;V&gt;&lt;d&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="944" header="Floating-point Maximum Number across Vector" doc_id="armv8arm" token="FMAXNMV">This instruction compares all the vector elements in the source 
SIMD&amp;FP register, and writes the largest of the values as a scalar 
to the destination SIMD&amp;FP register. All the values in this 
instruction are floating-point values.

FMAXNMV &lt;V&gt;&lt;d&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="945" header="Floating-point Maximum of Pair of elements" doc_id="armv8arm" token="FMAXP">1. Vector
This instruction creates a vector by concatenating the vector 
elements of the first source SIMD&amp;FP register after the vector 
elements of the second source SIMD&amp;FP register, reads each pair 
of adjacent vector elements from the concatenated vector, writes 
the larger of each pair of values into a vector, and writes the 
vector to the destination SIMD&amp;FP register. All the values in 
this instruction are floating-point values.

FMAXP &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;

2. Scalar
This instruction compares two vector elements in the source 
SIMD&amp;FP register and writes the largest of the floating-point 
values as a scalar to the destination SIMD&amp;FP register.

FMAXP &lt;V&gt;&lt;d&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="948" header="Floating-point Maximum across Vector" doc_id="armv8arm" token="FMAXV">This instruction compares all the vector elements in the source 
SIMD&amp;FP register, and writes the largest of the values as a scalar 
to the destination SIMD&amp;FP register. All the values in this 
instruction are floating-point values.

FMAXV &lt;V&gt;&lt;d&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="949" header="Floating-point minimum" doc_id="armv8arm" token="FMIN">1. Vector
This instruction compares corresponding elements in the vectors 
in the two source SIMD&amp;FP registers, places the smaller of each 
of the two floating-point values into a vector, and writes the 
vector to the destination SIMD&amp;FP register.

FMIN &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;

2. Scalar
This instruction compares the first and second source SIMD&amp;FP 
register values, and writes the smaller of the two floating-point 
values to the destination SIMD&amp;FP register.

Single-precision variant
  FMIN &lt;Sd&gt;, &lt;Sn&gt;, &lt;Sm&gt;
Double-precision variant
  FMIN &lt;Dd&gt;, &lt;Dn&gt;, &lt;Dm&gt;</hint>
			<hint page="953" header="Floating-point Minimum Number" doc_id="armv8arm" token="FMINNM">1. Vector
This instruction compares corresponding vector elements in the two source 
SIMD&amp;FP registers, writes the smaller of the two floating-point values into 
a vector, and writes the vector to the destination SIMD&amp;FP register.

FMINNM &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;

2. Scalar
This instruction compares the first and second source SIMD&amp;FP register values, 
and writes the smaller of the two floating-point values to the destination 
SIMD&amp;FP register.

Single-precision variant
  FMINNM &lt;Sd&gt;, &lt;Sn&gt;, &lt;Sm&gt;
Double-precision variant
  FMINNM &lt;Dd&gt;, &lt;Dn&gt;, &lt;Dm&gt;</hint>
			<hint page="957" header="Floating-point Minimum Number of Pair of elements" doc_id="armv8arm" token="FMINNMP">1. Vector
This instruction creates a vector by concatenating the vector 
elements of the first source SIMD&amp;FP register after the vector 
elements of the second source SIMD&amp;FP register, reads each pair 
of adjacent vector elements in the two source SIMD&amp;FP registers, 
writes the smallest of each pair of floating-point values into 
a vector, and writes the vector to the destination SIMD&amp;FP register. 
All the values in this instruction are floating-point values.

FMINNMP &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;

2. Scalar
This instruction compares two vector elements in the source 
SIMD&amp;FP register and writes the smallest of the floating-point 
values as a scalar to the destination SIMD&amp;FP register.

FMINNMP &lt;V&gt;&lt;d&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="960" header="Floating-point Minimum Number across Vector" doc_id="armv8arm" token="FMINNMV">This instruction compares all the vector elements in the source 
SIMD&amp;FP register, and writes the smallest of the values as a 
scalar to the destination SIMD&amp;FP register. All the values in 
this instruction are floating-point values.

FMINNMV &lt;V&gt;&lt;d&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="961" header="Floating-point Minimum of Pair of elements" doc_id="armv8arm" token="FMINP">1. Vector
This instruction creates a vector by concatenating the vector 
elements of the first source SIMD&amp;FP register after the vector 
elements of the second source SIMD&amp;FP register, reads each pair 
of adjacent vector elements from the concatenated vector, 
writes the smaller of each pair of values into a vector, 
and writes the vector to the destination SIMD&amp;FP register. 
All the values in this instruction are floating-point values.

FMINP &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;

2. Scalar
This instruction compares two vector elements in the source 
SIMD&amp;FP register and writes the smallest of the floating-point 
values as a scalar to the destination SIMD&amp;FP register.

FMINP &lt;V&gt;&lt;d&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="964" header="Floating-point Minimum across Vector." doc_id="armv8arm" token="FMINV">This instruction compares all the vector elements in the source 
SIMD&amp;FP register, and writes the smallest of the values as a 
scalar to the destination SIMD&amp;FP register. All the values in 
this instruction are floating-point values.

FMINV &lt;V&gt;&lt;d&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="965" header="Floating-point fused Multiply-Add to accumulator" doc_id="armv8arm" token="FMLA">1. By element
This instruction multiplies the vector elements in the first source 
SIMD&amp;FP register by the specified value in the second source SIMD&amp;FP 
register, and accumulates the results in the vector elements of the 
destination SIMD&amp;FP register. All the values in this instruction are 
floating-point values.

FMLA &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]

2. Vector
This instruction multiplies corresponding floating-point values in 
the vectors in the two source SIMD&amp;FP registers, adds the product to 
the corresponding vector element of the destination SIMD&amp;FP register, 
and writes the result to the destination SIMD&amp;FP register.

FMLA &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="969" header="Floating-point fused Multiply-Subtract from accumulator" doc_id="armv8arm" token="FMLS">1. By element
This instruction multiplies the vector elements in the first source 
SIMD&amp;FP register by the specified value in the second source SIMD&amp;FP 
register, and subtracts the results from the vector elements of the 
destination SIMD&amp;FP register. All the values in this instruction are 
floating-point values.

FMLS &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]

2. Vector
This instruction multiplies corresponding floating-point values in 
the vectors in the two source SIMD&amp;FP registers, negates the product, 
adds the result to the corresponding vector element of the destination 
SIMD&amp;FP register, and writes the result to the destination SIMD&amp;FP 
register.

FMLS &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="973" header="Floating-point move" doc_id="armv8arm" token="FMOV">1. Vector. Immediate
This instruction copies an immediate floating-point constant 
into every element of the SIMD&amp;FP destination register.

Single-precision variant: FMOV &lt;Vd&gt;.&lt;T&gt;, #&lt;imm&gt;
Double-precision variant: FMOV &lt;Vd&gt;.2D, #&lt;imm&gt;

2. Register
This instruction copies the floating-point value in the 
SIMD&amp;FP source register to the SIMD&amp;FP destination register.

Single-precision variant: FMOV &lt;Sd&gt;, &lt;Sn&gt;
Double-precision variant: FMOV &lt;Dd&gt;, &lt;Dn&gt;

3. General
This instruction transfers the contents of a SIMD&amp;FP register 
to a general-purpose register, or the contents of a 
general-purpose register to a SIMD&amp;FP register.

32-bit to single-precision variant:    FMOV &lt;Sd&gt;, &lt;Wn&gt;
Single-precision to 32-bit variant:    FMOV &lt;Wd&gt;, &lt;Sn&gt;
64-bit to double-precision variant:    FMOV &lt;Dd&gt;, &lt;Xn&gt;
64-bit to top half of 128-bit variant: FMOV &lt;Vd&gt;.D[1], &lt;Xn&gt;
Double-precision to 64-bit variant:    FMOV &lt;Xd&gt;, &lt;Dn&gt;
Top half of 128-bit to 64-bit variant: FMOV &lt;Xd&gt;, &lt;Vn&gt;.D[1]

4. Scalar. Immediate
This instruction copies a floating-point immediate constant 
into the SIMD&amp;FP destination register.

Single-precision variant: FMOV &lt;Sd&gt;, #&lt;imm&gt;
Double-precision variant: FMOV &lt;Dd&gt;, #&lt;imm&gt;</hint>
			<hint page="979" header="Floating-point Fused Multiply-Subtract" doc_id="armv8arm" token="FMSUB">This instruction multiplies the values of the first two 
SIMD&amp;FP source registers, negates the product, adds that 
to the value of the third SIMD&amp;FP source register, and 
writes the result to the SIMD&amp;FP destination register.

Single-precision variant
  FMSUB &lt;Sd&gt;, &lt;Sn&gt;, &lt;Sm&gt;, &lt;Sa&gt;
Double-precision variant
  FMSUB &lt;Dd&gt;, &lt;Dn&gt;, &lt;Dm&gt;, &lt;Da&gt;</hint>
			<hint page="981" header="Floating-point Multiply" doc_id="armv8arm" token="FMUL">1. By element
This instruction multiplies the vector elements in the first source 
SIMD&amp;FP register by the specified value in the second source SIMD&amp;FP 
register, places the results in a vector, and writes the vector to 
the destination SIMD&amp;FP register. All the values in this instruction 
are floating-point values.

FMUL &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]

2. Vector
This instruction multiplies corresponding floating-point values in 
the vectors in the two source SIMD&amp;FP registers, places the result 
in a vector, and writes the vector to the destination SIMD&amp;FP register.

FMUL &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;

3. Scalar
This instruction multiplies the floating-point values of the two source 
SIMD&amp;FP registers, and writes the result to the destination SIMD&amp;FP 
register.

Single-precision variant
  FMUL &lt;Sd&gt;, &lt;Sn&gt;, &lt;Sm&gt;
Double-precision variant
  FMUL &lt;Dd&gt;, &lt;Dn&gt;, &lt;Dm&gt;</hint>
			<hint page="987" header="Floating-point Multiply extended" doc_id="armv8arm" token="FMULX">1. Default
This instruction multiplies corresponding floating-point values in 
the vectors of the two source SIMD&amp;FP registers, places the resulting
floating-point values in a vector, and writes the vector to the 
destination SIMD&amp;FP register.

FMULX &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;

2. By element
This instruction multiplies the floating-point values in the vector 
elements in the first source SIMD&amp;FP register by the specified 
floating-point value in the second source SIMD&amp;FP register, places 
the results in a vector, and writes the vector to the destination 
SIMD&amp;FP register.

FMULX &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]</hint>
			<hint page="992" header="Floating-point Negate" doc_id="armv8arm" token="FNEG">1. Vector
This instruction negates the value of each vector element in the 
source SIMD&amp;FP register, writes the result to a vector, and writes 
the vector to the destination SIMD&amp;FP register.

FNEG &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;

2. Scalar
Floating-point Negate (scalar). This instruction negates the value 
in the SIMD&amp;FP source register and writes the result to the SIMD&amp;FP 
destination register.

Single-precision variant
  FNEG &lt;Sd&gt;, &lt;Sn&gt;
Double-precision variant
  FNEG &lt;Dd&gt;, &lt;Dn&gt;</hint>
			<hint page="994" header="Floating-point Negated fused Multiply-Add (scalar)" doc_id="armv8arm" token="FNMADD">This instruction multiplies the values of the first two SIMD&amp;FP 
source registers, negates the product, subtracts the value of 
the third SIMD&amp;FP source register, and writes the result to 
the destination SIMD&amp;FP register.

Single-precision variant
  FNMADD &lt;Sd&gt;, &lt;Sn&gt;, &lt;Sm&gt;, &lt;Sa&gt;
Double-precision variant
  FNMADD &lt;Dd&gt;, &lt;Dn&gt;, &lt;Dm&gt;, &lt;Da&gt;</hint>
			<hint page="996" header="Floating-point Negated fused Multiply-Subtract (scalar)" doc_id="armv8arm" token="FNMSUB">This instruction multiplies the values of the first two 
SIMD&amp;FP source registers, subtracts the value of the 
third SIMD&amp;FP source register, and writes the result 
to the destination SIMD&amp;FP register.

Single-precision variant
  FNMSUB &lt;Sd&gt;, &lt;Sn&gt;, &lt;Sm&gt;, &lt;Sa&gt;
Double-precision variant
  FNMSUB &lt;Dd&gt;, &lt;Dn&gt;, &lt;Dm&gt;, &lt;Da&gt;</hint>
			<hint page="998" header="Floating-point Multiply-Negate (scalar)" doc_id="armv8arm" token="FNMUL">This instruction multiplies the floating-point values of 
the two source SIMD&amp;FP registers, and writes the negation 
of the result to the destination SIMD&amp;FP register.

Single-precision variant
  FNMUL &lt;Sd&gt;, &lt;Sn&gt;, &lt;Sm&gt;
Double-precision variant
  FNMUL &lt;Dd&gt;, &lt;Dn&gt;, &lt;Dm&gt;</hint>
			<hint page="1000" header="Floating-point Reciprocal Estimate" doc_id="armv8arm" token="FRECPE">This instruction finds an approximate reciprocal estimate 
for each vector element in the source SIMD&amp;FP register, 
places the result in a vector, and writes the vector to 
the destination SIMD&amp;FP register.

Scalar variant
  FRECPE &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;

Vector variant
  FRECPE &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="1002" header="Floating-point Reciprocal Step" doc_id="armv8arm" token="FRECPS">This instruction multiplies the corresponding floating-point 
values in the vectors of the two source SIMD&amp;FP registers, 
subtracts each of the products from 2.0, places the resulting 
floating-point values in a vector, and writes the vector to 
the destination SIMD&amp;FP register.

Scalar variant
  FRECPS &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;
Vector variant
  FRECPS &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1004" header="Floating-point Reciprocal exponent (scalar)" doc_id="armv8arm" token="FRECPX">This instruction finds an approximate reciprocal exponent for 
each vector element in the source SIMD&amp;FP register, places 
the result in a vector, and writes the vector to the 
destination SIMD&amp;FP register.

FRECPX &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;</hint>
			<hint page="1005" header="Floating-point Round to Integral, to nearest with ties to Away" doc_id="armv8arm" token="FRINTA">1. Vector
This instruction rounds a vector of floating-point values in the 
SIMD&amp;FP source register to integral floating-point values of the 
same size using the Round to Nearest with Ties to Away rounding 
mode, and writes the result to the SIMD&amp;FP destination register.

FRINTA &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;

2. Scalar
This instruction rounds a floating-point value in the SIMD&amp;FP 
source register to an integral floating-point value of the same 
size using the Round to Nearest with Ties to Away rounding mode, 
and writes the result to the SIMD&amp;FP destination register.

Single-precision variant
  FRINTA &lt;Sd&gt;, &lt;Sn&gt;
Double-precision variant
  FRINTA &lt;Dd&gt;, &lt;Dn&gt;</hint>
			<hint page="1009" header="Floating-point Round to Integral, using current rounding mode" doc_id="armv8arm" token="FRINTI">1. Vector
This instruction rounds a vector of floating-point values in the 
SIMD&amp;FP source register to integral floating-point values of the 
same size using the rounding mode that is determined by the FPCR, 
and writes the result to the SIMD&amp;FP destination register.

FRINTI &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;

2. Scalar
This instruction rounds a floating-point value in the SIMD&amp;FP 
source register to an integral floating-point value of the same 
size using the rounding mode that is determined by the FPCR, and 
writes the result to the SIMD&amp;FP destination register.

Single-precision variant
  FRINTI &lt;Sd&gt;, &lt;Sn&gt;
Double-precision variant
  FRINTI &lt;Dd&gt;, &lt;Dn&gt;</hint>
			<hint page="1013" header="Floating-point Round to Integral, toward Minus infinity" doc_id="armv8arm" token="FRINTM">1. Vector
This instruction rounds a vector of floating-point values in the 
SIMD&amp;FP source register to integral floating-point values of the 
same size using the Round towards Minus Infinity rounding mode, 
and writes the result to the SIMD&amp;FP destination register.

FRINTM &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;

2. Scalar
This instruction rounds a floating-point value in the SIMD&amp;FP 
source register to an integral floating-point value of the same 
size using the Round towards Minus Infinity rounding mode, and 
writes the result to the SIMD&amp;FP destination register.

Single-precision variant
  FRINTM &lt;Sd&gt;, &lt;Sn&gt;
Double-precision variant
  FRINTM &lt;Dd&gt;, &lt;Dn&gt;</hint>
			<hint page="1017" header="Floating-point Round to Integral, to nearest with ties to even" doc_id="armv8arm" token="FRINTN">1. Vector
This instruction rounds a vector of floating-point values in the 
SIMD&amp;FP source register to integral floating-point values of the 
same size using the Round to Nearest rounding mode, and writes 
the result to the SIMD&amp;FP destination register.

FRINTN &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;

2. Scalar
This instruction rounds a floating-point value in the SIMD&amp;FP 
source register to an integral floating-point value of the same 
size using the Round to Nearest rounding mode, and writes the 
result to the SIMD&amp;FP destination register.

Single-precision variant
  FRINTN &lt;Sd&gt;, &lt;Sn&gt;
Double-precision variant
  FRINTN &lt;Dd&gt;, &lt;Dn&gt;</hint>
			<hint page="1021" header="Floating-point Round to Integral, toward Plus infinity" doc_id="armv8arm" token="FRINTP">1. Vector
This instruction rounds a vector of floating-point values in the 
SIMD&amp;FP source register to integral floating-point values of the 
same size using the Round towards Plus Infinity rounding mode, 
and writes the result to the SIMD&amp;FP destination register.

FRINTP &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;

2. Scalar
This instruction rounds a floating-point value in the SIMD&amp;FP 
source register to an integral floating-point value of the same 
size using the Round towards Plus Infinity rounding mode, and 
writes the result to the SIMD&amp;FP destination register.

Single-precision variant
  FRINTP &lt;Sd&gt;, &lt;Sn&gt;
Double-precision variant
  FRINTP &lt;Dd&gt;, &lt;Dn&gt;</hint>
			<hint page="1025" header="Floating-point Round to Integral exact, using current rounding mode" doc_id="armv8arm" token="FRINTX">1. Vector
This instruction rounds a vector of floating-point values in the 
SIMD&amp;FP source register to integral floating-point values of the 
same size using the rounding mode that is determined by the FPCR, 
and writes the result to the SIMD&amp;FP destination register.

FRINTX &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;

2. Scalar
This instruction rounds a floating-point value in the SIMD&amp;FP 
source register to an integral floating-point value of the same 
size using the rounding mode that is determined by the FPCR, and 
writes the result to the SIMD&amp;FP destination register.

Single-precision variant
  FRINTX &lt;Sd&gt;, &lt;Sn&gt;
Double-precision variant
  FRINTX &lt;Dd&gt;, &lt;Dn&gt;</hint>
			<hint page="1029" header="Floating-point Round to Integral exact, using current rounding mode" doc_id="armv8arm" token="FRINTZ">1. Vector
This instruction rounds a vector of floating-point values in the 
SIMD&amp;FP source register to integral floating-point values of the 
same size using the Round towards Zero rounding mode, and writes 
the result to the SIMD&amp;FP destination register.

FRINTZ &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;

2. Scalar
This instruction rounds a floating-point value in the SIMD&amp;FP source 
register to an integral floating-point value of the same size using 
the rounding mode that is determined by the FPCR, and writes the 
result to the SIMD&amp;FP destination register.

Single-precision variant
  FRINTX &lt;Sd&gt;, &lt;Sn&gt;
Double-precision variant
  FRINTX &lt;Dd&gt;, &lt;Dn&gt;</hint>
			<hint page="1033" header="Floating-point Reciprocal Square Root Estimate" doc_id="armv8arm" token="FRSQRTE">This instruction calculates an approximate square root for each 
vector element in the source SIMD&amp;FP register, places the result 
in a vector, and writes the vector to the destination SIMD&amp;FP 
register.

FRSQRTE &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;</hint>
			<hint page="1035" header="Floating-point Reciprocal Square Root Step" doc_id="armv8arm" token="FRSQRTS">This instruction multiplies corresponding floating-point values 
in the vectors of the two source SIMD&amp;FP registers, subtracts 
each of the products from 3.0, divides these results by 2.0, 
places the results into a vector, and writes the vector to 
the destination SIMD&amp;FP register.

Scalar variant
  FRSQRTS &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;
Vector variant
  FRSQRTS &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1038" header="Floating-point Square Root" doc_id="armv8arm" token="FSQRT">1. Vector
This instruction calculates the square root for each vector element in 
the source SIMD&amp;FP register, places the result in a vector, and writes 
the vector to the destination SIMD&amp;FP register.

FSQRT &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;

2. Scalar
This instruction calculates the square root of the value in the SIMD&amp;FP 
source register and writes the result to the SIMD&amp;FP destination register.

Single-precision variant
  FSQRT &lt;Sd&gt;, &lt;Sn&gt;
Double-precision variant
  FSQRT &lt;Dd&gt;, &lt;Dn&gt;</hint>
			<hint page="1041" header="Floating-point Subtract " doc_id="armv8arm" token="FSUB">1. Vector
This instruction subtracts the elements in the vector in the second 
source SIMD&amp;FP register, from the corresponding elements in the 
vector in the first source SIMD&amp;FP register, places each result into 
elements of a vector, and writes the vector to the destination SIMD&amp;FP 
register.

2. Scalar
This instruction subtracts the floating-point value of the second source 
SIMD&amp;FP register from the floating-point value of the first source SIMD&amp;FP 
register, and writes the result to the destination SIMD&amp;FP register.

Single-precision variant
  FSUB &lt;Sd&gt;, &lt;Sn&gt;, &lt;Sm&gt;
Double-precision variant
  FSUB &lt;Dd&gt;, &lt;Dn&gt;, &lt;Dm&gt;</hint>
		</group>
		<group type="ins" name="A64 SIMD instructions">
			<hint page="771" header="Absolute value (vector)" doc_id="armv8arm" token="ABS">This instruction calculates the absolute value of each vector 
element in the source SIMD&amp;FP register, puts the result into a 
vector, and writes the vector to the destination SIMD&amp;FP register.

ABS &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;</hint>
			<hint page="773" header="Add (vector)" doc_id="armv8arm" token="ADD">This instruction adds corresponding elements in the two source 
SIMD&amp;FP registers, places the results into a vector, and writes 
the vector to the destination SIMD&amp;FP register.

ADD &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;</hint>
			<hint page="775" header="Add returning High Narrow" doc_id="armv8arm" token="ADDHN">This instruction adds each vector element in the first source SIMD&amp;FP 
register to the corresponding vector element in the second source 
SIMD&amp;FP register, places the most significant half of the result 
into a vector, and writes the vector to the lower or upper half of 
the destination SIMD&amp;FP register.
The results are truncated. For rounded results, see RADDHN, RADDHN2.
The ADDHN instruction writes the vector to the lower half of the 
destination register and clears the upper half, while the ADDHN2 
instruction writes the vector to the upper half of the destination 
register without affecting the other bits of the register.

ADDHN &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;, &lt;Vm&gt;.&lt;Ta&gt;</hint>
			<hint page="775" header="Add returning High Narrow" doc_id="armv8arm" token="ADDHN2">This instruction adds each vector element in the first source SIMD&amp;FP 
register to the corresponding vector element in the second source 
SIMD&amp;FP register, places the most significant half of the result 
into a vector, and writes the vector to the lower or upper half of 
the destination SIMD&amp;FP register.
The results are truncated. For rounded results, see RADDHN, RADDHN2.
The ADDHN instruction writes the vector to the lower half of the 
destination register and clears the upper half, while the ADDHN2 
instruction writes the vector to the upper half of the destination 
register without affecting the other bits of the register.

ADDHN2 &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;, &lt;Vm&gt;.&lt;Ta&gt;</hint>
			<hint page="777" header="Add Pair of elements" doc_id="armv8arm" token="ADDP">1. Scalar
This instruction adds two vector elements in the source 
SIMD&amp;FP register and writes the scalar result into the 
destination SIMD&amp;FP register.

ADDP &lt;V&gt;&lt;d&gt;, &lt;Vn&gt;.&lt;T&gt;

2. Vector
This instruction creates a vector by concatenating the 
vector elements of the first source SIMD&amp;FP register 
after the vector elements of the second source SIMD&amp;FP 
register, reads each pair of adjacent vector elements 
from the concatenated vector, adds each pair of values 
together, places the result into a vector, and writes 
the vector to the destination SIMD&amp;FP register.

ADDP &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="780" header="Add across Vector" doc_id="armv8arm" token="ADDV">This instruction adds every vector element in the source SIMD&amp;FP 
register together, and writes the scalar result to the destination 
SIMD&amp;FP register.

ADDV &lt;V&gt;&lt;d&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="786" header="Bitwise AND (vector)" doc_id="armv8arm" token="AND">This instruction performs a bitwise AND between the two source 
SIMD&amp;FP registers, and writes the result to the destination 
SIMD&amp;FP register.

AND &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="787" header="Bitwise bit Clear" doc_id="armv8arm" token="BIC">1. Vector. Immediate
This instruction reads each vector element from the destination 
SIMD&amp;FP register, performs a bitwise AND between each result and 
the complement of an immediate constant, places the result into 
a vector, and writes the vector to the destination SIMD&amp;FP register.

16-bit variant
  BIC &lt;Vd&gt;.&lt;T&gt;, #&lt;imm8&gt;{, LSL #&lt;amount&gt;}
32-bit variant
  BIC &lt;Vd&gt;.&lt;T&gt;, #&lt;imm8&gt;{, LSL #&lt;amount&gt;}

2. Vector Register
This instruction performs a bitwise AND between the first source 
SIMD&amp;FP register and the complement of the second source SIMD&amp;FP 
register, and writes the result to the destination SIMD&amp;FP register.

BIC &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="790" header="Bitwise Insert if False" doc_id="armv8arm" token="BIF">This instruction inserts each bit from the first source 
SIMD&amp;FP register into the destination SIMD&amp;FP register 
if the corresponding bit of the second source SIMD&amp;FP 
register is 0, otherwise leaves the bit in the 
destination register unchanged.

BIF &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="791" header="Bitwise Insert if True" doc_id="armv8arm" token="BIT">This instruction inserts each bit from the first source 
SIMD&amp;FP register into the SIMD&amp;FP destination register 
if the corresponding bit of the second source SIMD&amp;FP 
register is 1, otherwise leaves the bit in the 
destination register unchanged.

BIT &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="792" header="Bitwise Select" doc_id="armv8arm" token="BSL">This instruction sets each bit in the destination 
SIMD&amp;FP register to the corresponding bit from the
first source SIMD&amp;FP register when the original 
destination bit was 1, otherwise from the second 
source SIMD&amp;FP register.

BSL &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="793" header="Count Leading Sign bits (vector)" doc_id="armv8arm" token="CLS">This instruction counts the number of consecutive bits following 
the most significant bit that are the same as the most significant 
bit in each vector element in the source SIMD&amp;FP register, places 
the result into a vector, and writes the vector to the destination 
SIMD&amp;FP register. The count does not include the most significant 
bit itself.

CLS &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="795" header="Count Leading Zero bits (vector)" doc_id="armv8arm" token="CLZ">This instruction counts the number of consecutive zeros, starting 
from the most significant bit, in each vector element in the source 
SIMD&amp;FP register, places the result into a vector, and writes the 
vector to the destination SIMD&amp;FP register.

CLZ &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="797" header="Compare bitwise Equal" doc_id="armv8arm" token="CMEQ">1. Register
This instruction compares each vector element from the first source 
SIMD&amp;FP register with the corresponding vector element from the 
second source SIMD&amp;FP register, and if the comparison is equal sets 
every bit of the corresponding vector element in the destination 
SIMD&amp;FP register to one, otherwise sets every bit of the corresponding 
vector element in the destination SIMD&amp;FP register to zero.

CMEQ &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;

2. Zero
This instruction reads each vector element in the source SIMD&amp;FP 
register and if the value is equal to zero sets every bit of the 
corresponding vector element in the destination SIMD&amp;FP register 
to one, otherwise sets every bit of the corresponding vector element 
in the destination SIMD&amp;FP register to zero.

CMEQ &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #0</hint>
			<hint page="801" header="Compare signed Greater than or Equal" doc_id="armv8arm" token="CMGE">1. Register
This instruction compares each vector element in the first source 
SIMD&amp;FP register with the corresponding vector element in the 
second source SIMD&amp;FP register and if the first signed integer 
value is greater than or equal to the second signed integer value 
sets every bit of the corresponding vector element in the 
destination SIMD&amp;FP register to one, otherwise sets every 
bit of the corresponding vector element in the destination 
SIMD&amp;FP register to zero.

CMGE &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;

2. Zero
This instruction reads each vector element in the source SIMD&amp;FP 
register and if the signed integer value is greater than or equal 
to zero sets every bit of the corresponding vector element in the 
destination SIMD&amp;FP register to one, otherwise sets every bit of 
the corresponding vector element in the destination SIMD&amp;FP 
register to zero.

CMGE &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #0</hint>
			<hint page="805" header="Compare signed Greater than" doc_id="armv8arm" token="CMGT">1. Register
This instruction compares each vector element in the first source 
SIMD&amp;FP register with the corresponding vector element in the 
second source SIMD&amp;FP register and if the first signed integer 
value is greater than the second signed integer value sets every 
bit of the corresponding vector element in the destination SIMD&amp;FP 
register to one, otherwise sets every bit of the corresponding 
vector element in the destination SIMD&amp;FP register to zero.

CMGT &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;

2. Zero
This instruction reads each vector element in the source SIMD&amp;FP 
register and if the signed integer value is greater than zero 
sets every bit of the corresponding vector element in the 
destination SIMD&amp;FP register to one, otherwise sets every bit 
of the corresponding vector element in the destination SIMD&amp;FP 
register to zero.

CMGT &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #0</hint>
			<hint page="809" header="Compare unsigned Higher (vector)" doc_id="armv8arm" token="CMHI">This instruction compares each vector element in the first source 
SIMD&amp;FP register with the corresponding vector element in the 
second source SIMD&amp;FP register and if the first unsigned integer 
value is greater than the second unsigned integer value sets every 
bit of the corresponding vector element in the destination SIMD&amp;FP 
register to one, otherwise sets every bit of the corresponding 
vector element in the destination SIMD&amp;FP register to zero.

CMHI &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;</hint>
			<hint page="811" header="Compare unsigned Higher or Same (vector)" doc_id="armv8arm" token="CMHS">This instruction compares each vector element in the first source SIMD&amp;FP 
register with the corresponding vector element in the second source 
SIMD&amp;FP register and if the first unsigned integer value is greater than 
or equal to the second unsigned integer value sets every bit of the 
corresponding vector element in the destination SIMD&amp;FP register to one, 
otherwise sets every bit of the corresponding vector element in the 
destination SIMD&amp;FP register to zero.

CMHS &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;</hint>
			<hint page="813" header="Compare signed Less than or Equal to zero (vector)" doc_id="armv8arm" token="CMLE">This instruction reads each vector element in the source 
SIMD&amp;FP register and if the signed integer value is less 
than or equal to zero sets every bit of the corresponding 
vector element in the destination SIMD&amp;FP register to one, 
otherwise sets every bit of the corresponding vector 
element in the destination SIMD&amp;FP register to zero.

CMLE &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #0</hint>
			<hint page="815" header="Compare signed Less than zero (vector)" doc_id="armv8arm" token="CMLT">This instruction reads each vector element in the source 
SIMD&amp;FP register and if the signed integer value is less 
than zero sets every bit of the corresponding vector 
element in the destination SIMD&amp;FP register to one, 
otherwise sets every bit of the corresponding vector 
element in the destination SIMD&amp;FP register to zero.

CMLT &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #0</hint>
			<hint page="817" header="Compare bitwise Test bits nonzero (vector)" doc_id="armv8arm" token="CMTST">This instruction reads each vector element in the first source 
SIMD&amp;FP register, performs an AND with the corresponding vector 
element in the second source SIMD&amp;FP register, and if the result 
is not zero, sets every bit of the corresponding vector element 
in the destination SIMD&amp;FP register to one, otherwise sets every 
bit of the corresponding vector element in the destination SIMD&amp;FP
register to zero.

CMTST &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;</hint>
			<hint page="819" header="Population Count per byte" doc_id="armv8arm" token="CNT">This instruction counts the number of bits that have a value 
of one in each vector element in the source SIMD&amp;FP register, 
places the result into a vector, and writes the vector to the 
destination SIMD&amp;FP register.

CNT &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="820" header="Duplicate to vector or scalar" doc_id="armv8arm" token="DUP">1. Element
This instruction duplicates the vector element at the specified 
element index in the source SIMD&amp;FP register into a scalar or 
each element in a vector, and writes the result to the 
destination SIMD&amp;FP register.

DUP &lt;V&gt;&lt;d&gt;, &lt;Vn&gt;.&lt;T&gt;[&lt;index&gt;]

2. General
This instruction duplicates the contents of the source 
general-purpose register into a scalar or each element in a 
vector, and writes the result to the SIMD&amp;FP destination 
register.

DUP &lt;Vd&gt;.&lt;T&gt;, &lt;R&gt;&lt;n&gt;</hint>
			<hint page="825" header="Bitwise Exclusive OR (vector)" doc_id="armv8arm" token="EOR">This instruction performs a bitwise Exclusive OR operation 
between the two source SIMD&amp;FP registers, and places the 
result in the destination SIMD&amp;FP register.

EOR &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="826" header="Extract vector from pair of vectors" doc_id="armv8arm" token="EXT">This instruction extracts the lowest vector elements from the 
second source SIMD&amp;FP register and the highest vector elements 
from the first source SIMD&amp;FP register, concatenates the results 
into a vector, and writes the vector to the destination SIMD&amp;FP 
register vector. The index value specifies the lowest vector 
element to extract from the first source register, and consecutive 
elements are extracted from the first, then second, source 
registers until the destination vector is filled.

EXT &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;, #&lt;index&gt;</hint>
			<hint page="1043" header="Insert vector element" doc_id="armv8arm" token="INS">1. Element
This instruction copies the vector element of the source 
SIMD&amp;FP register to the specified vector element of the 
destination SIMD&amp;FP register.

INS &lt;Vd&gt;.&lt;Ts&gt;[&lt;index1&gt;], &lt;Vn&gt;.&lt;Ts&gt;[&lt;index2&gt;]

2. General
This instruction copies the contents of the source 
general-purpose register to the specified vector element 
in the destination SIMD&amp;FP register.

INS &lt;Vd&gt;.&lt;Ts&gt;[&lt;index&gt;], &lt;R&gt;&lt;n&gt;</hint>
			<hint page="1047" header="Load single-element structures" doc_id="armv8arm" token="LD1">1. Multiple structures
This instruction loads multiple single-element structures from memory and 
writes the result to one, two, three, or four SIMD&amp;FP registers.

No offset:
  One register variant:    LD1 { &lt;Vt&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;]
  Two registers variant:   LD1 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;]
  Three registers variant: LD1 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt;, &lt;Vt3&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;]
  Four registers variant:  LD1 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt;, &lt;Vt3&gt;.&lt;T&gt;, &lt;Vt4&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;]

Post-index:
  One register, immediate offset variant:    LD1 { &lt;Vt&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;imm&gt;
  One register, register offset variant:     LD1 { &lt;Vt&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;Xm&gt;
  Two registers, immediate offset variant:   LD1 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;imm&gt;
  Two registers, register offset variant:    LD1 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;Xm&gt;
  Three registers, immediate offset variant: LD1 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt;, &lt;Vt3&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;imm&gt;
  Three registers, register offset variant:  LD1 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt;, &lt;Vt3&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;Xm&gt;
  Four registers, immediate offset variant:  LD1 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt;, &lt;Vt3&gt;.&lt;T&gt;, &lt;Vt4&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;imm&gt;
  Four registers, register offset variant:   LD1 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt;, &lt;Vt3&gt;.&lt;T&gt;, &lt;Vt4&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;Xm&gt;

2. Single structure
This instruction loads a single-element structure from memory and writes the 
result to the specified lane of the SIMD&amp;FP register without affecting the 
other bits of the register.

No offset:
  8-bit variant:  LD1 { &lt;Vt&gt;.B }[&lt;index&gt;], [&lt;Xn|SP&gt;]
  16-bit variant  LD1 { &lt;Vt&gt;.H }[&lt;index&gt;], [&lt;Xn|SP&gt;]
  32-bit variant: LD1 { &lt;Vt&gt;.S }[&lt;index&gt;], [&lt;Xn|SP&gt;]
  64-bit variant: LD1 { &lt;Vt&gt;.D }[&lt;index&gt;], [&lt;Xn|SP&gt;]

Post-index:
8-bit, immediate offset variant:  LD1 { &lt;Vt&gt;.B }[&lt;index&gt;], [&lt;Xn|SP&gt;], #1
8-bit, register offset variant:   LD1 { &lt;Vt&gt;.B }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;
16-bit, immediate offset variant: LD1 { &lt;Vt&gt;.H }[&lt;index&gt;], [&lt;Xn|SP&gt;], #2
16-bit, register offset variant:  LD1 { &lt;Vt&gt;.H }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;
32-bit, immediate offset variant: LD1 { &lt;Vt&gt;.S }[&lt;index&gt;], [&lt;Xn|SP&gt;], #4
32-bit, register offset variant:  LD1 { &lt;Vt&gt;.S }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;
64-bit, immediate offset variant: LD1 { &lt;Vt&gt;.D }[&lt;index&gt;], [&lt;Xn|SP&gt;], #8
64-bit, register offset variant:  LD1 { &lt;Vt&gt;.D }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;</hint>
			<hint page="1055" header="Load one single-element structure and Replicate to all lanes (of one register)" doc_id="armv8arm" token="LD1R">This instruction loads a single-element structure from memory and 
replicates the structure to all the lanes of the SIMD&amp;FP register.

No offset
  LD1R { &lt;Vt&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;]
Post-index
  Immediate offset variant: LD1R { &lt;Vt&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;imm&gt;
  Register offset variant:  LD1R { &lt;Vt&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;Xm&gt;</hint>
			<hint page="1058" header="Load 2-element structures" doc_id="armv8arm" token="LD2">1. Multiple structures
This instruction loads multiple 2-element structures from memory and writes 
the result to the two SIMD&amp;FP registers, with de-interleaving.

No offset:
  LD2 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;]

Post-index:
  Immediate offset variant: LD2 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;imm&gt;
  Register offset variant:  LD2 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;Xm&gt;

2. Single structure
This instruction loads a 2-element structure from memory and writes the result to 
the corresponding elements of the two SIMD&amp;FP registers without affecting the 
other bits of the registers.

No offset:
  8-bit variant:  LD2 { &lt;Vt&gt;.B, &lt;Vt2&gt;.B }[&lt;index&gt;], [&lt;Xn|SP&gt;]
  16-bit variant: LD2 { &lt;Vt&gt;.H, &lt;Vt2&gt;.H }[&lt;index&gt;], [&lt;Xn|SP&gt;]
  32-bit variant: LD2 { &lt;Vt&gt;.S, &lt;Vt2&gt;.S }[&lt;index&gt;], [&lt;Xn|SP&gt;]
  64-bit variant: LD2 { &lt;Vt&gt;.D, &lt;Vt2&gt;.D }[&lt;index&gt;], [&lt;Xn|SP&gt;]


Post-index:
  8-bit, immediate offset variant:  LD2 { &lt;Vt&gt;.B, &lt;Vt2&gt;.B }[&lt;index&gt;], [&lt;Xn|SP&gt;], #2
  8-bit, register offset variant:   LD2 { &lt;Vt&gt;.B, &lt;Vt2&gt;.B }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;
  16-bit, immediate offset variant: LD2 { &lt;Vt&gt;.H, &lt;Vt2&gt;.H }[&lt;index&gt;], [&lt;Xn|SP&gt;], #4
  16-bit, register offset variant:  LD2 { &lt;Vt&gt;.H, &lt;Vt2&gt;.H }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;
  32-bit, immediate offset variant: LD2 { &lt;Vt&gt;.S, &lt;Vt2&gt;.S }[&lt;index&gt;], [&lt;Xn|SP&gt;], #8
  32-bit, register offset variant:  LD2 { &lt;Vt&gt;.S, &lt;Vt2&gt;.S }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;
  64-bit, immediate offset variant: LD2 { &lt;Vt&gt;.D, &lt;Vt2&gt;.D }[&lt;index&gt;], [&lt;Xn|SP&gt;], #16
  64-bit, register offset variant:  LD2 { &lt;Vt&gt;.D, &lt;Vt2&gt;.D }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;</hint>
			<hint page="1065" header="Load single 2-element structure and Replicate to all lanes of two registers" doc_id="armv8arm" token="LD2R">This instruction loads a 2-element structure from memory and replicates 
the structure to all the lanes of the two SIMD&amp;FP registers.

No offset:
  LD2R { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;]

Post-index:
  Immediate offset variant: LD2R { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;imm&gt;
  Register offset variant:  LD2R { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;Xm&gt;</hint>
			<hint page="1068" header="Load 3-element structures to three registers" doc_id="armv8arm" token="LD3">1. Multiple structures
This instruction loads multiple 3-element structures from memory and writes the 
result to the three SIMD&amp;FP registers, with de-interleaving.

No offset:
  LD3 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt;, &lt;Vt3&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;]

Post-index:
  Immediate offset variant: LD3 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt;, &lt;Vt3&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;imm&gt;
  Register offset variant:  LD3 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt;, &lt;Vt3&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;Xm&gt;

2. Single structure
This instruction loads a 3-element structure from memory and writes the result to the 
corresponding elements of the three SIMD&amp;FP registers without affecting the other 
bits of the registers.

No offset:
  8-bit variant:  LD3 { &lt;Vt&gt;.B, &lt;Vt2&gt;.B, &lt;Vt3&gt;.B }[&lt;index&gt;], [&lt;Xn|SP&gt;]
  16-bit variant: LD3 { &lt;Vt&gt;.H, &lt;Vt2&gt;.H, &lt;Vt3&gt;.H }[&lt;index&gt;], [&lt;Xn|SP&gt;]
  32-bit variant: LD3 { &lt;Vt&gt;.S, &lt;Vt2&gt;.S, &lt;Vt3&gt;.S }[&lt;index&gt;], [&lt;Xn|SP&gt;]
  64-bit variant: LD3 { &lt;Vt&gt;.D, &lt;Vt2&gt;.D, &lt;Vt3&gt;.D }[&lt;index&gt;], [&lt;Xn|SP&gt;]

Post-index:
  8-bit, immediate offset variant:  LD3 { &lt;Vt&gt;.B, &lt;Vt2&gt;.B, &lt;Vt3&gt;.B }[&lt;index&gt;], [&lt;Xn|SP&gt;], #3
  8-bit, register offset variant:   LD3 { &lt;Vt&gt;.B, &lt;Vt2&gt;.B, &lt;Vt3&gt;.B }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;
  16-bit, immediate offset variant: LD3 { &lt;Vt&gt;.H, &lt;Vt2&gt;.H, &lt;Vt3&gt;.H }[&lt;index&gt;], [&lt;Xn|SP&gt;], #6
  16-bit, register offset variant:  LD3 { &lt;Vt&gt;.H, &lt;Vt2&gt;.H, &lt;Vt3&gt;.H }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;
  32-bit, immediate offset variant: LD3 { &lt;Vt&gt;.S, &lt;Vt2&gt;.S, &lt;Vt3&gt;.S }[&lt;index&gt;], [&lt;Xn|SP&gt;], #12
  32-bit, register offset variant:  LD3 { &lt;Vt&gt;.S, &lt;Vt2&gt;.S, &lt;Vt3&gt;.S }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;
  64-bit, immediate offset variant: LD3 { &lt;Vt&gt;.D, &lt;Vt2&gt;.D, &lt;Vt3&gt;.D }[&lt;index&gt;], [&lt;Xn|SP&gt;], #24
  64-bit, register offset variant:  LD3 { &lt;Vt&gt;.D, &lt;Vt2&gt;.D, &lt;Vt3&gt;.D }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;</hint>
			<hint page="1075" header="Load single 3-element structure and Replicate to all lanes of three registers." doc_id="armv8arm" token="LD3R">This instruction loads a 3-element structure from memory and replicates 
the structure to all the lanes of the three SIMD&amp;FP registers.

No offset:
  LD3R { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt;, &lt;Vt3&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;]
Post-index:
  Immediate offset variant: LD3R { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt;, &lt;Vt3&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;imm&gt;
  Register offset variant:  LD3R { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt;, &lt;Vt3&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;Xm&gt;</hint>
			<hint page="1078" header="Load 4-element structures to four registers" doc_id="armv8arm" token="LD4">1. Multiple structures
This instruction loads multiple 4-element structures from memory and writes the result 
to the four SIMD&amp;FP registers, with de-interleaving.

No offset:
  LD4 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt;, &lt;Vt3&gt;.&lt;T&gt;, &lt;Vt4&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;]

Post-index:
  Immediate offset variant: LD4 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt;, &lt;Vt3&gt;.&lt;T&gt;, &lt;Vt4&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;imm&gt;
  Register offset variant:  LD4 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt;, &lt;Vt3&gt;.&lt;T&gt;, &lt;Vt4&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;Xm&gt;

2. Single structure
This instruction loads a 4-element structure from memory and writes the result to the 
corresponding elements of the four SIMD&amp;FP registers without affecting the other bits 
of the registers.

No offset:
  8-bit variant:  LD4 { &lt;Vt&gt;.B, &lt;Vt2&gt;.B, &lt;Vt3&gt;.B, &lt;Vt4&gt;.B }[&lt;index&gt;], [&lt;Xn|SP&gt;]
  16-bit variant: LD4 { &lt;Vt&gt;.H, &lt;Vt2&gt;.H, &lt;Vt3&gt;.H, &lt;Vt4&gt;.H }[&lt;index&gt;], [&lt;Xn|SP&gt;]
  32-bit variant: LD4 { &lt;Vt&gt;.S, &lt;Vt2&gt;.S, &lt;Vt3&gt;.S, &lt;Vt4&gt;.S }[&lt;index&gt;], [&lt;Xn|SP&gt;]
  64-bit variant: LD4 { &lt;Vt&gt;.D, &lt;Vt2&gt;.D, &lt;Vt3&gt;.D, &lt;Vt4&gt;.D }[&lt;index&gt;], [&lt;Xn|SP&gt;]

Post-index:
  8-bit, immediate offset variant:  LD4 { &lt;Vt&gt;.B, &lt;Vt2&gt;.B, &lt;Vt3&gt;.B, &lt;Vt4&gt;.B }[&lt;index&gt;], [&lt;Xn|SP&gt;], #4
  8-bit, register offset variant:   LD4 { &lt;Vt&gt;.B, &lt;Vt2&gt;.B, &lt;Vt3&gt;.B, &lt;Vt4&gt;.B }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;
  16-bit, immediate offset variant: LD4 { &lt;Vt&gt;.H, &lt;Vt2&gt;.H, &lt;Vt3&gt;.H, &lt;Vt4&gt;.H }[&lt;index&gt;], [&lt;Xn|SP&gt;], #8
  16-bit, register offset variant:  LD4 { &lt;Vt&gt;.H, &lt;Vt2&gt;.H, &lt;Vt3&gt;.H, &lt;Vt4&gt;.H }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;
  32-bit, immediate offset variant: LD4 { &lt;Vt&gt;.S, &lt;Vt2&gt;.S, &lt;Vt3&gt;.S, &lt;Vt4&gt;.S }[&lt;index&gt;], [&lt;Xn|SP&gt;], #16
  32-bit, register offset variant:  LD4 { &lt;Vt&gt;.S, &lt;Vt2&gt;.S, &lt;Vt3&gt;.S, &lt;Vt4&gt;.S }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;
  64-bit, immediate offset variant: LD4 { &lt;Vt&gt;.D, &lt;Vt2&gt;.D, &lt;Vt3&gt;.D, &lt;Vt4&gt;.D }[&lt;index&gt;], [&lt;Xn|SP&gt;], #32

  64-bit, register offset variant:  LD4 { &lt;Vt&gt;.D, &lt;Vt2&gt;.D, &lt;Vt3&gt;.D, &lt;Vt4&gt;.D }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;</hint>
			<hint page="1085" header="Load single 4-element structure and Replicate to all lanes of four registers" doc_id="armv8arm" token="LD4R">This instruction loads a 4-element structure from memory and replicates 
the structure to all the lanes of the four SIMD&amp;FP registers.

No offset:
  LD4R { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt;, &lt;Vt3&gt;.&lt;T&gt;, &lt;Vt4&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;]

Post-index:
  Immediate offset variant: 
    LD4R { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt;, &lt;Vt3&gt;.&lt;T&gt;, &lt;Vt4&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;imm&gt;
  Register offset variant
    LD4R { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt;, &lt;Vt3&gt;.&lt;T&gt;, &lt;Vt4&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;Xm&gt;</hint>
			<hint page="1088" header="Load Pair of SIMD&amp;FP registers, with Non-temporal hint" doc_id="armv8arm" token="LDNP">This instruction loads a pair of SIMD&amp;FP registers from memory, 
issuing a hint to the memory system that the access is non-temporal. 
The address that is used for the load is calculated from a base 
register value and an optional immediate offset.

32-bit variant
  LDNP &lt;St1&gt;, &lt;St2&gt;, [&lt;Xn|SP&gt;{, #&lt;imm&gt;}]
64-bit variant
  LDNP &lt;Dt1&gt;, &lt;Dt2&gt;, [&lt;Xn|SP&gt;{, #&lt;imm&gt;}]
128-bit variant
  LDNP &lt;Qt1&gt;, &lt;Qt2&gt;, [&lt;Xn|SP&gt;{, #&lt;imm&gt;}]</hint>
			<hint page="1090" header="Load Pair of SIMD&amp;FP registers" doc_id="armv8arm" token="LDP">This instruction loads a pair of SIMD&amp;FP registers from memory. 
The address that is used for the load is calculated from a base 
register value and an optional immediate offset.

Post-index:
  32-bit variant:  LDP &lt;St1&gt;, &lt;St2&gt;, [&lt;Xn|SP&gt;], #&lt;imm&gt;
  64-bit variant:  LDP &lt;Dt1&gt;, &lt;Dt2&gt;, [&lt;Xn|SP&gt;], #&lt;imm&gt;
  128-bit variant: LDP &lt;Qt1&gt;, &lt;Qt2&gt;, [&lt;Xn|SP&gt;], #&lt;imm&gt;

Pre-index:
  32-bit variant:  LDP &lt;St1&gt;, &lt;St2&gt;, [&lt;Xn|SP&gt;, #&lt;imm&gt;]!
  64-bit variant:  LDP &lt;Dt1&gt;, &lt;Dt2&gt;, [&lt;Xn|SP&gt;, #&lt;imm&gt;]!
  128-bit variant: LDP &lt;Qt1&gt;, &lt;Qt2&gt;, [&lt;Xn|SP&gt;, #&lt;imm&gt;]!

Signed offset:
  32-bit variant:  LDP &lt;St1&gt;, &lt;St2&gt;, [&lt;Xn|SP&gt;{, #&lt;imm&gt;}]
  64-bit variant:  LDP &lt;Dt1&gt;, &lt;Dt2&gt;, [&lt;Xn|SP&gt;{, #&lt;imm&gt;}]
  128-bit variant: LDP &lt;Qt1&gt;, &lt;Qt2&gt;, [&lt;Xn|SP&gt;{, #&lt;imm&gt;}]</hint>
			<hint page="1093" header="Load SIMD&amp;FP Register" doc_id="armv8arm" token="LDR">1. Immediate
This instruction loads an element from memory, and writes the result 
as a scalar to the SIMD&amp;FP register. The address that is used for 
the load is calculated from a base register value, a signed 
immediate offset, and an optional offset that is a multiple of the 
element size.

Post-index:
  8-bit variant:   LDR &lt;Bt&gt;, [&lt;Xn|SP&gt;], #&lt;simm&gt;
  16-bit variant:  LDR &lt;Ht&gt;, [&lt;Xn|SP&gt;], #&lt;simm&gt;
  32-bit variant:  LDR &lt;St&gt;, [&lt;Xn|SP&gt;], #&lt;simm&gt;
  64-bit variant:  LDR &lt;Dt&gt;, [&lt;Xn|SP&gt;], #&lt;simm&gt;
  128-bit variant: LDR &lt;Qt&gt;, [&lt;Xn|SP&gt;], #&lt;simm&gt;

Pre-index:
  8-bit variant:   LDR &lt;Bt&gt;, [&lt;Xn|SP&gt;, #&lt;simm&gt;]!
  16-bit variant:  LDR &lt;Ht&gt;, [&lt;Xn|SP&gt;, #&lt;simm&gt;]!
  32-bit variant:  LDR &lt;St&gt;, [&lt;Xn|SP&gt;, #&lt;simm&gt;]!
  64-bit variant:  LDR &lt;Dt&gt;, [&lt;Xn|SP&gt;, #&lt;simm&gt;]!
  128-bit variant: LDR &lt;Qt&gt;, [&lt;Xn|SP&gt;, #&lt;simm&gt;]!

Unsigned offset:
  8-bit variant:   LDR &lt;Bt&gt;, [&lt;Xn|SP&gt;{, #&lt;pimm&gt;}]
  16-bit variant:  LDR &lt;Ht&gt;, [&lt;Xn|SP&gt;{, #&lt;pimm&gt;}]
  32-bit variant:  LDR &lt;St&gt;, [&lt;Xn|SP&gt;{, #&lt;pimm&gt;}]
  64-bit variant:  LDR &lt;Dt&gt;, [&lt;Xn|SP&gt;{, #&lt;pimm&gt;}]
  128-bit variant: LDR &lt;Qt&gt;, [&lt;Xn|SP&gt;{, #&lt;pimm&gt;}]

2. Literal
This instruction loads a SIMD&amp;FP register from memory. The address that is 
used for the load is calculated from the PC value and an immediate offset.

32-bit variant:  LDR &lt;St&gt;, &lt;label&gt;
64-bit variant:  LDR &lt;Dt&gt;, &lt;label&gt;
128-bit variant: LDR &lt;Qt&gt;, &lt;label&gt;

3. Register
This instruction loads a SIMD&amp;FP register from memory. The address that is used 
for the load is calculated from a base register value and an offset register 
value. The offset can be optionally shifted and extended.

8-bit variant:   LDR &lt;Bt&gt;, [&lt;Xn|SP&gt;, (&lt;Wm&gt;|&lt;Xm&gt;), &lt;extend&gt; {&lt;amount&gt;}]
8-bit variant:   LDR &lt;Bt&gt;, [&lt;Xn|SP&gt;, &lt;Xm&gt;{, LSL &lt;amount&gt;}]
16-bit variant:  LDR &lt;Ht&gt;, [&lt;Xn|SP&gt;, (&lt;Wm&gt;|&lt;Xm&gt;){, &lt;extend&gt; {&lt;amount&gt;}}]
32-bit variant:  LDR &lt;St&gt;, [&lt;Xn|SP&gt;, (&lt;Wm&gt;|&lt;Xm&gt;){, &lt;extend&gt; {&lt;amount&gt;}}]
64-bit variant:  LDR &lt;Dt&gt;, [&lt;Xn|SP&gt;, (&lt;Wm&gt;|&lt;Xm&gt;){, &lt;extend&gt; {&lt;amount&gt;}}]
128-bit variant: LDR &lt;Qt&gt;, [&lt;Xn|SP&gt;, (&lt;Wm&gt;|&lt;Xm&gt;){, &lt;extend&gt; {&lt;amount&gt;}}]</hint>
			<hint page="1102" header="Load SIMD&amp;FP Register (unscaled offset)" doc_id="armv8arm" token="LDUR">This instruction loads a SIMD&amp;FP register from memory. The address 
that is used for the load is calculated from a base register value 
and an optional immediate offset.

8-bit variant:   LDUR &lt;Bt&gt;, [&lt;Xn|SP&gt;{, #&lt;simm&gt;}]
16-bit variant:  LDUR &lt;Ht&gt;, [&lt;Xn|SP&gt;{, #&lt;simm&gt;}]
32-bit variant:  LDUR &lt;St&gt;, [&lt;Xn|SP&gt;{, #&lt;simm&gt;}]
64-bit variant:  LDUR &lt;Dt&gt;, [&lt;Xn|SP&gt;{, #&lt;simm&gt;}]
128-bit variant: LDUR &lt;Qt&gt;, [&lt;Xn|SP&gt;{, #&lt;simm&gt;}]</hint>
			<hint page="1104" header="Multiply-Add to accumulator" doc_id="armv8arm" token="MLA">1. By element
This instruction multiplies the vector elements in the first source 
SIMD&amp;FP register by the specified value in the second source SIMD&amp;FP 
register, and accumulates the results with the vector elements of the 
destination SIMD&amp;FP register. All the values in this instruction are 
unsigned integer values.

MLA &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]

2. Vector
This instruction multiplies corresponding elements in the vectors of 
the two source SIMD&amp;FP registers, and accumulates the results with the 
vector elements of the destination SIMD&amp;FP register.

MLA &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1108" header="Multiply-Subtract from accumulator" doc_id="armv8arm" token="MLS">1. By element
This instruction multiplies the vector elements in the first source 
SIMD&amp;FP register by the specified value in the second source SIMD&amp;FP 
register, and subtracts the results from the vector elements of the 
destination SIMD&amp;FP register. All the values in this instruction are 
unsigned integer values.

MLS &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]

2. Vector
This instruction multiplies corresponding elements in the vectors of 
the two source SIMD&amp;FP registers, and subtracts the results from the 
vector elements of the destination SIMD&amp;FP register.

MLS &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1112" header="Move vector element" doc_id="armv8arm" token="MOV">1. Scalar
This instruction duplicates the specified vector element in the SIMD&amp;FP 
source register into a scalar, and writes the result to the SIMD&amp;FP 
destination register.

MOV &lt;V&gt;&lt;d&gt;, &lt;Vn&gt;.&lt;T&gt;[&lt;index&gt;]
  is equivalent to
DUP &lt;V&gt;&lt;d&gt;, &lt;Vn&gt;.&lt;T&gt;[&lt;index&gt;]

2. Element
This instruction copies the vector element of the source SIMD&amp;FP register 
to the specified vector element of the destination SIMD&amp;FP register.
This instruction can insert data into individual elements within a SIMD&amp;FP 
register without clearing the remaining bits to zero.

MOV &lt;Vd&gt;.&lt;Ts&gt;[&lt;index1&gt;], &lt;Vn&gt;.&lt;Ts&gt;[&lt;index2&gt;]
  is equivalent to
INS &lt;Vd&gt;.&lt;Ts&gt;[&lt;index1&gt;], &lt;Vn&gt;.&lt;Ts&gt;[&lt;index2&gt;]

3. From general
This instruction copies the contents of the source general-purpose register 
to the specified vector element in the destination SIMD&amp;FP register.
This instruction can insert data into individual elements within a SIMD&amp;FP 
register without clearing the remaining bits to zero.

MOV &lt;Vd&gt;.&lt;Ts&gt;[&lt;index&gt;], &lt;R&gt;&lt;n&gt;
  is equivalent to
INS &lt;Vd&gt;.&lt;Ts&gt;[&lt;index&gt;], &lt;R&gt;&lt;n&gt;

4. Vector
This instruction copies the vector in the source SIMD&amp;FP register into the 
destination SIMD&amp;FP register.

MOV &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;
  is equivalent to
ORR &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;

5. To general
This instruction reads the unsigned integer from the source SIMD&amp;FP register, 
zero-extends it to form a 32-bit or 64-bit value, and writes the result to the 
destination general-purpose register.

32-bit variant:
  MOV &lt;Wd&gt;, &lt;Vn&gt;.S[&lt;index&gt;] is equivalent to UMOV &lt;Wd&gt;, &lt;Vn&gt;.S[&lt;index&gt;]
64-bit variant:
  MOV &lt;Xd&gt;, &lt;Vn&gt;.D[&lt;index&gt;] is equivalent to UMOV &lt;Xd&gt;, &lt;Vn&gt;.D[&lt;index&gt;]</hint>
			<hint page="1120" header="Move Immediate (vector)" doc_id="armv8arm" token="MOVI">This instruction places an immediate constant into every vector 
element of the destination SIMD&amp;FP register.

8-bit variant:
  MOVI &lt;Vd&gt;.&lt;T&gt;, #&lt;imm8&gt;{, LSL #0}
16-bit shifted immediate variant
  MOVI &lt;Vd&gt;.&lt;T&gt;, #&lt;imm8&gt;{, LSL #&lt;amount&gt;}
32-bit shifted immediate variant
  MOVI &lt;Vd&gt;.&lt;T&gt;, #&lt;imm8&gt;{, LSL #&lt;amount&gt;}
32-bit shifting ones variant
  MOVI &lt;Vd&gt;.&lt;T&gt;, #&lt;imm8&gt;, MSL #&lt;amount&gt;
64-bit scalar variant
  MOVI &lt;Dd&gt;, #&lt;imm&gt;
64-bit vector variant
  MOVI &lt;Vd&gt;.2D, #&lt;imm&gt;</hint>
			<hint page="1123" header="Multiply" doc_id="armv8arm" token="MUL">1. By element
This instruction multiplies the vector elements in the first source 
SIMD&amp;FP register by the specified value in the second source SIMD&amp;FP 
register, places the results in a vector, and writes the vector to the 
destination SIMD&amp;FP register. All the values in this instruction are 
unsigned integer values.

MUL &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]

2. Vector
This instruction multiplies corresponding elements in the vectors of 
the two source SIMD&amp;FP registers, places the results in a vector, and 
writes the vector to the destination SIMD&amp;FP register.

MUL &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1127" header="Bitwise NOT (vector)" doc_id="armv8arm" token="MVN">This instruction reads each vector element from the source SIMD&amp;FP register, 
places the inverse of each value into a vector, and writes the vector to the 
destination SIMD&amp;FP register.

MVN &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;

  is equivalent to

NOT &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="1128" header="Move inverted Immediate (vector)" doc_id="armv8arm" token="MVNI">This instruction places the inverse of an immediate constant into 
every vector element of the destination SIMD&amp;FP register.

16-bit shifted immediate variant
  MVNI &lt;Vd&gt;.&lt;T&gt;, #&lt;imm8&gt;{, LSL #&lt;amount&gt;}
32-bit shifted immediate variant
  MVNI &lt;Vd&gt;.&lt;T&gt;, #&lt;imm8&gt;{, LSL #&lt;amount&gt;}
32-bit shifting ones variant
  MVNI &lt;Vd&gt;.&lt;T&gt;, #&lt;imm8&gt;, MSL #&lt;amount&gt;</hint>
			<hint page="1130" header="Negate (vector)" doc_id="armv8arm" token="NEG">This instruction reads each vector element from the source SIMD&amp;FP 
register, negates each value, puts the result into a vector, and 
writes the vector to the destination SIMD&amp;FP register.

NEG &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;</hint>
			<hint page="1132" header="Bitwise NOT (vector)" doc_id="armv8arm" token="NOT">This instruction reads each vector element from the source SIMD&amp;FP 
register, places the inverse of each value into a vector, and 
writes the vector to the destination SIMD&amp;FP register.

NOT &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="1133" header="Bitwise inclusive OR NOT" doc_id="armv8arm" token="ORN">1. Vector
This instruction performs a bitwise OR NOT between the two source SIMD&amp;FP 
registers, and writes the result to the destination SIMD&amp;FP register.

ORN &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;

2. Immediate
This instruction reads each vector element from the destination SIMD&amp;FP 
register, performs a bitwise OR between each result and an immediate 
constant, places the result into a vector, and writes the vector to the 
destination SIMD&amp;FP register.

16-bit variant
  ORR &lt;Vd&gt;.&lt;T&gt;, #&lt;imm8&gt;{, LSL #&lt;amount&gt;}
32-bit variant
  ORR &lt;Vd&gt;.&lt;T&gt;, #&lt;imm8&gt;{, LSL #&lt;amount&gt;}

3. Register
This instruction performs a bitwise OR between the two source SIMD&amp;FP 
registers, and writes the result to the destination SIMD&amp;FP register.

ORR &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1137" header="Polynomial Multiply" doc_id="armv8arm" token="PMUL">This instruction multiplies corresponding elements in the vectors 
of the two source SIMD&amp;FP registers, places the results in a vector, 
and writes the vector to the destination SIMD&amp;FP register.

PMUL &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1139" header="Polynomial Multiply Long" doc_id="armv8arm" token="PMULL">This instruction multiplies corresponding elements in the lower or 
upper half of the vectors of the two source SIMD&amp;FP registers, 
places the results in a vector, and writes the vector to the 
destination SIMD&amp;FP register. The destination vector elements are 
twice as long as the elements that are multiplied.

The PMULL instruction extracts each source vector from the lower 
half of each source register, while the PMULL2
instruction extracts each source vector from the upper half of 
each source register.

PMULL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1139" header="Polynomial Multiply Long" doc_id="armv8arm" token="PMULL2">This instruction multiplies corresponding elements in the lower or 
upper half of the vectors of the two source SIMD&amp;FP registers, 
places the results in a vector, and writes the vector to the 
destination SIMD&amp;FP register. The destination vector elements are 
twice as long as the elements that are multiplied.

The PMULL instruction extracts each source vector from the lower 
half of each source register, while the PMULL2
instruction extracts each source vector from the upper half of 
each source register.

PMULL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1141" header="Rounding Add returning High Narrow" doc_id="armv8arm" token="RADDHN">This instruction adds each vector element in the first source SIMD&amp;FP 
register to the corresponding vector element in the second source SIMD&amp;FP 
register, places the most significant half of the result into a vector, 
and writes the vector to the lower or upper half of the destination SIMD&amp;FP 
register.

The RADDHN instruction writes the vector to the lower half of the destination 
register and clears the upper half, while the RADDHN2 instruction writes the 
vector to the upper half of the destination register without affecting the 
other bits of the register.

RADDHN &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;, &lt;Vm&gt;.&lt;Ta&gt;</hint>
			<hint page="1141" header="Rounding Add returning High Narrow" doc_id="armv8arm" token="RADDHN2">This instruction adds each vector element in the first source SIMD&amp;FP 
register to the corresponding vector element in the second source SIMD&amp;FP 
register, places the most significant half of the result into a vector, 
and writes the vector to the lower or upper half of the destination SIMD&amp;FP 
register.

The RADDHN instruction writes the vector to the lower half of the destination 
register and clears the upper half, while the RADDHN2 instruction writes the 
vector to the upper half of the destination register without affecting the 
other bits of the register.

RADDHN2 &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;, &lt;Vm&gt;.&lt;Ta&gt;</hint>
			<hint page="1143" header="Reverse Bit order (vector)" doc_id="armv8arm" token="RBIT">This instruction reads each vector element from the source SIMD&amp;FP register, 
reverses the bits of the element, places the results into a vector, and 
writes the vector to the destination SIMD&amp;FP register.

RBIT &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="1144" header="Reverse elements in 16-bit halfwords (vector)" doc_id="armv8arm" token="REV16">This instruction reverses the order of 8-bit elements in each halfword 
of the vector in the source SIMD&amp;FP register, places the results into 
a vector, and writes the vector to the destination SIMD&amp;FP register.

REV16 &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="1146" header="Reverse elements in 32-bit words (vector)" doc_id="armv8arm" token="REV32">This instruction reverses the order of 8-bit or 16-bit elements in each 
word of the vector in the source SIMD&amp;FP register, places the results 
into a vector, and writes the vector to the destination SIMD&amp;FP register.

REV32 &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="1148" header="Reverse elements in 64-bit doublewords (vector)" doc_id="armv8arm" token="REV64">This instruction reverses the order of 8-bit, 16-bit, or 32-bit elements in 
each doubleword of the vector in the source SIMD&amp;FP register, places the 
results into a vector, and writes the vector to the destination SIMD&amp;FP register.

REV64 &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="1150" header="Rounding Shift Right Narrow (immediate)" doc_id="armv8arm" token="RSHRN">This instruction reads each unsigned integer value from the vector in the 
source SIMD&amp;FP register, right shifts each result by an immediate value, 
writes the final result to a vector, and writes the vector to the lower or 
upper half of the destination SIMD&amp;FP register. The destination vector 
elements are half as long as the source vector elements. The results are 
rounded. For truncated results, see SHRN, SHRN2.

The RSHRN instruction writes the vector to the lower half of the 
destination register and clears the upper half, while the RSHRN2 
instruction writes the vector to the upper half of the destination 
register without affecting the other bits of the register.

RSHRN &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;, #&lt;shift&gt;</hint>
			<hint page="1150" header="Rounding Shift Right Narrow (immediate)" doc_id="armv8arm" token="RSHRN2">This instruction reads each unsigned integer value from the vector in the 
source SIMD&amp;FP register, right shifts each result by an immediate value, 
writes the final result to a vector, and writes the vector to the lower or 
upper half of the destination SIMD&amp;FP register. The destination vector 
elements are half as long as the source vector elements. The results are 
rounded. For truncated results, see SHRN, SHRN2.

The RSHRN instruction writes the vector to the lower half of the 
destination register and clears the upper half, while the RSHRN2 
instruction writes the vector to the upper half of the destination 
register without affecting the other bits of the register.

RSHRN2 &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;, #&lt;shift&gt;</hint>
			<hint page="1152" header="Rounding Subtract returning High Narrow" doc_id="armv8arm" token="RSUBHN">This instruction subtracts each vector element of the second source SIMD&amp;FP 
register from the corresponding vector element of the first source SIMD&amp;FP 
register, places the most significant half of the result into a vector, and 
writes the vector to the lower or upper half of the destination SIMD&amp;FP register.

The results are rounded. For truncated results, see SUBHN, SUBHN2.

The RSUBHN instruction writes the vector to the lower half of the destination 
register and clears the upper half, while the RSUBHN2 instruction writes the 
vector to the upper half of the destination register without affecting the 
other bits of the register.

RSUBHN &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;, &lt;Vm&gt;.&lt;Ta&gt;</hint>
			<hint page="1152" header="Rounding Subtract returning High Narrow" doc_id="armv8arm" token="RSUBHN2">This instruction subtracts each vector element of the second source SIMD&amp;FP 
register from the corresponding vector element of the first source SIMD&amp;FP 
register, places the most significant half of the result into a vector, and 
writes the vector to the lower or upper half of the destination SIMD&amp;FP register.

The results are rounded. For truncated results, see SUBHN, SUBHN2.

The RSUBHN instruction writes the vector to the lower half of the destination 
register and clears the upper half, while the RSUBHN2 instruction writes the 
vector to the upper half of the destination register without affecting the 
other bits of the register.

RSUBHN2 &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;, &lt;Vm&gt;.&lt;Ta&gt;</hint>
			<hint page="1154" header="Signed Absolute difference and Accumulate" doc_id="armv8arm" token="SABA">This instruction subtracts the elements of the vector of the second 
source SIMD&amp;FP register from the corresponding elements of the first 
source SIMD&amp;FP register, and accumulates the absolute values of the 
results into the elements of the vector of the destination SIMD&amp;FP 
register.

SABA &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1156" header="Signed Absolute difference and Accumulate Long" doc_id="armv8arm" token="SABAL">This instruction subtracts the vector elements in the lower or upper 
half of the second source SIMD&amp;FP register from the corresponding 
vector elements of the first source SIMD&amp;FP register, and accumulates 
the absolute values of the results into the vector elements of the 
destination SIMD&amp;FP register. The destination vector elements are 
twice as long as the source vector elements.

The SABAL instruction extracts each source vector from the lower half 
of each source register, while the SABAL2 instruction extracts each 
source vector from the upper half of each source register.

SABAL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1156" header="Signed Absolute difference and Accumulate Long" doc_id="armv8arm" token="SABAL2">This instruction subtracts the vector elements in the lower or upper 
half of the second source SIMD&amp;FP register from the corresponding 
vector elements of the first source SIMD&amp;FP register, and accumulates 
the absolute values of the results into the vector elements of the 
destination SIMD&amp;FP register. The destination vector elements are 
twice as long as the source vector elements.

The SABAL instruction extracts each source vector from the lower half 
of each source register, while the SABAL2 instruction extracts each 
source vector from the upper half of each source register.

SABAL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1158" header="Signed Absolute Difference" doc_id="armv8arm" token="SABD">This instruction subtracts the elements of the vector of the second 
source SIMD&amp;FP register from the corresponding elements of the first 
source SIMD&amp;FP register, places the absolute values of the results 
into a vector, and writes the vector to the destination SIMD&amp;FP register.

SABD &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1160" header="Signed Absolute Difference Long" doc_id="armv8arm" token="SABDL">This instruction subtracts the vector elements of the second source SIMD&amp;FP 
register from the corresponding vector elements of the first source SIMD&amp;FP 
register, places the absolute value of the results into a vector, and writes 
the vector to the lower or upper half of the destination SIMD&amp;FP register. 

The destination vector elements are twice as long as the source vector elements.

The SABDL instruction writes the vector to the lower half of the destination 
register and clears the upper half, while the SABDL2 instruction writes the 
vector to the upper half of the destination register without affecting the 
other bits of the register.

SABDL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1160" header="Signed Absolute Difference Long" doc_id="armv8arm" token="SABDL2">This instruction subtracts the vector elements of the second source SIMD&amp;FP 
register from the corresponding vector elements of the first source SIMD&amp;FP 
register, places the absolute value of the results into a vector, and writes 
the vector to the lower or upper half of the destination SIMD&amp;FP register. 

The destination vector elements are twice as long as the source vector elements.

The SABDL instruction writes the vector to the lower half of the destination 
register and clears the upper half, while the SABDL2 instruction writes the 
vector to the upper half of the destination register without affecting the 
other bits of the register.

SABDL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1162" header="Signed Add and Accumulate Long Pairwise" doc_id="armv8arm" token="SADALP">This instruction adds pairs of adjacent signed integer values from the 
vector in the source SIMD&amp;FP register and accumulates the results into 
the vector elements of the destination SIMD&amp;FP register. The destination 
vector elements are twice as long as the source vector elements.

SADALP &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;</hint>
			<hint page="1164" header="Signed Add Long (vector)" doc_id="armv8arm" token="SADDL">This instruction adds each vector element in the lower or upper half 
of the first source SIMD&amp;FP register to the corresponding vector 
element of the second source SIMD&amp;FP register, places the results 
into a vector, and writes the vector to the destination SIMD&amp;FP 
register. The destination vector elements are twice as long as the 
source vector elements. All the values in this instruction are 
signed integer values.

The SADDL instruction extracts each source vector from the lower 
half of each source register, while the SADDL2 instruction extracts 
each source vector from the upper half of each source register.

SADDL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1164" header="Signed Add Long (vector)" doc_id="armv8arm" token="SADDL2">This instruction adds each vector element in the lower or upper half 
of the first source SIMD&amp;FP register to the corresponding vector 
element of the second source SIMD&amp;FP register, places the results 
into a vector, and writes the vector to the destination SIMD&amp;FP 
register. The destination vector elements are twice as long as the 
source vector elements. All the values in this instruction are 
signed integer values.

The SADDL instruction extracts each source vector from the lower 
half of each source register, while the SADDL2 instruction extracts 
each source vector from the upper half of each source register.

SADDL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1166" header="Signed Add Long Pairwise" doc_id="armv8arm" token="SADDLP">This instruction adds pairs of adjacent signed integer values from 
the vector in the source SIMD&amp;FP register, places the result into 
a vector, and writes the vector to the destination SIMD&amp;FP register. 
The destination vector elements are twice as long as the source vector 
elements.

SADDLP &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;</hint>
			<hint page="1168" header="Signed Add Long across Vector" doc_id="armv8arm" token="SADDLV">This instruction adds every vector element in the source SIMD&amp;FP 
register together, and writes the scalar result to the destination 
SIMD&amp;FP register. The destination scalar is twice as long as the 
source vector elements. All the values in this instruction are 
signed integer values.

SADDLV &lt;V&gt;&lt;d&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="1170" header="Signed Add Wide" doc_id="armv8arm" token="SADDW">This instruction adds vector elements of the first source SIMD&amp;FP 
register to the corresponding vector elements in the lower or upper 
half of the second source SIMD&amp;FP register, places the results in a 
vector, and writes the vector to the SIMD&amp;FP destination register.

The SADDW instruction extracts the second source vector from the lower 
half of the second source register, while the SADDW2 instruction extracts 
the second source vector from the upper half of the second source register.

SADDW &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Ta&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1170" header="Signed Add Wide" doc_id="armv8arm" token="SADDW2">This instruction adds vector elements of the first source SIMD&amp;FP 
register to the corresponding vector elements in the lower or upper 
half of the second source SIMD&amp;FP register, places the results in a 
vector, and writes the vector to the SIMD&amp;FP destination register.

The SADDW instruction extracts the second source vector from the lower 
half of the second source register, while the SADDW2 instruction extracts 
the second source vector from the upper half of the second source register.

SADDW2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Ta&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1172" header="Signed fixed-point Convert" doc_id="armv8arm" token="SCVTF">1. Fixed-point (vector)
This instruction converts each element in a vector from fixed-point to 
floating-point using the rounding mode that is specified by the FPCR, 
and writes the result to the SIMD&amp;FP destination register.

Scalar variant: SCVTF &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #&lt;fbits&gt;

Vector variant: SCVTF &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, #&lt;fbits&gt;

2. Integer (vector)
This instruction converts each element in a vector from signed integer 
to floating-point using the rounding mode that is specified by the FPCR, 
and writes the result to the SIMD&amp;FP destination register.

Scalar variant: SCVTF &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;
Vector variant: SCVTF &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;

3. Fixed-point (scalar)
This instruction converts the signed value in the 32-bit or 64-bit 
general-purpose source register to a floating-point value using the 
rounding mode that is specified by the FPCR, and writes the result to 
the SIMD&amp;FP destination register.

32-bit to single-precision variant: SCVTF &lt;Sd&gt;, &lt;Wn&gt;, #&lt;fbits&gt;
32-bit to double-precision variant: SCVTF &lt;Dd&gt;, &lt;Wn&gt;, #&lt;fbits&gt;
64-bit to single-precision variant: SCVTF &lt;Sd&gt;, &lt;Xn&gt;, #&lt;fbits&gt;
64-bit to double-precision variant:SCVTF &lt;Dd&gt;, &lt;Xn&gt;, #&lt;fbits&gt;

4. Integer (scalar)
This instruction converts the signed integer value in the general-purpose 
source register to a floating-point value using the rounding mode that is 
specified by the FPCR, and writes the result to the SIMD&amp;FP destination register.

32-bit to single-precision variant: SCVTF &lt;Sd&gt;, &lt;Wn&gt;
32-bit to double-precision variant: SCVTF &lt;Dd&gt;, &lt;Wn&gt;
64-bit to single-precision variant: SCVTF &lt;Sd&gt;, &lt;Xn&gt;
64-bit to double-precision variant: SCVTF &lt;Dd&gt;, &lt;Xn&gt;</hint>
			<hint page="1191" header="Signed Halving Add" doc_id="armv8arm" token="SHADD">This instruction adds corresponding signed integer values from the 
two source SIMD&amp;FP registers, shifts each result right one bit, 
places the results into a vector, and writes the vector to the 
destination SIMD&amp;FP register.

SHADD &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1193" header="Shift Left (immediate)" doc_id="armv8arm" token="SHL">This instruction reads each value from a vector, right shifts each 
result by an immediate value, writes the final result to a vector, 
and writes the vector to the destination SIMD&amp;FP register.

Scalar variant
  SHL &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #&lt;shift&gt;
Vector variant
  SHL &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, #&lt;shift&gt;</hint>
			<hint page="1195" header="Shift Left Long (by element size)" doc_id="armv8arm" token="SHLL">This instruction reads each vector element in the lower or upper 
half of the source SIMD&amp;FP register, left shifts each result by 
the element size, writes the final result to a vector, and writes 
the vector to the destination SIMD&amp;FP register. The destination 
vector elements are twice as long as the source vector elements.

The SHLL instruction extracts vector elements from the lower half 
of the source register, while the SHLL2 instruction extracts vector 
elements from the upper half of the source register.

SHLL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, #&lt;shift&gt;</hint>
			<hint page="1195" header="Shift Left Long (by element size)" doc_id="armv8arm" token="SHLL2">This instruction reads each vector element in the lower or upper 
half of the source SIMD&amp;FP register, left shifts each result by 
the element size, writes the final result to a vector, and writes 
the vector to the destination SIMD&amp;FP register. The destination 
vector elements are twice as long as the source vector elements.

The SHLL instruction extracts vector elements from the lower half 
of the source register, while the SHLL2 instruction extracts vector 
elements from the upper half of the source register.

SHLL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, #&lt;shift&gt;</hint>
			<hint page="1197" header="Shift Right Narrow (immediate)" doc_id="armv8arm" token="SHRN">Shift Right Narrow (immediate). This instruction reads each unsigned integer 
value from the source SIMD&amp;FP register, right shifts each result by an 
immediate value, puts the final result into a vector, and writes the vector 
to the lower or upper half of the destination SIMD&amp;FP register. The destination 
vector elements are half as long as the source vector elements. The results 
are truncated. For rounded results, see RSHRN, RSHRN2.

The RSHRN instruction writes the vector to the lower half of the destination 
register and clears the upper half, while the RSHRN2 instruction writes the 
vector to the upper half of the destination register without affecting the 
other bits of the register.

SHRN &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;, #&lt;shift&gt;</hint>
			<hint page="1197" header="Shift Right Narrow (immediate)" doc_id="armv8arm" token="SHRN2">Shift Right Narrow (immediate). This instruction reads each unsigned integer 
value from the source SIMD&amp;FP register, right shifts each result by an 
immediate value, puts the final result into a vector, and writes the vector 
to the lower or upper half of the destination SIMD&amp;FP register. The destination 
vector elements are half as long as the source vector elements. The results 
are truncated. For rounded results, see RSHRN, RSHRN2.

The RSHRN instruction writes the vector to the lower half of the destination 
register and clears the upper half, while the RSHRN2 instruction writes the 
vector to the upper half of the destination register without affecting the 
other bits of the register.

SHRN2 &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;, #&lt;shift&gt;</hint>
			<hint page="1199" header="Signed Halving Subtract" doc_id="armv8arm" token="SHSUB">This instruction subtracts the elements in the vector in the second 
source SIMD&amp;FP register from the corresponding elements in the vector 
in the first source SIMD&amp;FP register, shifts each result right one bit, 
places each result into elements of a vector, and writes the vector 
to the destination SIMD&amp;FP register.

SHSUB &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1201" header="Shift Left and Insert (immediate)" doc_id="armv8arm" token="SLI">This instruction reads each vector element in the source SIMD&amp;FP 
register, left shifts each vector element by an immediate value, 
and inserts the result into the corresponding vector element in 
the destination SIMD&amp;FP register such that the new zero bits 
created by the shift are not inserted but retain their existing 
value. Bits shifted out of the left of each vector element in 
the source register are lost.

Scalar variant
  SLI &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #&lt;shift&gt;

Vector variant
  SLI &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, #&lt;shift&gt;</hint>
			<hint page="1204" header="Signed Maximum (vector)" doc_id="armv8arm" token="SMAX">This instruction compares corresponding elements in the vectors in 
the two source SIMD&amp;FP registers, places the larger of each pair of 
signed integer values into a vector, and writes the vector to the 
destination SIMD&amp;FP register.

SMAX &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1206" header="Signed Maximum Pairwise" doc_id="armv8arm" token="SMAXP">This instruction creates a vector by concatenating the vector elements 
of the first source SIMD&amp;FP register after the vector elements of the 
second source SIMD&amp;FP register, reads each pair of adjacent vector 
elements in the two source SIMD&amp;FP registers, writes the largest of 
each pair of signed integer values into a vector, and writes the 
vector to the destination SIMD&amp;FP register.

SMAXP &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1208" header="Signed Maximum across Vector" doc_id="armv8arm" token="SMAXV">This instruction compares all the vector elements in the source 
SIMD&amp;FP register, and writes the largest of the values as a scalar 
to the destination SIMD&amp;FP register. All the values in this 
instruction are signed integer values.

SMAXV &lt;V&gt;&lt;d&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="1210" header="Signed Minimum (vector)." doc_id="armv8arm" token="SMIN">This instruction compares corresponding elements in the vectors in 
the two source SIMD&amp;FP registers, places the smaller of each of the 
two signed integer values into a vector, and writes the vector to 
the destination SIMD&amp;FP register.

SMIN &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1211" header="Signed Minimum Pairwise" doc_id="armv8arm" token="SMINP">This instruction creates a vector by concatenating the vector elements 
of the first source SIMD&amp;FP register after the vector elements of the 
second source SIMD&amp;FP register, reads each pair of adjacent vector 
elements in the two source SIMD&amp;FP registers, writes the smallest of 
each pair of signed integer values into a vector, and writes the 
vector to the destination SIMD&amp;FP register.

SMINP &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1214" header="Signed Minimum across Vector" doc_id="armv8arm" token="SMINV">This instruction compares all the vector elements in the source 
SIMD&amp;FP register, and writes the smallest of the values as a 
scalar to the destination SIMD&amp;FP register. All the values in 
this instruction are signed integer values.

SMINV &lt;V&gt;&lt;d&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="1216" header="Signed Multiply-Add Long" doc_id="armv8arm" token="SMLAL">1. By element
This instruction multiplies each vector element in the lower or upper half 
of the first source SIMD&amp;FP register by the specified vector element in 
the second source SIMD&amp;FP register, and accumulates the results with the 
vector elements of the destination SIMD&amp;FP register. The destination 
vector elements are twice as long as the elements that are multiplied. All 
the values in this instruction are signed integer values.

The SMLAL instruction extracts vector elements from the lower half of the 
first source register, while the SMLAL2 instruction extracts vector elements 
from the upper half of the first source register.

SMLAL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]

2. Vector
This instruction multiplies corresponding signed integer values in the lower 
or upper half of the vectors of the two source SIMD&amp;FP registers, and accumulates 
the results with the vector elements of the destination SIMD&amp;FP register. The 
destination vector elements are twice as long as the elements that are multiplied.

The SMLAL instruction extracts each source vector from the lower half of each 
source register, while the SMLAL2 instruction extracts each source vector from 
the upper half of each source register.

SMLAL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1216" header="Signed Multiply-Add Long" doc_id="armv8arm" token="SMLAL2">1. By element
This instruction multiplies each vector element in the lower or upper half 
of the first source SIMD&amp;FP register by the specified vector element in 
the second source SIMD&amp;FP register, and accumulates the results with the 
vector elements of the destination SIMD&amp;FP register. The destination 
vector elements are twice as long as the elements that are multiplied. All 
the values in this instruction are signed integer values.

The SMLAL instruction extracts vector elements from the lower half of the 
first source register, while the SMLAL2 instruction extracts vector elements 
from the upper half of the first source register.

SMLAL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]

2. Vector
This instruction multiplies corresponding signed integer values in the lower 
or upper half of the vectors of the two source SIMD&amp;FP registers, and accumulates 
the results with the vector elements of the destination SIMD&amp;FP register. The 
destination vector elements are twice as long as the elements that are multiplied.

The SMLAL instruction extracts each source vector from the lower half of each 
source register, while the SMLAL2 instruction extracts each source vector from 
the upper half of each source register.

SMLAL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1221" header="Signed Multiply-Subtract Long" doc_id="armv8arm" token="SMLSL">1. By element
This instruction multiplies each vector element in the lower or upper half of 
the first source SIMD&amp;FP register by the specified vector element of the second 
source SIMD&amp;FP register and subtracts the results from the vector elements of 
the destination SIMD&amp;FP register. The destination vector elements are twice as 
long as the elements that are multiplied.

The SMLSL instruction extracts vector elements from the lower half of the first
source register, while the SMLSL2 instruction extracts vector elements from 
the upper half of the first source register.

SMLSL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]

2. Vector
This instruction multiplies corresponding signed integer values in the lower or 
upper half of the vectors of the two source SIMD&amp;FP registers, and subtracts 
the results from the vector elements of the destination SIMD&amp;FP register. The 
destination vector elements are twice as long as the elements that are multiplied.

The SMLSL instruction extracts each source vector from the lower half of each 
source register, while the SMLSL2 instruction extracts each source vector from 
the upper half of each source register.

SMLSL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1221" header="Signed Multiply-Subtract Long" doc_id="armv8arm" token="SMLSL2">1. By element
This instruction multiplies each vector element in the lower or upper half of 
the first source SIMD&amp;FP register by the specified vector element of the second 
source SIMD&amp;FP register and subtracts the results from the vector elements of 
the destination SIMD&amp;FP register. The destination vector elements are twice as 
long as the elements that are multiplied.

The SMLSL instruction extracts vector elements from the lower half of the first
source register, while the SMLSL2 instruction extracts vector elements from 
the upper half of the first source register.

SMLSL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]

2. Vector
This instruction multiplies corresponding signed integer values in the lower or 
upper half of the vectors of the two source SIMD&amp;FP registers, and subtracts 
the results from the vector elements of the destination SIMD&amp;FP register. The 
destination vector elements are twice as long as the elements that are multiplied.

The SMLSL instruction extracts each source vector from the lower half of each 
source register, while the SMLSL2 instruction extracts each source vector from 
the upper half of each source register.

SMLSL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1226" header="Signed Move vector element to general-purpose register" doc_id="armv8arm" token="SMOV">This instruction reads the signed integer from the source SIMD&amp;FP register, 
sign-extends it to form a 32-bit or 64-bit value, and writes the result to 
destination general-purpose register.

32-bit variant
  SMOV &lt;Wd&gt;, &lt;Vn&gt;.&lt;Ts&gt;[&lt;index&gt;]
64-bit variant
  SMOV &lt;Xd&gt;, &lt;Vn&gt;.&lt;Ts&gt;[&lt;index&gt;]</hint>
			<hint page="1228" header="Signed Multiply Long" doc_id="armv8arm" token="SMULL">1. By element
This instruction multiplies each vector element in the lower or upper half 
of the first source SIMD&amp;FP register by the specified vector element of 
the second source SIMD&amp;FP register, places the result in a vector, and 
writes the vector to the destination SIMD&amp;FP register. The destination 
vector elements are twice as long as the elements that are multiplied.

The SMULL instruction extracts vector elements from the lower half of the 
first source register, while the SMULL2 instruction extracts vector elements 
from the upper half of the first source register.

SMULL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]

2. Vector
This instruction multiplies corresponding signed integer values in the lower 
or upper half of the vectors of the two source SIMD&amp;FP registers, places the 
results in a vector, and writes the vector to the destination SIMD&amp;FP register.

The destination vector elements are twice as long as the elements that are 
multiplied.

The SMULL instruction extracts each source vector from the lower half of each 
source register, while the SMULL2 instruction extracts each source vector from 
the upper half of each source register.

SMULL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1228" header="Signed Multiply Long" doc_id="armv8arm" token="SMULL2">1. By element
This instruction multiplies each vector element in the lower or upper half 
of the first source SIMD&amp;FP register by the specified vector element of 
the second source SIMD&amp;FP register, places the result in a vector, and 
writes the vector to the destination SIMD&amp;FP register. The destination 
vector elements are twice as long as the elements that are multiplied.

The SMULL instruction extracts vector elements from the lower half of the 
first source register, while the SMULL2 instruction extracts vector elements 
from the upper half of the first source register.

SMULL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]

2. Vector
This instruction multiplies corresponding signed integer values in the lower 
or upper half of the vectors of the two source SIMD&amp;FP registers, places the 
results in a vector, and writes the vector to the destination SIMD&amp;FP register.

The destination vector elements are twice as long as the elements that are 
multiplied.

The SMULL instruction extracts each source vector from the lower half of each 
source register, while the SMULL2 instruction extracts each source vector from 
the upper half of each source register.

SMULL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1232" header="Signed saturating Absolute value" doc_id="armv8arm" token="SQABS">This instruction reads each vector element from the source SIMD&amp;FP 
register, puts the absolute value of the result into a vector, and 
writes the vector to the destination SIMD&amp;FP register. All the 
values in this instruction are signed integer values.

Scalar variant
  SQABS &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;

Vector variant
  SQABS &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="1234" header="Signed saturating Add" doc_id="armv8arm" token="SQADD">This instruction adds the values of corresponding elements of the two 
source SIMD&amp;FP registers, places the results into a vector, and writes 
the vector to the destination SIMD&amp;FP register.

Scalar variant
  SQADD &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;

Vector variant
  SQADD &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1236" header="Signed saturating Doubling Multiply-Add Long" doc_id="armv8arm" token="SQDMLAL">1. By element
This instruction multiplies each vector element in the lower or upper half 
of the first source SIMD&amp;FP register by the specified vector element of the 
second source SIMD&amp;FP register, doubles the results, and accumulates the 
final results with the vector elements of the destination SIMD&amp;FP register. 
The destination vector elements are twice as long as the elements that are 
multiplied.

If overflow occurs with any of the results, those results are saturated. 
If saturation occurs, the cumulative saturation bit FPSR.QC is set.

The SQDMLAL instruction extracts vector elements from the lower half of the 
first source register, while the SQDMLAL2 instruction extracts vector elements 
from the upper half of the first source register.

Scalar variant
  SQDMLAL &lt;Va&gt;&lt;d&gt;, &lt;Vb&gt;&lt;n&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]

Vector variant
  SQDMLAL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]

2. Vector
This instruction multiplies corresponding signed integer values in the lower 
or upper half of the vectors of the two source SIMD&amp;FP registers, doubles the 
results, and accumulates the final results with the vector elements of the 
destination SIMD&amp;FP register. The destination vector elements are twice as 
long as the elements that are multiplied.

If overflow occurs with any of the results, those results are saturated. If 
saturation occurs, the cumulative saturation bit FPSR.QC is set.

The SQDMLAL instruction extracts each source vector from the lower half of 
each source register, while the SQDMLAL2 instruction extracts each source 
vector from the upper half of each source register.

Scalar variant
  SQDMLAL &lt;Va&gt;&lt;d&gt;, &lt;Vb&gt;&lt;n&gt;, &lt;Vb&gt;&lt;m&gt;

Vector variant
  SQDMLAL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1236" header="Signed saturating Doubling Multiply-Add Long" doc_id="armv8arm" token="SQDMLAL2">1. By element
This instruction multiplies each vector element in the lower or upper half 
of the first source SIMD&amp;FP register by the specified vector element of the 
second source SIMD&amp;FP register, doubles the results, and accumulates the 
final results with the vector elements of the destination SIMD&amp;FP register. 
The destination vector elements are twice as long as the elements that are 
multiplied.

If overflow occurs with any of the results, those results are saturated. 
If saturation occurs, the cumulative saturation bit FPSR.QC is set.

The SQDMLAL instruction extracts vector elements from the lower half of the 
first source register, while the SQDMLAL2 instruction extracts vector elements 
from the upper half of the first source register.

Vector variant
  SQDMLAL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]

2. Vector
This instruction multiplies corresponding signed integer values in the lower 
or upper half of the vectors of the two source SIMD&amp;FP registers, doubles the 
results, and accumulates the final results with the vector elements of the 
destination SIMD&amp;FP register. The destination vector elements are twice as 
long as the elements that are multiplied.

If overflow occurs with any of the results, those results are saturated. If 
saturation occurs, the cumulative saturation bit FPSR.QC is set.

The SQDMLAL instruction extracts each source vector from the lower half of 
each source register, while the SQDMLAL2 instruction extracts each source 
vector from the upper half of each source register.

Vector variant
  SQDMLAL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1243" header="Signed saturating Doubling Multiply-Subtract Long" doc_id="armv8arm" token="SQDMLSL">1. By element
This instruction multiplies each vector element in the lower or upper half of 
the first source SIMD&amp;FP register by the specified vector element of the second 
source SIMD&amp;FP register, doubles the results, and subtracts the final results 
from the vector elements of the destination SIMD&amp;FP register. The destination 
vector elements are twice as long as the elements that are multiplied. All the 
values in this instruction are signed integer values.

If overflow occurs with any of the results, those results are saturated. If 
saturation occurs, the cumulative saturation bit FPSR.QC is set.

The SQDMLSL instruction extracts vector elements from the lower half of the 
first source register, while the SQDMLSL2 instruction extracts vector elements 
from the upper half of the first source register.

Scalar variant
  SQDMLSL &lt;Va&gt;&lt;d&gt;, &lt;Vb&gt;&lt;n&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]

Vector variant
  SQDMLSL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]

2. Vector
This instruction multiplies corresponding signed integer values in the lower or 
upper half of the vectors of the two source SIMD&amp;FP registers, doubles the 
results, and subtracts the final results from the vector elements of the 
destination SIMD&amp;FP register. The destination vector elements are twice as long 
as the elements that are multiplied.

If overflow occurs with any of the results, those results are saturated. If 
saturation occurs, the cumulative saturation bit FPSR.QC is set.

The SQDMLSL instruction extracts each source vector from the lower half of each 
source register, while the SQDMLSL2 instruction extracts each source vector from 
the upper half of each source register.

Scalar variant
  SQDMLSL &lt;Va&gt;&lt;d&gt;, &lt;Vb&gt;&lt;n&gt;, &lt;Vb&gt;&lt;m&gt;

Vector variant
  SQDMLSL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1243" header="Signed saturating Doubling Multiply-Subtract Long" doc_id="armv8arm" token="SQDMLSL2">1. By element
This instruction multiplies each vector element in the lower or upper half of 
the first source SIMD&amp;FP register by the specified vector element of the second 
source SIMD&amp;FP register, doubles the results, and subtracts the final results 
from the vector elements of the destination SIMD&amp;FP register. The destination 
vector elements are twice as long as the elements that are multiplied. All the 
values in this instruction are signed integer values.

If overflow occurs with any of the results, those results are saturated. If 
saturation occurs, the cumulative saturation bit FPSR.QC is set.

The SQDMLSL instruction extracts vector elements from the lower half of the 
first source register, while the SQDMLSL2 instruction extracts vector elements 
from the upper half of the first source register.

Vector variant
  SQDMLSL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]

2. Vector
This instruction multiplies corresponding signed integer values in the lower or 
upper half of the vectors of the two source SIMD&amp;FP registers, doubles the 
results, and subtracts the final results from the vector elements of the 
destination SIMD&amp;FP register. The destination vector elements are twice as long 
as the elements that are multiplied.

If overflow occurs with any of the results, those results are saturated. If 
saturation occurs, the cumulative saturation bit FPSR.QC is set.

The SQDMLSL instruction extracts each source vector from the lower half of each 
source register, while the SQDMLSL2 instruction extracts each source vector from 
the upper half of each source register.

Vector variant
  SQDMLSL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1250" header="Signed saturating Doubling Multiply returning High half" doc_id="armv8arm" token="SQDMULH">1. By element
This instruction multiplies each vector element in the first source SIMD&amp;FP 
register by the specified vector element of the second source SIMD&amp;FP 
register, doubles the results, places the most significant half of the 
final results into a vector, and writes the vector to the destination 
SIMD&amp;FP register. The results are truncated.

SQDMULH &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]

2. Vector
This instruction multiplies the values of corresponding elements of the two 
source SIMD&amp;FP registers, doubles the results, places the most significant 
half of the final results into a vector, and writes the vector to the 
destination SIMD&amp;FP register. The results are truncated.

SQDMULH &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;</hint>
			<hint page="1255" header="Signed saturating Doubling Multiply Long" doc_id="armv8arm" token="SQDMULL">1. By element
This instruction multiplies each vector element in the lower or upper half of 
the first source SIMD&amp;FP register by the specified vector element of the 
second source SIMD&amp;FP register, doubles the results, places the final results 
in a vector, and writes the vector to the destination SIMD&amp;FP register. All 
the values in this instruction are signed integer values.

If overflow occurs with any of the results, those results are saturated. If 
saturation occurs, the cumulative saturation bit FPSR.QC is set.

The SQDMULL instruction extracts the first source vector from the lower half 
of the first source register, while the SQDMULL2 instruction extracts the 
first source vector from the upper half of the first source register.

Scalar variant
  SQDMULL &lt;Va&gt;&lt;d&gt;, &lt;Vb&gt;&lt;n&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]

Vector variant
  SQDMULL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]

1. Vector
This instruction multiplies corresponding vector elements in the lower or upper 
half of the two source SIMD&amp;FP registers, doubles the results, places the final 
results in a vector, and writes the vector to the destination SIMD&amp;FP register.
If overflow occurs with any of the results, those results are saturated. If 
saturation occurs, the cumulative saturation bit FPSR.QC is set.

The SQDMULL instruction extracts each source vector from the lower half of each 
source register, while the SQDMULL2 instruction extracts each source vector from 
the upper half of each source register.

Scalar variant
  SQDMULL &lt;Va&gt;&lt;d&gt;, &lt;Vb&gt;&lt;n&gt;, &lt;Vb&gt;&lt;m&gt;

Vector variant
  SQDMULL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1255" header="Signed saturating Doubling Multiply Long" doc_id="armv8arm" token="SQDMULL2">1. By element
This instruction multiplies each vector element in the lower or upper half of 
the first source SIMD&amp;FP register by the specified vector element of the 
second source SIMD&amp;FP register, doubles the results, places the final results 
in a vector, and writes the vector to the destination SIMD&amp;FP register. All 
the values in this instruction are signed integer values.

If overflow occurs with any of the results, those results are saturated. If 
saturation occurs, the cumulative saturation bit FPSR.QC is set.

The SQDMULL instruction extracts the first source vector from the lower half 
of the first source register, while the SQDMULL2 instruction extracts the 
first source vector from the upper half of the first source register.

Vector variant
  SQDMULL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]

1. Vector
This instruction multiplies corresponding vector elements in the lower or upper 
half of the two source SIMD&amp;FP registers, doubles the results, places the final 
results in a vector, and writes the vector to the destination SIMD&amp;FP register.
If overflow occurs with any of the results, those results are saturated. If 
saturation occurs, the cumulative saturation bit FPSR.QC is set.

The SQDMULL instruction extracts each source vector from the lower half of each 
source register, while the SQDMULL2 instruction extracts each source vector from 
the upper half of each source register.

Vector variant
  SQDMULL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1261" header="Signed saturating Negate" doc_id="armv8arm" token="SQNEG">This instruction reads each vector element from the source SIMD&amp;FP register, 
negates each value, places the result into a vector, and writes the vector 
to the destination SIMD&amp;FP register. All the values in this instruction are 
signed integer values.

Scalar variant
  SQNEG &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;

Vector variant
  SQNEG &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="1263" header="Signed saturating Rounding Doubling Multiply returning High half" doc_id="armv8arm" token="SQRDMULH">1. By element
This instruction multiplies each vector element in the first source SIMD&amp;FP 
register by the specified vector element of the second source SIMD&amp;FP register, 
doubles the results, places the most significant half of the final results 
into a vector, and writes the vector to the destination SIMD&amp;FP register.
The results are rounded.

Scalar variant
  SQRDMULH &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]

Vector variant
  SQRDMULH &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]

2. Vector
This instruction multiplies the values of corresponding elements of the two 
source SIMD&amp;FP registers, doubles the results, places the most significant 
half of the final results into a vector, and writes the vector to the 
destination SIMD&amp;FP register.
The results are rounded.

Scalar variant
  SQRDMULH &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;

Vector variant
  SQRDMULH &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1268" header="Signed saturating Rounding Shift Left" doc_id="armv8arm" token="SQRSHL">This instruction takes each vector element in the first source SIMD&amp;FP register, 
shifts it by a value from the least significant byte of the corresponding vector 
element of the second source SIMD&amp;FP register, places the results into a vector, 
and writes the vector to the destination SIMD&amp;FP register.
If the shift value is positive, the operation is a left shift. Otherwise, it is a 
right shift. The results are rounded. For truncated results, see SQSHL (register).

Scalar variant
  SQRSHL &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;

Vector variant
  SQRSHL &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1270" header="Signed saturating Rounded Shift Right Narrow" doc_id="armv8arm" token="SQRSHRN">This instruction reads each vector element in the source SIMD&amp;FP register, 
right shifts each result by an immediate value, saturates each shifted 
result to a value that is half the original width, puts the final result 
into a vector, and writes the vector to the lower or upper half of the 
destination SIMD&amp;FP register. All the values in this instruction are signed 
integer values. The destination vector elements are half as long as the 
source vector elements. The results are rounded. For truncated results, 
see SQSHRN, SQSHRN2.

The SQRSHRN instruction writes the vector to the lower half of the 
destination register and clears the upper half, while the SQRSHRN2 
instruction writes the vector to the upper half of the destination register 
without affecting the other bits of the register.

Scalar variant
  SQRSHRN &lt;Vb&gt;&lt;d&gt;, &lt;Va&gt;&lt;n&gt;, #&lt;shift&gt;

Vector variant
  SQRSHRN &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;, #&lt;shift&gt;</hint>
			<hint page="1270" header="Signed saturating Rounded Shift Right Narrow" doc_id="armv8arm" token="SQRSHRN2">This instruction reads each vector element in the source SIMD&amp;FP register, 
right shifts each result by an immediate value, saturates each shifted 
result to a value that is half the original width, puts the final result 
into a vector, and writes the vector to the lower or upper half of the 
destination SIMD&amp;FP register. All the values in this instruction are signed 
integer values. The destination vector elements are half as long as the 
source vector elements. The results are rounded. For truncated results, 
see SQSHRN, SQSHRN2.

The SQRSHRN instruction writes the vector to the lower half of the 
destination register and clears the upper half, while the SQRSHRN2 
instruction writes the vector to the upper half of the destination register 
without affecting the other bits of the register.

Vector variant
  SQRSHRN2 &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;, #&lt;shift&gt;</hint>
			<hint page="1273" header="Signed saturating Rounded Shift Right Unsigned Narrow" doc_id="armv8arm" token="SQRSHRUN">This instruction reads each signed integer value in the vector of the 
source SIMD&amp;FP register, right shifts each value by an immediate value, 
saturates the result to an unsigned integer value that is half the 
original width, places the final result into a vector, and writes the 
vector to the destination SIMD&amp;FP register. The results are rounded. 
For truncated results, see SQSHRUN, SQSHRUN2.

The SQRSHRUN instruction writes the vector to the lower half of the 
destination register and clears the upper half, while the SQRSHRUN2 
instruction writes the vector to the upper half of the destination 
register without affecting the other bits of the register.

Scalar variant
  SQRSHRUN &lt;Vb&gt;&lt;d&gt;, &lt;Va&gt;&lt;n&gt;, #&lt;shift&gt;

Vector variant
  SQRSHRUN &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;, #&lt;shift&gt;</hint>
			<hint page="1273" header="Signed saturating Rounded Shift Right Unsigned Narrow" doc_id="armv8arm" token="SQRSHRUN2">This instruction reads each signed integer value in the vector of the 
source SIMD&amp;FP register, right shifts each value by an immediate value, 
saturates the result to an unsigned integer value that is half the 
original width, places the final result into a vector, and writes the 
vector to the destination SIMD&amp;FP register. The results are rounded. 
For truncated results, see SQSHRUN, SQSHRUN2.

The SQRSHRUN instruction writes the vector to the lower half of the 
destination register and clears the upper half, while the SQRSHRUN2 
instruction writes the vector to the upper half of the destination 
register without affecting the other bits of the register.

Vector variant
  SQRSHRUN2 &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;, #&lt;shift&gt;</hint>
			<hint page="1276" header="Signed saturating Shift Left" doc_id="armv8arm" token="SQSHL">1. Immediate
This instruction reads each vector element in the source SIMD&amp;FP register, 
shifts each result by an immediate value, places the final result in a 
vector, and writes the vector to the destination SIMD&amp;FP register. 
The results are truncated. 

Scalar variant
  SQSHL &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #&lt;shift&gt;

Vector variant
  SQSHL &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, #&lt;shift&gt;

2. Register
This instruction takes each element in the vector of the first source 
SIMD&amp;FP register, shifts each element by a value from the least significant 
byte of the corresponding element of the second source SIMD&amp;FP register, 
places the results in a vector, and writes the vector to the destination 
SIMD&amp;FP register.

If the shift value is positive, the operation is a left shift. Otherwise, 
it is a right shift. The results are truncated.

Scalar variant
  SQSHL &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;

Vector variant
  SQSHL &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1281" header="Signed saturating Shift Left Unsigned" doc_id="armv8arm" token="SQSHLU">This instruction reads each signed integer value in the vector of 
the source SIMD&amp;FP register, shifts each value by an immediate 
value, saturates the shifted result to an unsigned integer value, 
places the result in a vector, and writes the vector to the 
destination SIMD&amp;FP register. The results are truncated.

Scalar variant
  SQSHLU &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #&lt;shift&gt;

Vector variant
  SQSHLU &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, #&lt;shift&gt;</hint>
			<hint page="1284" header="Signed saturating Shift Right Narrow" doc_id="armv8arm" token="SQSHRN">This instruction reads each vector element in the source SIMD&amp;FP register, 
right shifts and truncates each result by an immediate value, saturates 
each shifted result to a value that is half the original width, puts the 
final result into a vector, and writes the vector to the lower or upper 
half of the destination SIMD&amp;FP register. All the values in this 
instruction are signed integer values. The destination vector elements 
are half as long as the source vector elements.

The SQSHRN instruction writes the vector to the lower half of the 
destination register and clears the upper half, while the SQSHRN2 
instruction writes the vector to the upper half of the destination 
register without affecting the other bits of the register.

Scalar variant
SQSHRN &lt;Vb&gt;&lt;d&gt;, &lt;Va&gt;&lt;n&gt;, #&lt;shift&gt;

Vector variant
SQSHRN &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;, #&lt;shift&gt;</hint>
			<hint page="1284" header="Signed saturating Shift Right Narrow" doc_id="armv8arm" token="SQSHRN2">This instruction reads each vector element in the source SIMD&amp;FP register, 
right shifts and truncates each result by an immediate value, saturates 
each shifted result to a value that is half the original width, puts the 
final result into a vector, and writes the vector to the lower or upper 
half of the destination SIMD&amp;FP register. All the values in this 
instruction are signed integer values. The destination vector elements 
are half as long as the source vector elements.

The SQSHRN instruction writes the vector to the lower half of the 
destination register and clears the upper half, while the SQSHRN2 
instruction writes the vector to the upper half of the destination 
register without affecting the other bits of the register.

Vector variant
SQSHRN2 &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;, #&lt;shift&gt;</hint>
			<hint page="1287" header="Signed saturating Shift Right Unsigned Narrow" doc_id="armv8arm" token="SQSHRUN">This instruction reads each signed integer value in the vector of the 
source SIMD&amp;FP register, right shifts each value by an immediate value, 
saturates the result to an unsigned integer value that is half the 
original width, places the final result into a vector, and writes the 
vector to the destination SIMD&amp;FP register. The results are truncated. 

The SQSHRUN instruction writes the vector to the lower half of the 
destination register and clears the upper half, while the SQSHRUN2 
instruction writes the vector to the upper half of the destination 
register without affecting the other bits of the register.

Scalar variant
  SQSHRUN &lt;Vb&gt;&lt;d&gt;, &lt;Va&gt;&lt;n&gt;, #&lt;shift&gt;

Vector variant
  SQSHRUN &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;, #&lt;shift&gt;</hint>
			<hint page="1287" header="Signed saturating Shift Right Unsigned Narrow" doc_id="armv8arm" token="SQSHRUN2">This instruction reads each signed integer value in the vector of the 
source SIMD&amp;FP register, right shifts each value by an immediate value, 
saturates the result to an unsigned integer value that is half the 
original width, places the final result into a vector, and writes the 
vector to the destination SIMD&amp;FP register. The results are truncated. 

The SQSHRUN instruction writes the vector to the lower half of the 
destination register and clears the upper half, while the SQSHRUN2 
instruction writes the vector to the upper half of the destination 
register without affecting the other bits of the register.

Vector variant
  SQSHRUN2 &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;, #&lt;shift&gt;</hint>
			<hint page="1290" header="Signed saturating Subtract" doc_id="armv8arm" token="SQSUB">This instruction subtracts the element values of the second source SIMD&amp;FP 
register from the corresponding element values of the first source SIMD&amp;FP 
register, places the results into a vector, and writes the vector to the
destination SIMD&amp;FP register.

Scalar variant
  SQSUB &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;

Vector variant
  SQSUB &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1292" header="Signed saturating extract Narrow" doc_id="armv8arm" token="SQXTN">This instruction reads each vector element from the source SIMD&amp;FP register, 
saturates the value to half the original width, places the result into a 
vector, and writes the vector to the lower or upper half of the destination 
SIMD&amp;FP register. The destination vector elements are half as long as the 
source vector elements. All the values in this instruction are signed 
integer values.

If overflow occurs with any of the results, those results are saturated. 
If saturation occurs, the cumulative saturation bit FPSR.QC is set.

The SQXTN instruction writes the vector to the lower half of the destination 
register and clears the upper half, while the SQXTN2 instruction writes the 
vector to the upper half of the destination register without affecting the 
other bits of the register.

Scalar variant
SQXTN &lt;Vb&gt;&lt;d&gt;, &lt;Va&gt;&lt;n&gt;

Vector variant
SQXTN &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;</hint>
			<hint page="1292" header="Signed saturating extract Narrow" doc_id="armv8arm" token="SQXTN2">This instruction reads each vector element from the source SIMD&amp;FP register, 
saturates the value to half the original width, places the result into a 
vector, and writes the vector to the lower or upper half of the destination 
SIMD&amp;FP register. The destination vector elements are half as long as the 
source vector elements. All the values in this instruction are signed 
integer values.

If overflow occurs with any of the results, those results are saturated. 
If saturation occurs, the cumulative saturation bit FPSR.QC is set.

The SQXTN instruction writes the vector to the lower half of the destination 
register and clears the upper half, while the SQXTN2 instruction writes the 
vector to the upper half of the destination register without affecting the 
other bits of the register.

Vector variant
SQXTN2 &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;</hint>
			<hint page="1295" header="Signed saturating extract Unsigned Narrow" doc_id="armv8arm" token="SQXTUN">This instruction reads each signed integer value in the vector of the source 
SIMD&amp;FP register, saturates the value to an unsigned integer value that is 
half the original width, places the result into a vector, and writes the 
vector to the lower or upper half of the destination SIMD&amp;FP register. The 
destination vector elements are half as long as the source vector elements.

If saturation occurs, the cumulative saturation bit FPSR.QC is set.

The SQXTUN instruction writes the vector to the lower half of the destination 
register and clears the upper half, while the SQXTUN2 instruction writes the 
vector to the upper half of the destination register without affecting the 
other bits of the register.

Scalar variant
  SQXTUN &lt;Vb&gt;&lt;d&gt;, &lt;Va&gt;&lt;n&gt;

Vector variant
  SQXTUN &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;</hint>
			<hint page="1295" header="Signed saturating extract Unsigned Narrow" doc_id="armv8arm" token="SQXTUN2">This instruction reads each signed integer value in the vector of the source 
SIMD&amp;FP register, saturates the value to an unsigned integer value that is 
half the original width, places the result into a vector, and writes the 
vector to the lower or upper half of the destination SIMD&amp;FP register. The 
destination vector elements are half as long as the source vector elements.

If saturation occurs, the cumulative saturation bit FPSR.QC is set.

The SQXTUN instruction writes the vector to the lower half of the destination 
register and clears the upper half, while the SQXTUN2 instruction writes the 
vector to the upper half of the destination register without affecting the 
other bits of the register.

Vector variant
  SQXTUN2 &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;</hint>
			<hint page="1298" header="Signed Rounding Halving Add" doc_id="armv8arm" token="SRHADD">This instruction adds corresponding signed integer values from the two 
source SIMD&amp;FP registers, shifts each result right one bit, places the 
results into a vector, and writes the vector to the destination SIMD&amp;FP 
register. The results are rounded.

SRHADD &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1300" header="Shift Right and Insert" doc_id="armv8arm" token="SRI">This instruction reads each vector element in the source SIMD&amp;FP register, 
right shifts each vector element by an immediate value, and inserts the 
result into the corresponding vector element in the destination SIMD&amp;FP 
register such that the new zero bits created by the shift are not inserted 
but retain their existing value. Bits shifted out of the right of each 
vector element of the source register are lost.

SRI &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #&lt;shift&gt;</hint>
			<hint page="1303" header="Signed Rounding Shift Left" doc_id="armv8arm" token="SRSHL">This instruction takes each signed integer value in the vector of the first 
source SIMD&amp;FP register, shifts it by a value from the least significant byte 
of the corresponding element of the second source SIMD&amp;FP register, places 
the results in a vector, and writes the vector to the destination SIMD&amp;FP 
register.

If the shift value is positive, the operation is a left shift. If the shift 
value is negative, it is a rounding right shift.

SRSHL &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;</hint>
			<hint page="1305" header="Signed Rounding Shift Right" doc_id="armv8arm" token="SRSHR">This instruction reads each vector element in the source SIMD&amp;FP register, 
right shifts each result by an immediate value, places the final result 
into a vector, and writes the vector to the destination SIMD&amp;FP register. 
All the values in this instruction are signed integer values. 
The results are rounded.

SRSHR &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #&lt;shift&gt;</hint>
			<hint page="1307" header="Signed Rounding Shift Right and Accumulate" doc_id="armv8arm" token="SRSRA">This instruction reads each vector element in the source SIMD&amp;FP register, 
right shifts each result by an immediate value, and accumulates the final 
results with the vector elements of the destination SIMD&amp;FP register. All 
the values in this instruction are signed integer values. 
The results are rounded.

SRSRA &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #&lt;shift&gt;</hint>
			<hint page="1309" header="Signed Shift Left" doc_id="armv8arm" token="SSHL">This instruction takes each signed integer value in the vector of the first 
source SIMD&amp;FP register, shifts each value by a value from the least 
significant byte of the corresponding element of the second source SIMD&amp;FP 
register, places the results in a vector, and writes the vector to the 
destination SIMD&amp;FP register.

If the shift value is positive, the operation is a left shift. If the shift 
value is negative, it is a truncating right shift.

Scalar variant
  SSHL &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;

Vector variant
  SSHL &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1312" header="Signed Shift Left Long" doc_id="armv8arm" token="SSHLL">This instruction reads each vector element from the source SIMD&amp;FP register, 
left shifts each vector element by the specified shift amount, places the 
result into a vector, and writes the vector to the destination SIMD&amp;FP register. 
The destination vector elements are twice as long as the source vector elements. 
All the values in this instruction are signed integer values.

The SSHLL instruction extracts vector elements from the lower half of the source 
register, while the SSHLL2 instruction extracts vector elements from the upper 
half of the source register.

SSHLL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, #&lt;shift&gt;</hint>
			<hint page="1312" header="Signed Shift Left Long" doc_id="armv8arm" token="SSHLL2">This instruction reads each vector element from the source SIMD&amp;FP register, 
left shifts each vector element by the specified shift amount, places the 
result into a vector, and writes the vector to the destination SIMD&amp;FP register. 
The destination vector elements are twice as long as the source vector elements. 
All the values in this instruction are signed integer values.

The SSHLL instruction extracts vector elements from the lower half of the source 
register, while the SSHLL2 instruction extracts vector elements from the upper 
half of the source register.

SSHLL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, #&lt;shift&gt;</hint>
			<hint page="1313" header="Signed Shift Right" doc_id="armv8arm" token="SSHR">This instruction reads each vector element in the source SIMD&amp;FP register, 
right shifts each result by an immediate value, places the final result 
into a vector, and writes the vector to the destination SIMD&amp;FP register. 
All the values in this instruction are signed integer values. 
The results are truncated. 

Scalar variant
  SSHR &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #&lt;shift&gt;

Vector variant
  SSHR &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, #&lt;shift&gt;</hint>
			<hint page="1315" header="Signed Shift Right and Accumulate" doc_id="armv8arm" token="SSRA">This instruction reads each vector element in the source SIMD&amp;FP register, 
right shifts each result by an immediate value, and accumulates the final 
results with the vector elements of the destination SIMD&amp;FP register. All 
the values in this instruction are signed integer values. 
The results are truncated.

Scalar variant
  SSRA &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #&lt;shift&gt;

Vector variant
  SSRA &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, #&lt;shift&gt;</hint>
			<hint page="1317" header="Signed Subtract Long" doc_id="armv8arm" token="SSUBL">This instruction subtracts each vector element in the lower or upper half of 
the second source SIMD&amp;FP register from the corresponding vector element of 
the first source SIMD&amp;FP register, places the results into a vector, and writes 
the vector to the destination SIMD&amp;FP register. All the values in this 
instruction are signed integer values. The destination vector elements are 
twice as long as the source vector elements.

The SSUBL instruction extracts each source vector from the lower half of each 
source register, while the SSUBL2 instruction extracts each source vector from 
the upper half of each source register.

SSUBL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1317" header="Signed Subtract Long" doc_id="armv8arm" token="SSUBL2">This instruction subtracts each vector element in the lower or upper half of 
the second source SIMD&amp;FP register from the corresponding vector element of 
the first source SIMD&amp;FP register, places the results into a vector, and writes 
the vector to the destination SIMD&amp;FP register. All the values in this 
instruction are signed integer values. The destination vector elements are 
twice as long as the source vector elements.

The SSUBL instruction extracts each source vector from the lower half of each 
source register, while the SSUBL2 instruction extracts each source vector from 
the upper half of each source register.

SSUBL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1319" header="Signed Subtract Wide" doc_id="armv8arm" token="SSUBW">This instruction subtracts each vector element in the lower or upper half of 
the second source SIMD&amp;FP register from the corresponding vector element in 
the first source SIMD&amp;FP register, places the result in a vector, and writes 
the vector to the SIMD&amp;FP destination register. All the values in this 
instruction are signed integer values.

The SSUBW instruction extracts the second source vector from the lower half 
of the second source register, while the SSUBW2 instruction extracts the 
second source vector from the upper half of the second source register.

SSUBW &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Ta&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1319" header="Signed Subtract Wide" doc_id="armv8arm" token="SSUBW2">This instruction subtracts each vector element in the lower or upper half of 
the second source SIMD&amp;FP register from the corresponding vector element in 
the first source SIMD&amp;FP register, places the result in a vector, and writes 
the vector to the SIMD&amp;FP destination register. All the values in this 
instruction are signed integer values.

The SSUBW instruction extracts the second source vector from the lower half 
of the second source register, while the SSUBW2 instruction extracts the 
second source vector from the upper half of the second source register.

SSUBW2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Ta&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1321" header="Store single-element structures from one, two, three, or four registers" doc_id="armv8arm" token="ST1">1. Multiple structures
This instruction stores elements to memory from one, two, three, or four SIMD&amp;FP 
registers, without interleaving. Every element of each register is stored.

No offset:
  One register variant:    ST1 { &lt;Vt&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;]
  Two registers variant:   ST1 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;]
  Three registers variant: ST1 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt;, &lt;Vt3&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;]
  Four registers variant:  ST1 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt;, &lt;Vt3&gt;.&lt;T&gt;, &lt;Vt4&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;]

Post-index:
  One register, immediate offset variant:    ST1 { &lt;Vt&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;imm&gt;
  One register, register offset variant:     ST1 { &lt;Vt&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;Xm&gt;
  Two registers, immediate offset variant:   ST1 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;imm&gt;
  Two registers, register offset variant:    ST1 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;Xm&gt;
  Three registers, immediate offset variant: ST1 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt;, &lt;Vt3&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;imm&gt;
  Three registers, register offset variant:  ST1 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt;, &lt;Vt3&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;Xm&gt;
  Four registers, immediate offset variant:  ST1 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt;, &lt;Vt3&gt;.&lt;T&gt;, &lt;Vt4&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;imm&gt;
  Four registers, register offset variant:   ST1 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt;, &lt;Vt3&gt;.&lt;T&gt;, &lt;Vt4&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;Xm&gt;

2. Single structure
This instruction stores the specified element of a SIMD&amp;FP register to memory.

No offset:
  8-bit variant:  ST1 { &lt;Vt&gt;.B }[&lt;index&gt;], [&lt;Xn|SP&gt;]
  16-bit variant: ST1 { &lt;Vt&gt;.H }[&lt;index&gt;], [&lt;Xn|SP&gt;]
  32-bit variant: ST1 { &lt;Vt&gt;.S }[&lt;index&gt;], [&lt;Xn|SP&gt;]
  64-bit variant: ST1 { &lt;Vt&gt;.D }[&lt;index&gt;], [&lt;Xn|SP&gt;]

Post-index:
  8-bit, immediate offset variant:  ST1 { &lt;Vt&gt;.B }[&lt;index&gt;], [&lt;Xn|SP&gt;], #1
  8-bit, register offset variant:   ST1 { &lt;Vt&gt;.B }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;
  16-bit, immediate offset variant: ST1 { &lt;Vt&gt;.H }[&lt;index&gt;], [&lt;Xn|SP&gt;], #2
  16-bit, register offset variant:  ST1 { &lt;Vt&gt;.H }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;
  32-bit, immediate offset variant: ST1 { &lt;Vt&gt;.S }[&lt;index&gt;], [&lt;Xn|SP&gt;], #4
  32-bit, register offset variant:  ST1 { &lt;Vt&gt;.S }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;
  64-bit, immediate offset variant: ST1 { &lt;Vt&gt;.D }[&lt;index&gt;], [&lt;Xn|SP&gt;], #8
  64-bit, register offset variant:  ST1 { &lt;Vt&gt;.D }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;</hint>
			<hint page="1329" header="Store 2-element structures from two registers" doc_id="armv8arm" token="ST2">1. Multiple structures
This instruction stores multiple 2-element structures from two SIMD&amp;FP registers 
to memory, with interleaving. Every element of each register is stored.

No offset:
  ST2 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;]

Post-index:
  Immediate offset variant: ST2 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;imm&gt;
  Register offset variant:  ST2 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;Xm&gt;


2. Single structure
This instruction stores a 2-element structure to memory from corresponding elements 
of two SIMD&amp;FP registers.

No offset:
  8-bit variant:  ST2 { &lt;Vt&gt;.B, &lt;Vt2&gt;.B }[&lt;index&gt;], [&lt;Xn|SP&gt;]
  16-bit variant: ST2 { &lt;Vt&gt;.H, &lt;Vt2&gt;.H }[&lt;index&gt;], [&lt;Xn|SP&gt;]
  32-bit variant: ST2 { &lt;Vt&gt;.S, &lt;Vt2&gt;.S }[&lt;index&gt;], [&lt;Xn|SP&gt;]
  64-bit variant: ST2 { &lt;Vt&gt;.D, &lt;Vt2&gt;.D }[&lt;index&gt;], [&lt;Xn|SP&gt;]

Post-index:
  8-bit, immediate offset variant:  ST2 { &lt;Vt&gt;.B, &lt;Vt2&gt;.B }[&lt;index&gt;], [&lt;Xn|SP&gt;], #2
  8-bit, register offset variant:   ST2 { &lt;Vt&gt;.B, &lt;Vt2&gt;.B }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;
  16-bit, immediate offset variant: ST2 { &lt;Vt&gt;.H, &lt;Vt2&gt;.H }[&lt;index&gt;], [&lt;Xn|SP&gt;], #4
  16-bit, register offset variant:  ST2 { &lt;Vt&gt;.H, &lt;Vt2&gt;.H }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;
  32-bit, immediate offset variant: ST2 { &lt;Vt&gt;.S, &lt;Vt2&gt;.S }[&lt;index&gt;], [&lt;Xn|SP&gt;], #8
  32-bit, register offset variant:  ST2 { &lt;Vt&gt;.S, &lt;Vt2&gt;.S }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;
  64-bit, immediate offset variant: ST2 { &lt;Vt&gt;.D, &lt;Vt2&gt;.D }[&lt;index&gt;], [&lt;Xn|SP&gt;], #16
  64-bit, register offset variant:  ST2 { &lt;Vt&gt;.D, &lt;Vt2&gt;.D }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;</hint>
			<hint page="1336" header="Store 3-element structures from three registers" doc_id="armv8arm" token="ST3">1. Multiple structures
This instruction stores multiple 3-element structures to memory from three SIMD&amp;FP registers, 
with interleaving. Every element of each register is stored.

No offset:
  ST3 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt;, &lt;Vt3&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;]

Post-index:
  Immediate offset variant: ST3 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt;, &lt;Vt3&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;imm&gt;
  Register offset variant:  ST3 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt;, &lt;Vt3&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;Xm&gt;


2. Single structure
This instruction stores a 3-element structure to memory from corresponding elements of three 
SIMD&amp;FP registers.

No offset:
  8-bit variant:  ST3 { &lt;Vt&gt;.B, &lt;Vt2&gt;.B, &lt;Vt3&gt;.B }[&lt;index&gt;], [&lt;Xn|SP&gt;]
  16-bit variant: ST3 { &lt;Vt&gt;.H, &lt;Vt2&gt;.H, &lt;Vt3&gt;.H }[&lt;index&gt;], [&lt;Xn|SP&gt;]
  32-bit variant: ST3 { &lt;Vt&gt;.S, &lt;Vt2&gt;.S, &lt;Vt3&gt;.S }[&lt;index&gt;], [&lt;Xn|SP&gt;]
  64-bit variant: ST3 { &lt;Vt&gt;.D, &lt;Vt2&gt;.D, &lt;Vt3&gt;.D }[&lt;index&gt;], [&lt;Xn|SP&gt;]

Post-index:
  8-bit, immediate offset variant:  ST3 { &lt;Vt&gt;.B, &lt;Vt2&gt;.B, &lt;Vt3&gt;.B }[&lt;index&gt;], [&lt;Xn|SP&gt;], #3
  8-bit, register offset variant:   ST3 { &lt;Vt&gt;.B, &lt;Vt2&gt;.B, &lt;Vt3&gt;.B }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;
  16-bit, immediate offset variant: ST3 { &lt;Vt&gt;.H, &lt;Vt2&gt;.H, &lt;Vt3&gt;.H }[&lt;index&gt;], [&lt;Xn|SP&gt;], #6
  16-bit, register offset variant:  ST3 { &lt;Vt&gt;.H, &lt;Vt2&gt;.H, &lt;Vt3&gt;.H }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;
  32-bit, immediate offset variant: ST3 { &lt;Vt&gt;.S, &lt;Vt2&gt;.S, &lt;Vt3&gt;.S }[&lt;index&gt;], [&lt;Xn|SP&gt;], #12
  32-bit, register offset variant:  ST3 { &lt;Vt&gt;.S, &lt;Vt2&gt;.S, &lt;Vt3&gt;.S }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;
  64-bit, immediate offset variant: ST3 { &lt;Vt&gt;.D, &lt;Vt2&gt;.D, &lt;Vt3&gt;.D }[&lt;index&gt;], [&lt;Xn|SP&gt;], #24
  64-bit, register offset variant:  ST3 { &lt;Vt&gt;.D, &lt;Vt2&gt;.D, &lt;Vt3&gt;.D }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;</hint>
			<hint page="1343" header="Store 4-element structures from four registers" doc_id="armv8arm" token="ST4">1. Multiple structures
This instruction stores multiple 4-element structures to memory from four SIMD&amp;FP registers, 
with interleaving. Every element of each register is stored.

No offset:
  ST4 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt;, &lt;Vt3&gt;.&lt;T&gt;, &lt;Vt4&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;]

Post-index:
  Immediate offset variant: ST4 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt;, &lt;Vt3&gt;.&lt;T&gt;, &lt;Vt4&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;imm&gt;
  Register offset variant: ST4 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt;, &lt;Vt3&gt;.&lt;T&gt;, &lt;Vt4&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;Xm&gt;

2. Single structure
This instruction stores a 4-element structure to memory from corresponding elements of four 
SIMD&amp;FP registers.

No offset:
  8-bit variant:  ST4 { &lt;Vt&gt;.B, &lt;Vt2&gt;.B, &lt;Vt3&gt;.B, &lt;Vt4&gt;.B }[&lt;index&gt;],
  16-bit variant: ST4 { &lt;Vt&gt;.H, &lt;Vt2&gt;.H, &lt;Vt3&gt;.H, &lt;Vt4&gt;.H }[&lt;index&gt;],
  32-bit variant: ST4 { &lt;Vt&gt;.S, &lt;Vt2&gt;.S, &lt;Vt3&gt;.S, &lt;Vt4&gt;.S }[&lt;index&gt;], [&lt;Xn|SP&gt;]
  64-bit variant: ST4 { &lt;Vt&gt;.D, &lt;Vt2&gt;.D, &lt;Vt3&gt;.D, &lt;Vt4&gt;.D }[&lt;index&gt;], [&lt;Xn|SP&gt;]

Post-index:
  8-bit, immediate offset variant:  ST4 { &lt;Vt&gt;.B, &lt;Vt2&gt;.B, &lt;Vt3&gt;.B, &lt;Vt4&gt;.B }[&lt;index&gt;], [&lt;Xn|SP&gt;], #4
  8-bit, register offset variant:   ST4 { &lt;Vt&gt;.B, &lt;Vt2&gt;.B, &lt;Vt3&gt;.B, &lt;Vt4&gt;.B }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;
  16-bit, immediate offset variant: ST4 { &lt;Vt&gt;.H, &lt;Vt2&gt;.H, &lt;Vt3&gt;.H, &lt;Vt4&gt;.H }[&lt;index&gt;], [&lt;Xn|SP&gt;], #8
  16-bit, register offset variant:  ST4 { &lt;Vt&gt;.H, &lt;Vt2&gt;.H, &lt;Vt3&gt;.H, &lt;Vt4&gt;.H }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;
  32-bit, immediate offset variant: ST4 { &lt;Vt&gt;.S, &lt;Vt2&gt;.S, &lt;Vt3&gt;.S, &lt;Vt4&gt;.S }[&lt;index&gt;], [&lt;Xn|SP&gt;], #16
  32-bit, register offset variant:  ST4 { &lt;Vt&gt;.S, &lt;Vt2&gt;.S, &lt;Vt3&gt;.S, &lt;Vt4&gt;.S }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;
  64-bit, immediate offset variant: ST4 { &lt;Vt&gt;.D, &lt;Vt2&gt;.D, &lt;Vt3&gt;.D, &lt;Vt4&gt;.D }[&lt;index&gt;], [&lt;Xn|SP&gt;], #32
  64-bit, register offset variant:  ST4 { &lt;Vt&gt;.D, &lt;Vt2&gt;.D, &lt;Vt3&gt;.D, &lt;Vt4&gt;.D }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;</hint>
			<hint page="1350" header="Store Pair of SIMD&amp;FP registers, with Non-temporal hint" doc_id="armv8arm" token="STNP">This instruction stores a pair of SIMD&amp;FP registers to memory, issuing a hint 
to the memory system that the access is non-temporal. The address used for the 
store is calculated from an address from a base register value and an immediate 
offset.

32-bit variant
  STNP &lt;St1&gt;, &lt;St2&gt;, [&lt;Xn|SP&gt;{, #&lt;imm&gt;}]
64-bit variant
  STNP &lt;Dt1&gt;, &lt;Dt2&gt;, [&lt;Xn|SP&gt;{, #&lt;imm&gt;}]
128-bit variant
  STNP &lt;Qt1&gt;, &lt;Qt2&gt;, [&lt;Xn|SP&gt;{, #&lt;imm&gt;}]</hint>
			<hint page="1352" header="Store Pair of SIMD&amp;FP registers" doc_id="armv8arm" token="STP">This instruction stores a pair of SIMD&amp;FP registers to memory. The address used 
for the store is calculated from a base register value and an immediate offset.

Post-index:
  32-bit variant:  STP &lt;St1&gt;, &lt;St2&gt;, [&lt;Xn|SP&gt;], #&lt;imm&gt;
  64-bit variant:  STP &lt;Dt1&gt;, &lt;Dt2&gt;, [&lt;Xn|SP&gt;], #&lt;imm&gt;
  128-bit variant: STP &lt;Qt1&gt;, &lt;Qt2&gt;, [&lt;Xn|SP&gt;], #&lt;imm&gt;

Pre-index:
  32-bit variant:  STP &lt;St1&gt;, &lt;St2&gt;, [&lt;Xn|SP&gt;, #&lt;imm&gt;]!
  64-bit variant:  STP &lt;Dt1&gt;, &lt;Dt2&gt;, [&lt;Xn|SP&gt;, #&lt;imm&gt;]!
  128-bit variant: STP &lt;Qt1&gt;, &lt;Qt2&gt;, [&lt;Xn|SP&gt;, #&lt;imm&gt;]!

Signed offset:
  32-bit variant:  STP &lt;St1&gt;, &lt;St2&gt;, [&lt;Xn|SP&gt;{, #&lt;imm&gt;}]
  64-bit variant:  STP &lt;Dt1&gt;, &lt;Dt2&gt;, [&lt;Xn|SP&gt;{, #&lt;imm&gt;}]
  128-bit variant: STP &lt;Qt1&gt;, &lt;Qt2&gt;, [&lt;Xn|SP&gt;{, #&lt;imm&gt;}]</hint>
			<hint page="1355" header="Store SIMD&amp;FP register" doc_id="armv8arm" token="STR">1. Immediate
This instruction stores a single SIMD&amp;FP register to memory. The address 
that is used for the store is calculated from a base register value and 
an immediate offset.

Post-index:
  8-bit variant:   STR &lt;Bt&gt;, [&lt;Xn|SP&gt;], #&lt;simm&gt;
  16-bit variant:  STR &lt;Ht&gt;, [&lt;Xn|SP&gt;], #&lt;simm&gt;
  32-bit variant:  STR &lt;St&gt;, [&lt;Xn|SP&gt;], #&lt;simm&gt;
  64-bit variant:  STR &lt;Dt&gt;, [&lt;Xn|SP&gt;], #&lt;simm&gt;
  128-bit variant: STR &lt;Qt&gt;, [&lt;Xn|SP&gt;], #&lt;simm&gt;

Pre-index:
  8-bit variant:   STR &lt;Bt&gt;, [&lt;Xn|SP&gt;, #&lt;simm&gt;]!
  16-bit variant:  STR &lt;Ht&gt;, [&lt;Xn|SP&gt;, #&lt;simm&gt;]!
  32-bit variant:  STR &lt;St&gt;, [&lt;Xn|SP&gt;, #&lt;simm&gt;]!
  64-bit variant:  STR &lt;Dt&gt;, [&lt;Xn|SP&gt;, #&lt;simm&gt;]!
  128-bit variant: STR &lt;Qt&gt;, [&lt;Xn|SP&gt;, #&lt;simm&gt;]!

Unsigned offset:
  8-bit variant:   STR &lt;Bt&gt;, [&lt;Xn|SP&gt;{, #&lt;pimm&gt;}]
  16-bit variant:  STR &lt;Ht&gt;, [&lt;Xn|SP&gt;{, #&lt;pimm&gt;}]
  32-bit variant:  STR &lt;St&gt;, [&lt;Xn|SP&gt;{, #&lt;pimm&gt;}]
  64-bit variant:  STR &lt;Dt&gt;, [&lt;Xn|SP&gt;{, #&lt;pimm&gt;}]
  128-bit variant: STR &lt;Qt&gt;, [&lt;Xn|SP&gt;{, #&lt;pimm&gt;}]

2. Register
This instruction stores a single SIMD&amp;FP register to memory. The address that is used 
for the store is calculated from a base register value and an offset register value. 
The offset can be optionally shifted and extended.

8-bit variant:   STR &lt;Bt&gt;, [&lt;Xn|SP&gt;, (&lt;Wm&gt;|&lt;Xm&gt;), &lt;extend&gt; {&lt;amount&gt;}]
8-bit variant:   STR &lt;Bt&gt;, [&lt;Xn|SP&gt;, &lt;Xm&gt;{, LSL &lt;amount&gt;}]
16-bit variant:  STR &lt;Ht&gt;, [&lt;Xn|SP&gt;, (&lt;Wm&gt;|&lt;Xm&gt;){, &lt;extend&gt; {&lt;amount&gt;}}]
32-bit variant:  STR &lt;St&gt;, [&lt;Xn|SP&gt;, (&lt;Wm&gt;|&lt;Xm&gt;){, &lt;extend&gt; {&lt;amount&gt;}}]
64-bit variant:  STR &lt;Dt&gt;, [&lt;Xn|SP&gt;, (&lt;Wm&gt;|&lt;Xm&gt;){, &lt;extend&gt; {&lt;amount&gt;}}]
128-bit variant: STR &lt;Qt&gt;, [&lt;Xn|SP&gt;, (&lt;Wm&gt;|&lt;Xm&gt;){, &lt;extend&gt; {&lt;amount&gt;}}]</hint>
			<hint page="1362" header="Store SIMD&amp;FP register (unscaled offset)" doc_id="armv8arm" token="STUR">This instruction stores a single SIMD&amp;FP register to memory. The address that 
is used for the store is calculated from a base register value and an optional 
immediate offset.

8-bit variant: 
  STUR &lt;Bt&gt;, [&lt;Xn|SP&gt;{, #&lt;simm&gt;}]
16-bit variant
  STUR &lt;Ht&gt;, [&lt;Xn|SP&gt;{, #&lt;simm&gt;}]
32-bit variant
  STUR &lt;St&gt;, [&lt;Xn|SP&gt;{, #&lt;simm&gt;}]
64-bit variant
  STUR &lt;Dt&gt;, [&lt;Xn|SP&gt;{, #&lt;simm&gt;}]
128-bit variant
  STUR &lt;Qt&gt;, [&lt;Xn|SP&gt;{, #&lt;simm&gt;}]</hint>
			<hint page="1364" header="Subtract (vector)" doc_id="armv8arm" token="SUB">This instruction subtracts each vector element in the second source SIMD&amp;FP register 
from the corresponding vector element in the first source SIMD&amp;FP register, places 
the result into a vector, and writes the vector to the destination SIMD&amp;FP register.

Scalar variant
  SUB &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;

Vector variant
  SUB &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1366" header="Subtract returning High Narrow" doc_id="armv8arm" token="SUBHN">This instruction subtracts each vector element in the second source SIMD&amp;FP register 
from the corresponding vector element in the first source SIMD&amp;FP register, places 
the most significant half of the result into a vector, and writes the vector to the 
lower or upper half of the destination SIMD&amp;FP register. All the values in this 
instruction are signed integer values. The results are truncated.

The SUBHN instruction writes the vector to the lower half of the destination register 
and clears the upper half, while the SUBHN2 instruction writes the vector to the upper 
half of the destination register without affecting the other bits of the register.

Three registers, not all the same type variant
SUBHN &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;, &lt;Vm&gt;.&lt;Ta&gt;</hint>
			<hint page="1366" header="Subtract returning High Narrow" doc_id="armv8arm" token="SUBHN2">This instruction subtracts each vector element in the second source SIMD&amp;FP register 
from the corresponding vector element in the first source SIMD&amp;FP register, places 
the most significant half of the result into a vector, and writes the vector to the 
lower or upper half of the destination SIMD&amp;FP register. All the values in this 
instruction are signed integer values. The results are truncated.

The SUBHN instruction writes the vector to the lower half of the destination register 
and clears the upper half, while the SUBHN2 instruction writes the vector to the upper 
half of the destination register without affecting the other bits of the register.

Three registers, not all the same type variant
SUBHN2 &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;, &lt;Vm&gt;.&lt;Ta&gt;</hint>
			<hint page="1368" header="Signed saturating Accumulate of Unsigned value" doc_id="armv8arm" token="SUQADD">This instruction adds the unsigned integer values of the vector elements in the 
source SIMD&amp;FP register to corresponding signed integer values of the vector 
elements in the destination SIMD&amp;FP register, and writes the resulting signed 
integer values to the destination SIMD&amp;FP register.

Scalar variant
  SUQADD &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;

Vector variant
  SUQADD &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="1370" header="Signed extend Long" doc_id="armv8arm" token="SXTL">This instruction duplicates each vector element in the lower or upper half of the 
source SIMD&amp;FP register into a vector, and writes the vector to the destination 
SIMD&amp;FP register. The destination vector elements are twice as long as the source 
vector elements. All the values in this instruction are signed integer values.

The SXTL instruction extracts the source vector from the lower half of the source 
register, while the SXTL2 instruction extracts the source vector from the upper 
half of the source register.

SXTL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;

  is equivalent to

SSHLL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, #0</hint>
			<hint page="1370" header="Signed extend Long" doc_id="armv8arm" token="SXTL2">This instruction duplicates each vector element in the lower or upper half of the 
source SIMD&amp;FP register into a vector, and writes the vector to the destination 
SIMD&amp;FP register. The destination vector elements are twice as long as the source 
vector elements. All the values in this instruction are signed integer values.

The SXTL instruction extracts the source vector from the lower half of the source 
register, while the SXTL2 instruction extracts the source vector from the upper 
half of the source register.

SXTL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;

  is equivalent to

SSHLL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, #0</hint>
			<hint page="1372" header="Table vector Lookup" doc_id="armv8arm" token="TBL">This instruction reads each value from the vector elements in the index 
source SIMD&amp;FP register, uses each result as an index to perform a lookup 
in a table of bytes that is described by one to four source table SIMD&amp;FP 
registers, places the lookup result in a vector, and writes the vector to 
the destination SIMD&amp;FP register. If an index is out of range for the table, 
the result for that lookup is 0. If more than one source register is used 
to describe the table, the first source register describes the lowest bytes 
of the table.

Two register table variant
  TBL &lt;Vd&gt;.&lt;Ta&gt;, { &lt;Vn&gt;.16B, &lt;Vn+1&gt;.16B }, &lt;Vm&gt;.&lt;Ta&gt;

Three register table variant
  TBL &lt;Vd&gt;.&lt;Ta&gt;, { &lt;Vn&gt;.16B, &lt;Vn+1&gt;.16B, &lt;Vn+2&gt;.16B }, &lt;Vm&gt;.&lt;Ta&gt;

Four register table variant
  TBL &lt;Vd&gt;.&lt;Ta&gt;, { &lt;Vn&gt;.16B, &lt;Vn+1&gt;.16B, &lt;Vn+2&gt;.16B, &lt;Vn+3&gt;.16B }, &lt;Vm&gt;.&lt;Ta&gt;

Single register table variant
  TBL &lt;Vd&gt;.&lt;Ta&gt;, { &lt;Vn&gt;.16B }, &lt;Vm&gt;.&lt;Ta&gt;</hint>
			<hint page="1374" header="Table vector lookup extension" doc_id="armv8arm" token="TBX">This instruction reads each value from the vector elements in the index 
source SIMD&amp;FP register, uses each result as an index to perform a lookup 
in a table of bytes that is described by one to four source table SIMD&amp;FP 
registers, places the lookup result in a vector, and writes the vector to 
the destination SIMD&amp;FP register. If an index is out of range for the table, 
the existing value in the vector element of the destination register is 
left unchanged. If more than one source register is used to describe the 
table, the first source register describes the lowest bytes of the table.

Two register table variant
  TBX &lt;Vd&gt;.&lt;Ta&gt;, { &lt;Vn&gt;.16B, &lt;Vn+1&gt;.16B }, &lt;Vm&gt;.&lt;Ta&gt;

Three register table variant
  TBX &lt;Vd&gt;.&lt;Ta&gt;, { &lt;Vn&gt;.16B, &lt;Vn+1&gt;.16B, &lt;Vn+2&gt;.16B }, &lt;Vm&gt;.&lt;Ta&gt;

Four register table variant
  TBX &lt;Vd&gt;.&lt;Ta&gt;, { &lt;Vn&gt;.16B, &lt;Vn+1&gt;.16B, &lt;Vn+2&gt;.16B, &lt;Vn+3&gt;.16B }, &lt;Vm&gt;.&lt;Ta&gt;

Single register table variant
  TBX &lt;Vd&gt;.&lt;Ta&gt;, { &lt;Vn&gt;.16B }, &lt;Vm&gt;.&lt;Ta&gt;</hint>
			<hint page="1376" header="Transpose vectors (primary)" doc_id="armv8arm" token="TRN1">This instruction reads corresponding even-numbered vector elements from the two 
source SIMD&amp;FP registers, starting at zero, places each result into consecutive 
elements of a vector, and writes the vector to the destination SIMD&amp;FP register. 
Vector elements from the first source register are placed into even-numbered 
elements of the destination vector, starting at zero, while vector elements from 
the second source register are placed into odd-numbered elements of the 
destination vector.

TRN1 &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1378" header="Transpose vectors (secondary)" doc_id="armv8arm" token="TRN2">This instruction reads corresponding odd-numbered vector elements from the two 
source SIMD&amp;FP registers, places each result into consecutive elements of a 
vector, and writes the vector to the destination SIMD&amp;FP register. Vector 
elements from the first source register are placed into even-numbered elements 
of the destination vector, starting at zero, while vector elements from the 
second source register are placed into odd-numbered elements of the destination 
vector.

TRN2 &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1380" header="Unsigned Absolute difference and Accumulate" doc_id="armv8arm" token="UABA">This instruction subtracts the elements of the vector of the second 
source SIMD&amp;FP register from the corresponding elements of the first 
source SIMD&amp;FP register, and accumulates the absolute values of the 
results into the elements of the vector of the destination SIMD&amp;FP 
register.

UABA &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1382" header="Unsigned Absolute difference and Accumulate Long" doc_id="armv8arm" token="UABAL">This instruction subtracts the vector elements in the lower or upper half of the 
second source SIMD&amp;FP register from the corresponding vector elements of the first 
source SIMD&amp;FP register, and accumulates the absolute values of the results into 
the vector elements of the destination SIMD&amp;FP register. The destination vector 
elements are twice as long as the source vector elements. All the values in this 
instruction are unsigned integer values.

The UABAL instruction extracts each source vector from the lower half of each 
source register, while the UABAL2 instruction extracts each source vector from 
the upper half of each source register.

UABAL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1382" header="Unsigned Absolute difference and Accumulate Long" doc_id="armv8arm" token="UABAL2">This instruction subtracts the vector elements in the lower or upper half of the 
second source SIMD&amp;FP register from the corresponding vector elements of the first 
source SIMD&amp;FP register, and accumulates the absolute values of the results into 
the vector elements of the destination SIMD&amp;FP register. The destination vector 
elements are twice as long as the source vector elements. All the values in this 
instruction are unsigned integer values.

The UABAL instruction extracts each source vector from the lower half of each 
source register, while the UABAL2 instruction extracts each source vector from 
the upper half of each source register.

UABAL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1384" header="Unsigned Absolute Difference (vector)" doc_id="armv8arm" token="UABD">This instruction subtracts the elements of the vector of the second 
source SIMD&amp;FP register from the corresponding elements of the first 
source SIMD&amp;FP register, places the absolute values of the results 
into a vector, and writes the vector to the destination SIMD&amp;FP 
register.

UABD &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1386" header="Unsigned Absolute Difference Long" doc_id="armv8arm" token="UABDL">This instruction subtracts the vector elements in the lower or upper half of the 
second source SIMD&amp;FP register from the corresponding vector elements of the first 
source SIMD&amp;FP register, places the absolute value of the result into a vector, 
and writes the vector to the destination SIMD&amp;FP register. The destination vector 
elements are twice as long as the source vector elements. All the values in this 
instruction are unsigned integer values.

The UABDL instruction extracts each source vector from the lower half of each 
source register, while the UABDL2 instruction extracts each source vector from 
the upper half of each source register.

UABDL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1386" header="Unsigned Absolute Difference Long" doc_id="armv8arm" token="UABDL2">This instruction subtracts the vector elements in the lower or upper half of the 
second source SIMD&amp;FP register from the corresponding vector elements of the first 
source SIMD&amp;FP register, places the absolute value of the result into a vector, 
and writes the vector to the destination SIMD&amp;FP register. The destination vector 
elements are twice as long as the source vector elements. All the values in this 
instruction are unsigned integer values.

The UABDL instruction extracts each source vector from the lower half of each 
source register, while the UABDL2 instruction extracts each source vector from 
the upper half of each source register.

UABDL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1388" header="Unsigned Add and Accumulate Long Pairwise" doc_id="armv8arm" token="UADALP">This instruction adds pairs of adjacent unsigned integer values from the vector 
in the source SIMD&amp;FP register and accumulates the results with the vector 
elements of the destination SIMD&amp;FP register. The destination vector elements 
are twice as long as the source vector elements.

UADALP &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;</hint>
			<hint page="1390" header="Unsigned Add Long (vector)" doc_id="armv8arm" token="UADDL">This instruction adds each vector element in the lower or upper half of the first 
source SIMD&amp;FP register to the corresponding vector element of the second source 
SIMD&amp;FP register, places the result into a vector, and writes the vector to the 
destination SIMD&amp;FP register. The destination vector elements are twice as long 
as the source vector elements. All the values in this instruction are unsigned 
integer values.

The UADDL instruction extracts each source vector from the lower half of each 
source register, while the UADDL2 instruction extracts each source vector from 
the upper half of each source register.

UADDL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1390" header="Unsigned Add Long (vector)" doc_id="armv8arm" token="UADDL2">This instruction adds each vector element in the lower or upper half of the first 
source SIMD&amp;FP register to the corresponding vector element of the second source 
SIMD&amp;FP register, places the result into a vector, and writes the vector to the 
destination SIMD&amp;FP register. The destination vector elements are twice as long 
as the source vector elements. All the values in this instruction are unsigned 
integer values.

The UADDL instruction extracts each source vector from the lower half of each 
source register, while the UADDL2 instruction extracts each source vector from 
the upper half of each source register.

UADDL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1392" header="Unsigned Add Long Pairwise" doc_id="armv8arm" token="UADDLP">This instruction adds pairs of adjacent unsigned integer values from the 
vector in the source SIMD&amp;FP register, places the result into a vector, 
and writes the vector to the destination SIMD&amp;FP register. The destination 
vector elements are twice as long as the source vector elements.

UADDLP &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;</hint>
			<hint page="1394" header="Unsigned sum Long across Vector" doc_id="armv8arm" token="UADDLV">This instruction adds every vector element in the source SIMD&amp;FP register together, 
and writes the scalar result to the destination SIMD&amp;FP register. The destination 
scalar is twice as long as the source vector elements. All the values in this 
instruction are unsigned integer values.

UADDLV &lt;V&gt;&lt;d&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="1396" header="Unsigned Add Wide" doc_id="armv8arm" token="UADDW, UADDW2">This instruction adds the vector elements of the first source SIMD&amp;FP register 
to the corresponding vector elements in the lower or upper half of the second 
source SIMD&amp;FP register, places the result in a vector, and writes the vector 
to the SIMD&amp;FP destination register. The vector elements of the destination 
register and the first source register are twice as long as the vector elements 
of the second source register. All the values in this instruction are unsigned 
integer values.

The UADDW instruction extracts vector elements from the lower half of the second 
source register, while the UADDW2 instruction extracts vector elements from the 
upper half of the second source register.

UADDW &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Ta&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1396" header="Unsigned Add Wide" doc_id="armv8arm" token="UADDW2">This instruction adds the vector elements of the first source SIMD&amp;FP register 
to the corresponding vector elements in the lower or upper half of the second 
source SIMD&amp;FP register, places the result in a vector, and writes the vector 
to the SIMD&amp;FP destination register. The vector elements of the destination 
register and the first source register are twice as long as the vector elements 
of the second source register. All the values in this instruction are unsigned 
integer values.

The UADDW instruction extracts vector elements from the lower half of the second 
source register, while the UADDW2 instruction extracts vector elements from the 
upper half of the second source register.

UADDW2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Ta&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1398" header="Unsigned Convert to Floating-point" doc_id="armv8arm" token="UCVTF">1. Fixed-point (vector)
This instruction converts each element in a vector from fixed-point to floating-point 
using the rounding mode that is specified by the FPCR, and writes the result to the 
SIMD&amp;FP destination register.

Scalar variant
  UCVTF &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #&lt;fbits&gt;
Vector variant
  UCVTF &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, #&lt;fbits&gt;

2. Integer (vector)
This instruction converts each element in a vector from an unsigned integer value to a 
floating-point value using the rounding mode that is specified by the FPCR, and writes 
the result to the SIMD&amp;FP destination register.

Scalar variant
  UCVTF &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;
Vector variant
  UCVTF &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;


3. Fixed-paint (scalar)
This instruction converts the unsigned value in the 32-bit or 64-bit general-purpose 
source register to a floating-point value using the rounding mode that is specified 
by the FPCR, and writes the result to the SIMD&amp;FP destination register.

32-bit to single-precision variant: UCVTF &lt;Sd&gt;, &lt;Wn&gt;, #&lt;fbits&gt;
32-bit to double-precision variant: UCVTF &lt;Dd&gt;, &lt;Wn&gt;, #&lt;fbits&gt;
64-bit to single-precision variant: UCVTF &lt;Sd&gt;, &lt;Xn&gt;, #&lt;fbits&gt;
64-bit to double-precision variant: UCVTF &lt;Dd&gt;, &lt;Xn&gt;, #&lt;fbits&gt;


4. Integer (scalar)
This instruction converts the unsigned integer value in the general-purpose source 
register to a floating-point value using the rounding mode that is specified by the 
FPCR, and writes the result to the SIMD&amp;FP destination register.

32-bit to single-precision variant: UCVTF &lt;Sd&gt;, &lt;Wn&gt;
32-bit to double-precision variant: UCVTF &lt;Dd&gt;, &lt;Wn&gt;
64-bit to single-precision variant: UCVTF &lt;Sd&gt;, &lt;Xn&gt;
64-bit to double-precision variant: UCVTF &lt;Dd&gt;, &lt;Xn&gt;</hint>
			<hint page="1407" header="Unsigned Halving Add" doc_id="armv8arm" token="UHADD">This instruction adds corresponding unsigned integer values from the two 
source SIMD&amp;FP registers, shifts each result right one bit, places the 
results into a vector, and writes the vector to the destination SIMD&amp;FP 
register.

UHADD &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1409" header="Unsigned Halving Subtract" doc_id="armv8arm" token="UHSUB">This instruction subtracts the vector elements in the second source SIMD&amp;FP 
register from the corresponding vector elements in the first source SIMD&amp;FP 
register, shifts each result right one bit, places each result into a vector, 
and writes the vector to the destination SIMD&amp;FP register.

UHSUB &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1411" header="Unsigned Maximum (vector)." doc_id="armv8arm" token="UMAX">This instruction compares corresponding elements in the vectors 
in the two source SIMD&amp;FP registers, places the larger of each 
pair of unsigned integer values into a vector, and writes the 
vector to the destination SIMD&amp;FP register.

UMAX &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1413" header="Unsigned Maximum Pairwise" doc_id="armv8arm" token="UMAXP">This instruction creates a vector by concatenating the vector elements of the first 
source SIMD&amp;FP register after the vector elements of the second source SIMD&amp;FP 
register, reads each pair of adjacent vector elements in the two source SIMD&amp;FP 
registers, writes the largest of each pair of unsigned integer values into a vector, 
and writes the vector to the destination SIMD&amp;FP register.

UMAXP &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1415" header="Unsigned Maximum across Vector" doc_id="armv8arm" token="UMAXV">This instruction compares all the vector elements in the source SIMD&amp;FP register, 
and writes the largest of the values as a scalar to the destination SIMD&amp;FP 
register. All the values in this instruction are unsigned integer values.

UMAXV &lt;V&gt;&lt;d&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="1417" header="Unsigned Minimum (vector)" doc_id="armv8arm" token="UMIN">This instruction compares corresponding vector elements in the two source SIMD&amp;FP 
registers, places the smaller of each of the two unsigned integer values into a 
vector, and writes the vector to the destination SIMD&amp;FP register.

UMIN &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1419" header="Unsigned Minimum Pairwise" doc_id="armv8arm" token="UMINP">This instruction creates a vector by concatenating the vector elements of the 
first source SIMD&amp;FP register after the vector elements of the second source 
SIMD&amp;FP register, reads each pair of adjacent vector elements in the two source 
SIMD&amp;FP registers, writes the smallest of each pair of unsigned integer values 
into a vector, and writes the vector to the destination SIMD&amp;FP register.

UMINP &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1421" header="Unsigned Minimum across Vector" doc_id="armv8arm" token="UMINV">This instruction compares all the vector elements in the source SIMD&amp;FP register, 
and writes the smallest of the values as a scalar to the destination SIMD&amp;FP 
register. All the values in this instruction are unsigned integer values.

UMINV &lt;V&gt;&lt;d&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="1423" header="Unsigned Multiply-Add Long" doc_id="armv8arm" token="UMLAL">1. By element
This instruction multiplies each vector element in the lower or upper half of the first 
source SIMD&amp;FP register by the specified vector element of the second source SIMD&amp;FP 
register and accumulates the results with the vector elements of the destination 
SIMD&amp;FP register. The destination vector elements are twice as long as the elements 
that are multiplied.

UMLAL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]

2. Vector
This instruction multiplies the vector elements in the lower or upper half of the first 
source SIMD&amp;FP register by the corresponding vector elements of the second source SIMD&amp;FP 
register, and accumulates the results with the vector elements of the destination 
SIMD&amp;FP register. The destination vector elements are twice as long as the elements 
that are multiplied.

UMLAL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1423" header="Unsigned Multiply-Add Long" doc_id="armv8arm" token="UMLAL2">1. By element
This instruction multiplies each vector element in the lower or upper half of the first 
source SIMD&amp;FP register by the specified vector element of the second source SIMD&amp;FP 
register and accumulates the results with the vector elements of the destination 
SIMD&amp;FP register. The destination vector elements are twice as long as the elements 
that are multiplied.

UMLAL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]

2. Vector
This instruction multiplies the vector elements in the lower or upper half of the first 
source SIMD&amp;FP register by the corresponding vector elements of the second source SIMD&amp;FP 
register, and accumulates the results with the vector elements of the destination 
SIMD&amp;FP register. The destination vector elements are twice as long as the elements 
that are multiplied.

UMLAL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1428" header="Unsigned Multiply-Subtract Long" doc_id="armv8arm" token="UMLSL">1. By element
This instruction multiplies each vector element in the lower or upper half of the first 
source SIMD&amp;FP register by the specified vector element of the second source SIMD&amp;FP 
register and subtracts the results from the vector elements of the destination 
SIMD&amp;FP register. The destination vector elements are twice as long as the elements 
that are multiplied.

UMLSL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]

2. Vector
This instruction multiplies corresponding vector elements in the lower or upper half 
of the two source SIMD&amp;FP registers, and subtracts the results from the vector 
elements of the destination SIMD&amp;FP register. The destination vector elements are 
twice as long as the elements that are multiplied. All the values in this instruction 
are unsigned integer values.

UMLSL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1428" header="Unsigned Multiply-Subtract Long" doc_id="armv8arm" token="UMLSL2">1. By element
This instruction multiplies each vector element in the lower or upper half of the first 
source SIMD&amp;FP register by the specified vector element of the second source SIMD&amp;FP 
register and subtracts the results from the vector elements of the destination 
SIMD&amp;FP register. The destination vector elements are twice as long as the elements 
that are multiplied.

UMLSL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]

2. Vector
This instruction multiplies corresponding vector elements in the lower or upper half 
of the two source SIMD&amp;FP registers, and subtracts the results from the vector 
elements of the destination SIMD&amp;FP register. The destination vector elements are 
twice as long as the elements that are multiplied. All the values in this instruction 
are unsigned integer values.

UMLSL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1433" header="Unsigned Move vector element to general-purpose register" doc_id="armv8arm" token="UMOV">This instruction reads the unsigned integer from the source SIMD&amp;FP register, 
zero-extends it to form a 32-bit or 64-bit value, and writes the result to 
the destination general-purpose register.

32-bit variant
  UMOV &lt;Wd&gt;, &lt;Vn&gt;.&lt;Ts&gt;[&lt;index&gt;]

64-bit variant
  UMOV &lt;Xd&gt;, &lt;Vn&gt;.&lt;Ts&gt;[&lt;index&gt;]</hint>
			<hint page="1435" header="Unsigned Multiply Long" doc_id="armv8arm" token="UMULL">1. By element
This instruction multiplies each vector element in the lower or upper half of the 
first source SIMD&amp;FP register by the specified vector element of the second source 
SIMD&amp;FP register, places the results in a vector, and writes the vector to the 
destination SIMD&amp;FP register. The destination vector elements are twice as long 
as the elements that are multiplied.

UMULL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]


2. Vector
This instruction multiplies corresponding vector elements in the lower or upper 
half of the two source SIMD&amp;FP registers, places the result in a vector, and 
writes the vector to the destination SIMD&amp;FP register. The destination vector 
elements are twice as long as the elements that are multiplied. All the values 
in this instruction are unsigned integer values.

UMULL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1435" header="Unsigned Multiply Long" doc_id="armv8arm" token="UMULL2">1. By element
This instruction multiplies each vector element in the lower or upper half of the 
first source SIMD&amp;FP register by the specified vector element of the second source 
SIMD&amp;FP register, places the results in a vector, and writes the vector to the 
destination SIMD&amp;FP register. The destination vector elements are twice as long 
as the elements that are multiplied.

UMULL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]


2. Vector
This instruction multiplies corresponding vector elements in the lower or upper 
half of the two source SIMD&amp;FP registers, places the result in a vector, and 
writes the vector to the destination SIMD&amp;FP register. The destination vector 
elements are twice as long as the elements that are multiplied. All the values 
in this instruction are unsigned integer values.

UMULL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1439" header="Unsigned saturating Add" doc_id="armv8arm" token="UQADD">This instruction adds the values of corresponding elements of the two source 
SIMD&amp;FP registers, places the results into a vector, and writes the vector to 
the destination SIMD&amp;FP register.

UQADD &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;</hint>
			<hint page="1441" header="Unsigned saturating Rounding Shift Left" doc_id="armv8arm" token="UQRSHL">This instruction takes each vector element of the first source SIMD&amp;FP register, 
shifts the vector element by a value from the least significant byte of the 
corresponding vector element of the second source SIMD&amp;FP register, places the 
results into a vector, and writes the vector to the destination SIMD&amp;FP register.

UQRSHL &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;</hint>
			<hint page="1443" header="Unsigned saturating Rounded Shift Right Narrow" doc_id="armv8arm" token="UQRSHRN">This instruction reads each vector element in the source SIMD&amp;FP register, 
right shifts each result by an immediate value, puts the final result into 
a vector, and writes the vector to the lower or upper half of the destination 
SIMD&amp;FP register. All the values in this instruction are unsigned integer 
values. The results are rounded.

Scalar variant
  UQRSHRN &lt;Vb&gt;&lt;d&gt;, &lt;Va&gt;&lt;n&gt;, #&lt;shift&gt;

Vector variant
  UQRSHRN &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;, #&lt;shift&gt;</hint>
			<hint page="1443" header="Unsigned saturating Rounded Shift Right Narrow" doc_id="armv8arm" token="UQRSHRN2">This instruction reads each vector element in the source SIMD&amp;FP register, 
right shifts each result by an immediate value, puts the final result into 
a vector, and writes the vector to the lower or upper half of the destination 
SIMD&amp;FP register. All the values in this instruction are unsigned integer 
values. The results are rounded.

Vector variant
  UQRSHRN2 &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;, #&lt;shift&gt;</hint>
			<hint page="1446" header="Unsigned saturating Shift Left" doc_id="armv8arm" token="UQSHL">1. Immediate
This instruction takes each vector element in the source SIMD&amp;FP register, 
shifts it by an immediate value, places the results in a vector, and writes 
the vector to the destination SIMD&amp;FP register. The results are truncated.

Scalar variant
  UQSHL &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #&lt;shift&gt;

Vector variant
  UQSHL &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, #&lt;shift&gt;

2. Register
This instruction takes each element in the vector of the first source SIMD&amp;FP 
register, shifts the element by a value from the least significant byte of 
the corresponding element of the second source SIMD&amp;FP register, places the 
results in a vector, and writes the vector to the destination SIMD&amp;FP register.

Scalar variant
  UQSHL &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;

Vector variant
  UQSHL &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1451" header="Unsigned saturating Shift Right Narrow" doc_id="armv8arm" token="UQSHRN">This instruction reads each vector element in the source SIMD&amp;FP register, 
right shifts each result by an immediate value, saturates each shifted result 
to a value that is half the original width, puts the final result into a vector, 
and writes the vector to the lower or upper half of the destination SIMD&amp;FP 
register. All the values in this instruction are unsigned integer values. 
The results are truncated.

Scalar variant
  UQSHRN &lt;Vb&gt;&lt;d&gt;, &lt;Va&gt;&lt;n&gt;, #&lt;shift&gt;

Vector variant
  UQSHRN &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;, #&lt;shift&gt;</hint>
			<hint page="1451" header="Unsigned saturating Shift Right Narrow" doc_id="armv8arm" token="UQSHRN2">This instruction reads each vector element in the source SIMD&amp;FP register, 
right shifts each result by an immediate value, saturates each shifted result 
to a value that is half the original width, puts the final result into a vector, 
and writes the vector to the lower or upper half of the destination SIMD&amp;FP 
register. All the values in this instruction are unsigned integer values. 
The results are truncated.

Vector variant
  UQSHRN2 &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;, #&lt;shift&gt;</hint>
			<hint page="1454" header="Unsigned saturating Subtract." doc_id="armv8arm" token="UQSUB">This instruction subtracts the element values of the second source SIMD&amp;FP 
register from the corresponding element values of the first source SIMD&amp;FP 
register, places the results into a vector, and writes the vector to the 
destination SIMD&amp;FP register.

UQSUB &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;</hint>
			<hint page="1456" header="Unsigned saturating extract Narrow" doc_id="armv8arm" token="UQXTN">This instruction reads each vector element from the source SIMD&amp;FP register, 
saturates each value to half the original width, places the result into a 
vector, and writes the vector to the destination SIMD&amp;FP register. All the 
values in this instruction are unsigned integer values.

If saturation occurs, the cumulative saturation bit FPSR.QC is set.

The UQXTN instruction writes the vector to the lower half of the destination 
register and clears the upper half, while the UQXTN2 instruction writes the 
vector to the upper half of the destination register without affecting the 
other bits of the register.

Scalar variant
  UQXTN &lt;Vb&gt;&lt;d&gt;, &lt;Va&gt;&lt;n&gt;

Vector variant
  UQXTN &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;</hint>
			<hint page="1456" header="Unsigned saturating extract Narrow" doc_id="armv8arm" token="UQXTN2">This instruction reads each vector element from the source SIMD&amp;FP register, 
saturates each value to half the original width, places the result into a 
vector, and writes the vector to the destination SIMD&amp;FP register. All the 
values in this instruction are unsigned integer values.

If saturation occurs, the cumulative saturation bit FPSR.QC is set.

The UQXTN instruction writes the vector to the lower half of the destination 
register and clears the upper half, while the UQXTN2 instruction writes the 
vector to the upper half of the destination register without affecting the 
other bits of the register.

Vector variant
  UQXTN &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;</hint>
			<hint page="1459" header="Unsigned Reciprocal Estimate" doc_id="armv8arm" token="URECPE">This instruction reads each vector element from the source SIMD&amp;FP register, 
calculates an approximate inverse for the unsigned integer value, places the 
result into a vector, and writes the vector to the destination SIMD&amp;FP register.

URECPE &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="1460" header="Unsigned Rounding Halving Add" doc_id="armv8arm" token="URHADD">This instruction adds corresponding unsigned integer values from the two 
source SIMD&amp;FP registers, shifts each result right one bit, places the 
results into a vector, and writes the vector to the destination SIMD&amp;FP 
register.

URHADD &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1462" header="Unsigned Rounding Shift Left" doc_id="armv8arm" token="URSHL">This instruction takes each element in the vector of the first source 
SIMD&amp;FP register, shifts the vector element by a value from the least 
significant byte of the corresponding element of the second source 
SIMD&amp;FP register, places the results in a vector, and writes 
the vector to the destination SIMD&amp;FP register.

URSHL &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;</hint>
			<hint page="1464" header="Unsigned Rounding Shift Right" doc_id="armv8arm" token="URSHR">This instruction reads each vector element in the source SIMD&amp;FP register, 
right shifts each result by an immediate value, writes the final result to 
a vector, and writes the vector to the destination SIMD&amp;FP register. 
All the values in this instruction are unsigned integer values. 
The results are rounded.

Scalar variant
  URSHR &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #&lt;shift&gt;

Vector variant
  URSHR &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, #&lt;shift&gt;</hint>
			<hint page="1466" header="Unsigned Reciprocal Square Root Estimate" doc_id="armv8arm" token="URSQRTE">This instruction reads each vector element from the source 
SIMD&amp;FP register, calculates an approximate inverse square 
root for each value, places the result into a vector, and 
writes the vector to the destination SIMD&amp;FP register. 
All the values in this instruction are unsigned integer 
values.

URSQRTE &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="1467" header="Unsigned Rounding Shift Right and Accumulate" doc_id="armv8arm" token="URSRA">This instruction reads each vector element in the source 
SIMD&amp;FP register, right shifts each result by an immediate 
value, and accumulates the final results with the vector 
elements of the destination SIMD&amp;FP register. All the values 
in this instruction are unsigned integer values. 
The results are rounded.

Scalar variant
  URSRA &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #&lt;shift&gt;

Vector variant
  URSRA &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, #&lt;shift&gt;</hint>
			<hint page="1469" header="Unsigned Shift Left" doc_id="armv8arm" token="USHL">This instruction takes each element in the vector of the first source 
SIMD&amp;FP register, shifts each element by a value from the least 
significant byte of the corresponding element of the second source 
SIMD&amp;FP register, places the results in a vector, and writes the 
vector to the destination SIMD&amp;FP register.

Scalar variant
  USHL &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;

Vector variant
  USHL &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1471" header="Unsigned Shift Left Long" doc_id="armv8arm" token="USHLL">This instruction reads each vector element in the lower or upper half of 
the source SIMD&amp;FP register, shifts the unsigned integer value left by 
the specified number of bits, places the result into a vector, and writes 
the vector to the destination SIMD&amp;FP register. The destination vector 
elements are twice as long as the source vector elements.

The USHLL instruction extracts vector elements from the lower half of the 
source register, while the USHLL2 instruction extracts vector elements 
from the upper half of the source register.

USHLL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, #&lt;shift&gt;</hint>
			<hint page="1471" header="Unsigned Shift Left Long" doc_id="armv8arm" token="USHLL2">This instruction reads each vector element in the lower or upper half of 
the source SIMD&amp;FP register, shifts the unsigned integer value left by 
the specified number of bits, places the result into a vector, and writes 
the vector to the destination SIMD&amp;FP register. The destination vector 
elements are twice as long as the source vector elements.

The USHLL instruction extracts vector elements from the lower half of the 
source register, while the USHLL2 instruction extracts vector elements 
from the upper half of the source register.

USHLL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, #&lt;shift&gt;</hint>
			<hint page="1473" header="Unsigned Shift Right" doc_id="armv8arm" token="USHR">This instruction reads each vector element in the source SIMD&amp;FP register, 
right shifts each result by an immediate value, writes the final result 
to a vector, and writes the vector to the destination SIMD&amp;FP register. 
All the values in this instruction are unsigned integer values. 
The results are truncated.

Scalar variant
  USHR &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #&lt;shift&gt;

Vector variant
  USHR &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, #&lt;shift&gt;</hint>
			<hint page="1475" header="Unsigned saturating Accumulate of Signed value" doc_id="armv8arm" token="USQADD">This instruction adds the signed integer values of the vector elements 
in the source SIMD&amp;FP register to corresponding unsigned integer values 
of the vector elements in the destination SIMD&amp;FP register, and 
accumulates the resulting unsigned integer values with the vector 
elements of the destination SIMD&amp;FP register.

Scalar variant
  USQADD &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;

Vector variant
  USQADD &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="1477" header="Unsigned Shift Right and Accumulate" doc_id="armv8arm" token="USRA">This instruction reads each vector element in the source SIMD&amp;FP register, 
right shifts each result by an immediate value, and accumulates the final 
results with the vector elements of the destination SIMD&amp;FP register. 
All the values in this instruction are unsigned integer values. 
The results are truncated. 

Scalar variant
  USRA &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #&lt;shift&gt;

Vector variant
  USRA &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, #&lt;shift&gt;</hint>
			<hint page="1479" header="Unsigned Subtract Long" doc_id="armv8arm" token="USUBL">This instruction subtracts each vector element in the lower or upper half of the 
second source SIMD&amp;FP register from the corresponding vector element of the first 
source SIMD&amp;FP register, places the result into a vector, and writes the vector 
to the destination SIMD&amp;FP register. All the values in this instruction are 
unsigned integer values. The destination vector elements are twice as long as 
the source vector elements.

The USUBL instruction extracts each source vector from the lower half of each 
source register, while the USUBL2 instruction extracts each source vector 
from the upper half of each source register.

USUBL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1479" header="Unsigned Subtract Long" doc_id="armv8arm" token="USUBL2">This instruction subtracts each vector element in the lower or upper half of the 
second source SIMD&amp;FP register from the corresponding vector element of the first 
source SIMD&amp;FP register, places the result into a vector, and writes the vector 
to the destination SIMD&amp;FP register. All the values in this instruction are 
unsigned integer values. The destination vector elements are twice as long as 
the source vector elements.

The USUBL instruction extracts each source vector from the lower half of each 
source register, while the USUBL2 instruction extracts each source vector 
from the upper half of each source register.

USUBL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1481" header="Unsigned Subtract Wide" doc_id="armv8arm" token="USUBW">This instruction subtracts each vector element of the second 
source SIMD&amp;FP register from the corresponding vector element 
in the lower or upper half of the first source SIMD&amp;FP register, 
places the result in a vector, and writes the vector to the 
SIMD&amp;FP destination register. All the values in this instruction 
are signed integer values.

The vector elements of the destination register and the first 
source register are twice as long as the vector elements of 
the second source register.

USUBW &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Ta&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1481" header="Unsigned Subtract Wide" doc_id="armv8arm" token="USUBW2">This instruction subtracts each vector element of the second 
source SIMD&amp;FP register from the corresponding vector element 
in the lower or upper half of the first source SIMD&amp;FP register, 
places the result in a vector, and writes the vector to the 
SIMD&amp;FP destination register. All the values in this instruction 
are signed integer values.

The vector elements of the destination register and the first 
source register are twice as long as the vector elements of 
the second source register.

USUBW2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Ta&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1483" header="Unsigned extend Long" doc_id="armv8arm" token="UXTL">This instruction copies each vector element from the lower or upper half of the 
source SIMD&amp;FP register into a vector, and writes the vector to the destination 
SIMD&amp;FP register. The destination vector elements are twice as long as the 
source vector elements.

The UXTL instruction extracts vector elements from the lower half of the source 
register, while the UXTL2 instruction extracts vector elements from the upper 
half of the source register.

UXTL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;

  is equivalent to

USHLL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, #0</hint>
			<hint page="1483" header="Unsigned extend Long" doc_id="armv8arm" token="UXTL2">This instruction copies each vector element from the lower or upper half of the 
source SIMD&amp;FP register into a vector, and writes the vector to the destination 
SIMD&amp;FP register. The destination vector elements are twice as long as the 
source vector elements.

The UXTL instruction extracts vector elements from the lower half of the source 
register, while the UXTL2 instruction extracts vector elements from the upper 
half of the source register.

UXTL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;

  is equivalent to

USHLL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, #0</hint>
			<hint page="1485" header="Unzip vectors (primary)" doc_id="armv8arm" token="UZP1">This instruction reads corresponding even-numbered vector elements from the 
two source SIMD&amp;FP registers, starting at zero, places the result from the 
first source register into consecutive elements in the lower half of a vector, 
and the result from the second source register into consecutive elements in 
the upper half of a vector, and writes the vector to the destination SIMD&amp;FP 
register.

UZP1 &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1487" header="Unzip vectors (secondary)" doc_id="armv8arm" token="UZP2">This instruction reads corresponding odd-numbered vector elements 
from the two source SIMD&amp;FP registers, places the result from the 
first source register into consecutive elements in the lower half 
of a vector, and the result from the second source register into 
consecutive elements in the upper half of a vector, and writes 
the vector to the destination SIMD&amp;FP register.

UZP2 &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1489" header="Extract Narrow" doc_id="armv8arm" token="XTN">This instruction reads each vector element from the source SIMD&amp;FP register, 
narrows each value to half the original width, places the result into a 
vector, and writes the vector to the lower or upper half of the destination 
SIMD&amp;FP register. The destination vector elements are half as long as the 
source vector elements.

The XTN instruction writes the vector to the lower half of the destination 
register and clears the upper half, while the XTN2 instruction writes the 
vector to the upper half of the destination register without affecting 
the other bits of the register.

XTN &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;</hint>
			<hint page="1489" header="Extract Narrow" doc_id="armv8arm" token="XTN2">This instruction reads each vector element from the source SIMD&amp;FP register, 
narrows each value to half the original width, places the result into a 
vector, and writes the vector to the lower or upper half of the destination 
SIMD&amp;FP register. The destination vector elements are half as long as the 
source vector elements.

The XTN instruction writes the vector to the lower half of the destination 
register and clears the upper half, while the XTN2 instruction writes the 
vector to the upper half of the destination register without affecting 
the other bits of the register.

XTN2 &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;</hint>
			<hint page="1491" header="Zip vectors (primary)" doc_id="armv8arm" token="ZIP1">This instruction reads adjacent vector elements from the upper half of two 
source SIMD&amp;FP registers as pairs, interleaves the pairs and places them 
into a vector, and writes the vector to the destination SIMD&amp;FP register. 
The first pair from the first source register is placed into the two 
lowest vector elements, with subsequent pairs taken alternately from 
each source register.

ZIP1 &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1493" header="Zip vectors (secondary)" doc_id="armv8arm" token="ZIP2">This instruction reads adjacent vector elements from the lower half 
of two source SIMD&amp;FP registers as pairs, interleaves the pairs and 
places them into a vector, and writes the vector to the destination 
SIMD&amp;FP register. The first pair from the first source register is 
placed into the two lowest vector elements, with subsequent pairs 
taken alternately from each source register.

ZIP2 &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
		</group>
		<group type="ins" name="A64 Cryptographic Extension instructions">
			<hint page="782" header="AES single round decryption" doc_id="armv8arm" token="AESD">AESD &lt;Vd&gt;.16B, &lt;Vn&gt;.16B</hint>
			<hint page="783" header="AES single round encryption" doc_id="armv8arm" token="AESE">AESE &lt;Vd&gt;.16B, &lt;Vn&gt;.16B</hint>
			<hint page="784" header="AES inverse mix columns" doc_id="armv8arm" token="AESIMC">AESIMC &lt;Vd&gt;.16B, &lt;Vn&gt;.16B</hint>
			<hint page="785" header="AES mix columns" doc_id="armv8arm" token="AESMC">AESMC &lt;Vd&gt;.16B, &lt;Vn&gt;.16B</hint>
			<hint page="498" header="CRC32 checksum" doc_id="armv8arm" token="CRC32B">Performs a cyclic redundancy check (CRC) calculation on a value held in a 
general-purpose register. It takes an input CRC value in the first source 
operand, performs a CRC on the input value in the second source operand, 
and returns the output CRC value. The second source operand can be 8, 16, 
32, or 64 bits. To align with common usage, the bit order of the values
is reversed as part of the operation, and the polynomial 0x04C11DB7 is 
used for the CRC calculation.

CRC32B &lt;Wd&gt;, &lt;Wn&gt;, &lt;Wm&gt;</hint>
			<hint page="498" header="CRC32 checksum" doc_id="armv8arm" token="CRC32H">Performs a cyclic redundancy check (CRC) calculation on a value held in a 
general-purpose register. It takes an input CRC value in the first source 
operand, performs a CRC on the input value in the second source operand, 
and returns the output CRC value. The second source operand can be 8, 16, 
32, or 64 bits. To align with common usage, the bit order of the values
is reversed as part of the operation, and the polynomial 0x04C11DB7 is 
used for the CRC calculation.

CRC32H &lt;Wd&gt;, &lt;Wn&gt;, &lt;Wm&gt;</hint>
			<hint page="498" header="CRC32 checksum" doc_id="armv8arm" token="CRC32W">Performs a cyclic redundancy check (CRC) calculation on a value held in a 
general-purpose register. It takes an input CRC value in the first source 
operand, performs a CRC on the input value in the second source operand, 
and returns the output CRC value. The second source operand can be 8, 16, 
32, or 64 bits. To align with common usage, the bit order of the values
is reversed as part of the operation, and the polynomial 0x04C11DB7 is 
used for the CRC calculation.

CRC32W &lt;Wd&gt;, &lt;Wn&gt;, &lt;Wm&gt;</hint>
			<hint page="498" header="CRC32 checksum" doc_id="armv8arm" token="CRC32X">Performs a cyclic redundancy check (CRC) calculation on a value held in a 
general-purpose register. It takes an input CRC value in the first source 
operand, performs a CRC on the input value in the second source operand, 
and returns the output CRC value. The second source operand can be 8, 16, 
32, or 64 bits. To align with common usage, the bit order of the values
is reversed as part of the operation, and the polynomial 0x04C11DB7 is 
used for the CRC calculation.

CRC32X &lt;Wd&gt;, &lt;Wn&gt;, &lt;Xm&gt;</hint>
			<hint page="500" header="CRC32 checksum" doc_id="armv8arm" token="CRC32CB">Performs a cyclic redundancy check (CRC) calculation on a value held in a 
general-purpose register. It takes an input CRC value in the first source 
operand, performs a CRC on the input value in the second source operand, 
and returns the output CRC value. The second source operand can be 8, 16, 
32, or 64 bits. To align with common usage, the bit order of the values 
is reversed as part of the operation, and the polynomial 0x1EDC6F41 is 
used for the CRC calculation.

CRC32CB &lt;Wd&gt;, &lt;Wn&gt;, &lt;Wm&gt;</hint>
			<hint page="500" header="CRC32 checksum" doc_id="armv8arm" token="CRC32CH">Performs a cyclic redundancy check (CRC) calculation on a value held in a 
general-purpose register. It takes an input CRC value in the first source 
operand, performs a CRC on the input value in the second source operand, 
and returns the output CRC value. The second source operand can be 8, 16, 
32, or 64 bits. To align with common usage, the bit order of the values 
is reversed as part of the operation, and the polynomial 0x1EDC6F41 is 
used for the CRC calculation.

CRC32CH &lt;Wd&gt;, &lt;Wn&gt;, &lt;Wm&gt;</hint>
			<hint page="500" header="CRC32 checksum" doc_id="armv8arm" token="CRC32CW">Performs a cyclic redundancy check (CRC) calculation on a value held in a 
general-purpose register. It takes an input CRC value in the first source 
operand, performs a CRC on the input value in the second source operand, 
and returns the output CRC value. The second source operand can be 8, 16, 
32, or 64 bits. To align with common usage, the bit order of the values 
is reversed as part of the operation, and the polynomial 0x1EDC6F41 is 
used for the CRC calculation.

CRC32CW &lt;Wd&gt;, &lt;Wn&gt;, &lt;Wm&gt;</hint>
			<hint page="500" header="CRC32 checksum" doc_id="armv8arm" token="CRC32CX">Performs a cyclic redundancy check (CRC) calculation on a value held in a 
general-purpose register. It takes an input CRC value in the first source 
operand, performs a CRC on the input value in the second source operand, 
and returns the output CRC value. The second source operand can be 8, 16, 
32, or 64 bits. To align with common usage, the bit order of the values 
is reversed as part of the operation, and the polynomial 0x1EDC6F41 is 
used for the CRC calculation.

CRC32CX &lt;Wd&gt;, &lt;Wn&gt;, &lt;Xm&gt;</hint>
			<hint page="1181" header="SHA1 hash update (choose)" doc_id="armv8arm" token="SHA1C">SHA1C &lt;Qd&gt;, &lt;Sn&gt;, &lt;Vm&gt;.4S</hint>
			<hint page="1182" header="SHA1 fixed rotate " doc_id="armv8arm" token="SHA1H">SHA1H &lt;Sd&gt;, &lt;Sn&gt;</hint>
			<hint page="1183" header="SHA1 hash update (majority)" doc_id="armv8arm" token="SHA1M">SHA1M &lt;Qd&gt;, &lt;Sn&gt;, &lt;Vm&gt;.4S</hint>
			<hint page="1184" header="SHA1 hash update (parity)" doc_id="armv8arm" token="SHA1P">SHA1P &lt;Qd&gt;, &lt;Sn&gt;, &lt;Vm&gt;.4S</hint>
			<hint page="1185" header="SHA1 schedule update 0" doc_id="armv8arm" token="SHA1SU0">SHA1SU0 &lt;Vd&gt;.4S, &lt;Vn&gt;.4S, &lt;Vm&gt;.4S</hint>
			<hint page="1186" header="SHA1 schedule update 1" doc_id="armv8arm" token="SHA1SU1">SHA1SU1 &lt;Vd&gt;.4S, &lt;Vn&gt;.4S</hint>
			<hint page="1187" header="SHA256 hash update (part 2)" doc_id="armv8arm" token="SHA256H2">SHA256H2 &lt;Qd&gt;, &lt;Qn&gt;, &lt;Vm&gt;.4S</hint>
			<hint page="1188" header="SHA256 hash update (part 1)" doc_id="armv8arm" token="SHA256H">SHA256H &lt;Qd&gt;, &lt;Qn&gt;, &lt;Vm&gt;.4S</hint>
			<hint page="1189" header="SHA256 schedule update 0" doc_id="armv8arm" token="SHA256SU0">SHA256SU0 &lt;Vd&gt;.4S, &lt;Vn&gt;.4S</hint>
			<hint page="1190" header="SHA256 schedule update 1" doc_id="armv8arm" token="SHA256SU1">SHA256SU1 &lt;Vd&gt;.4S, &lt;Vn&gt;.4S, &lt;Vm&gt;.4S</hint>
		</group>
	</elements>
</documentation>